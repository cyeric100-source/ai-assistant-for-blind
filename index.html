<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI è¦–éšœåŠ©ç† - æ–‡å­—è®€å–å°ˆå®¶</title>
    
    <!-- å¼•å…¥ Marked.js è§£æ Markdown -->
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/lib/marked.umd.min.js"></script>
    
    <!-- å¼•å…¥ DOMPurify é€²è¡Œ HTML æ¶ˆæ¯’ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.8/purify.min.js"></script>

    <!-- ã€æ ¸å¿ƒè¨­å®šã€‘PDF.js v4.0.379 (ä½¿ç”¨ç©©å®šç‰ˆæœ¬) -->
    <script type="module">
        if (window.location.protocol === 'file:') {
            document.documentElement.innerHTML = `
                <body style="background:#000; color:#fff; display:flex; flex-direction:column; justify-content:center; align-items:center; height:100vh; margin:0; font-family:sans-serif;">
                    <h1 style="color:yellow; font-size:2.5rem; text-align:center;">âš ï¸ ç’°å¢ƒéŒ¯èª¤</h1>
                    <p style="font-size:1.5rem; text-align:center; max-width:800px; line-height:1.6;">
                        è«‹å°‡æ­¤å°ˆæ¡ˆä¸Šå‚³è‡³ <strong>GitHub</strong> ä¸¦é€é GitHub Pages é–‹å•Ÿã€‚
                    </p>
                </body>
            `;
            throw new Error("Local execution blocked.");
        }

        const PDF_BASE = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.0.379/pdf.min.mjs';
        const WORKER_URL = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.0.379/pdf.worker.min.mjs';

        async function initPdfSystem() {
            try {
                const pdfjsLib = await import(PDF_BASE);
                window.pdfjsLib = pdfjsLib;
                pdfjsLib.GlobalWorkerOptions.workerSrc = WORKER_URL;
                console.log("PDF System Initialized");
                window.dispatchEvent(new Event('pdfjs-loaded'));
            } catch (e) {
                console.error("PDF Init Failed:", e);
                window.reportError("PDF æ ¸å¿ƒè¼‰å…¥å¤±æ•— (CDN)", e);
                const btn = document.getElementById('pdf-start-btn');
                if (btn) {
                    btn.innerText = "âš ï¸ éŒ¯èª¤ï¼šPDF æ ¸å¿ƒå¤±æ•—";
                    btn.classList.add('danger');
                    btn.disabled = true;
                }
            }
        }
        initPdfSystem();
    </script>
    
    <style>
        :root {
            --bg-color: #000000;
            --text-color: #FFFFFF;
            --accent-color: #FFFF00;
            --user-header-color: #0088ff;
            --ai-header-color: #FFFF00;
            --border-color: #555;
            --input-bg: #1A1A1A;
            --button-bg: #FFFF00;
            --button-text: #000000;
            --status-bg: #222;
            --tool-bg: #112233;
            --nav-bg: #111;
            --nav-active-bg: #333;
        }

        /* å…¨å±€é‡ç½®èˆ‡ä½ˆå±€ */
        * { box-sizing: border-box; }
        
        body {
            font-family: system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0; padding: 0;
            font-size: 1.1rem; line-height: 1.5;
            height: 100dvh;
            display: grid;
            grid-template-rows: auto 1fr auto;
            overflow: hidden;
        }

        /* 1. é ‚éƒ¨ç‹€æ…‹åˆ— */
        header {
            background: var(--status-bg);
            border-bottom: 1px solid var(--border-color);
            z-index: 100;
            flex-shrink: 0;
        }

        #status-bar {
            padding: 8px; text-align: center; font-weight: bold;
            font-size: 1rem; color: #fff;
            transition: background-color 0.3s;
        }
        #status-bar.ready { background: #004400; }
        #status-bar.busy { background: #664400; }
        #status-bar.error { background: #660000; }
        #status-bar.recording { background: #aa0000; animation: pulse 1s infinite; }
        
        #visual-progress {
            background: #333; color: #88ccff; font-size: 0.85rem; 
            text-align: center; padding: 2px; display: none;
        }
        #visual-progress.active { display: block; }

        /* 2. ä¸»å…§å®¹å€åŸŸ (Tab Views) */
        main {
            position: relative;
            overflow: hidden;
            background: var(--bg-color);
        }

        .view-section {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            overflow-y: auto;
            padding: 15px;
            display: none;
            flex-direction: column;
        }

        .view-section.active {
            display: flex;
        }
        
        /* [Chat View] ç‰¹åˆ¥ä½ˆå±€ */
        #view-chat {
            padding: 0; 
        }
        #chat-container {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            padding-bottom: 20px;
        }
        #input-area-wrapper {
            flex-shrink: 0;
            background: #111;
            border-top: 1px solid var(--border-color);
            padding: 10px;
        }

        /* 3. åº•éƒ¨å°èˆªæ¬„ */
        .bottom-nav {
            background: var(--nav-bg);
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: space-around;
            align-items: center;
            height: 70px;
            flex-shrink: 0;
            z-index: 200;
        }

        .nav-btn {
            background: transparent; border: none;
            color: #888;
            font-size: 0.9rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            flex: 1;
            height: 100%;
            cursor: pointer;
            padding: 5px;
        }
        .nav-btn span.icon { font-size: 1.5rem; margin-bottom: 4px; display: block; }
        .nav-btn.active {
            color: var(--accent-color);
            background: var(--nav-active-bg);
            border-top: 3px solid var(--accent-color);
        }
        .nav-btn:focus-visible { outline: 3px solid var(--accent-color); box-shadow: inset 0 0 10px #fff; }

        /* é€šç”¨å…ƒä»¶æ¨£å¼ */
        h2 { 
            font-size: 1.3rem; color: #88ccff; border-bottom: 2px solid #333; 
            padding-bottom: 5px; margin-top: 0; margin-bottom: 15px;
        }
        h3 { color: #ccc; margin: 15px 0 10px 0; font-size: 1.1rem; }

        input, select, textarea {
            width: 100%; padding: 12px; margin-bottom: 15px;
            background: var(--input-bg); border: 1px solid var(--border-color);
            color: var(--text-color); font-size: 1.1rem; border-radius: 6px;
        }
        
        button.action-btn {
            width: 100%; padding: 14px; font-size: 1.1rem; font-weight: bold;
            border-radius: 8px; margin-bottom: 12px; cursor: pointer;
            background-color: var(--button-bg); color: var(--button-text); border: none;
        }
        button.secondary { background-color: #333; color: #fff; border: 1px solid #777; }
        button.danger { background-color: #550000; color: #ffcccc; border: 1px solid #ff4444; }
        button.high-contrast { background-color: #FFD700; color: #000; border: 2px solid #FFF; font-size: 1.2rem; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }

        /* OCR çµæœå€å°ˆç”¨æ¨£å¼ */
        #quick-ocr-output {
            background: #111; border: 2px solid #444; border-radius: 8px;
            padding: 15px; min-height: 100px; margin-top: 10px;
            white-space: pre-wrap; word-break: break-word;
        }
        #quick-ocr-output:focus { outline: 3px solid var(--accent-color); background: #222; }

        /* å°è©±æ°£æ³¡æ¨£å¼ */
        .message {
            background: #111; padding: 15px; margin-bottom: 20px;
            border-left: 5px solid var(--border-color);
            border-radius: 4px;
        }
        .message.user { border-left-color: var(--user-header-color); background: #0a0a1a; }
        .message.assistant { border-left-color: var(--ai-header-color); background: #1a1a0a; }
        .message h1.msg-heading { font-size: 1rem; color: #888; margin: 0 0 5px 0; border: none; }
        
        /* è¼¸å…¥å€æ¨£å¼ */
        .input-row { display: flex; gap: 8px; align-items: flex-end; }
        #user-input { min-height: 60px; max-height: 150px; margin-bottom: 0; resize: none; }
        #voice-btn { 
            width: 60px; height: 60px; border-radius: 50%; 
            display: flex; align-items: center; justify-content: center;
            font-size: 1.5rem; padding: 0; margin: 0;
            flex-shrink: 0;
        }
        #voice-btn.recording { background-color: #ff3333 !important; animation: pulse 1s infinite; }
        #submit-btn { width: 70px; height: 60px; margin: 0; flex-shrink: 0; padding: 5px; font-size: 1rem; }
        
        /* Utility Row & Checkbox */
        .utility-row { display: flex; gap: 10px; margin-bottom: 10px; overflow-x: auto; padding-bottom: 5px; align-items: center; }
        .utility-row button { white-space: nowrap; font-size: 0.9rem; padding: 8px 12px; margin: 0; width: auto; flex-shrink: 0; }

        /* æ¨™æº– Checkbox æ¨£å¼ (å°è©±é å°ˆç”¨) */
        .chat-check-btn {
            display: inline-flex; align-items: center;
            background: #333; border: 1px solid #777; color: #fff;
            padding: 8px 12px; border-radius: 6px;
            font-size: 0.9rem; cursor: pointer; white-space: nowrap;
            user-select: none;
        }
        .chat-check-btn input {
            width: 18px; height: 18px; margin: 0 8px 0 0;
            accent-color: var(--accent-color); /* å¼·èª¿è‰² */
        }
        /* å‹¾é¸æ™‚é«˜äº® */
        .chat-check-btn:has(input:checked) {
            border-color: var(--accent-color);
            background: #2a2a00;
        }

        /* è¨­å®šé æ¨£å¼ */
        .settings-card {
            background: #1a1a1a; padding: 15px; border-radius: 8px;
            border: 1px solid #333; margin-bottom: 20px;
        }
        
        .check-btn {
            display: flex; align-items: center; background: #222; padding: 10px;
            border-radius: 6px; margin-bottom: 10px; border: 1px solid #444;
        }
        .check-btn input { width: 25px; height: 25px; margin: 0 10px 0 0; }

        .hidden { display: none !important; }
        .visually-hidden { position: absolute; width: 1px; height: 1px; overflow: hidden; clip: rect(0,0,0,0); }
        
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }

        /* é›»è…¦ç‰ˆé©é…ï¼šå´é‚Šæ¬„ */
        @media (min-width: 768px) {
            body {
                grid-template-rows: auto 1fr;
                grid-template-columns: 200px 1fr;
            }
            header { grid-column: 1 / -1; }
            .bottom-nav {
                grid-row: 2; grid-column: 1;
                flex-direction: column; justify-content: flex-start;
                height: 100%; padding-top: 20px;
                border-top: none; border-right: 1px solid var(--border-color);
            }
            .nav-btn { height: auto; padding: 20px; width: 100%; border-top: none; border-left: 4px solid transparent; }
            .nav-btn.active { border-top: none; border-left-color: var(--accent-color); }
            main { grid-row: 2; grid-column: 2; }
        }
    </style>
</head>
<body>

    <!-- 1. é ‚éƒ¨ç‹€æ…‹ -->
    <header role="banner">
        <div id="status-bar" role="status" aria-live="polite">ç³»çµ±å·²å•Ÿå‹•ï¼Œè«‹é¸æ“‡åŠŸèƒ½</div>
        <div id="visual-progress" aria-hidden="true"></div>
    </header>

    <!-- 2. ä¸»å…§å®¹å€ (åŒ…å«ä¸‰å€‹è¦–åœ–) -->
    <main>
        <!-- A. å°è©±è¦–åœ– (Chat View) -->
        <section id="view-chat" class="view-section active" role="tabpanel" aria-labelledby="tab-chat">
            <div id="chat-container">
                <div class="message assistant">
                    <h1 class="msg-heading">AI åŠ©ç†ï¼š</h1>
                    <div class="markdown-body">ä½ å¥½ï¼æˆ‘æ˜¯ä½ çš„ AI è¦–éšœåŠ©ç†ã€‚å·²å•Ÿç”¨å…¨åŠŸèƒ½å®‰å…¨ä»£ç† (æ”¯æ´å¤§å‹æª”æ¡ˆ)ã€‚è«‹è¼¸å…¥æ–‡å­—ã€ä¸Šå‚³åœ–ç‰‡/PDFï¼Œæˆ–ä½¿ç”¨èªéŸ³é€²è¡Œå°è©±ã€‚</div>
                </div>
                <div id="chat-output"></div>
            </div>

            <!-- è¼¸å…¥æ§åˆ¶å€ (å›ºå®šåœ¨å°è©±é åº•éƒ¨) -->
            <div id="input-area-wrapper">
                <div class="utility-row">
                    <!-- 1. æª”æ¡ˆä¸Šå‚³æŒ‰éˆ• -->
                    <button type="button" id="upload-btn" class="secondary" onclick="document.getElementById('file-input').click()">ğŸ“ æª”æ¡ˆ/æ‹ç…§</button>
                    
                    <!-- 2. æš«åœå‚³é€ Checkbox -->
                    <label class="chat-check-btn">
                        <input type="checkbox" id="pause-send">
                        <span>æš«åœç™¼é€</span>
                    </label>

                    <!-- 3. æ¸…é™¤æŒ‰éˆ• -->
                    <button type="button" id="new-chat-btn" class="danger" onclick="resetConversation()">ğŸ—‘ï¸ æ¸…é™¤</button>
                    
                    <!-- éš±è—çš„ File Input -->
                    <input type="file" id="file-input" class="visually-hidden" accept="*/*" onchange="handleFileSelect()">
                </div>
                
                <form onsubmit="handleSubmit(event)" class="input-row">
                    <button type="button" id="voice-btn" class="secondary" title="èªéŸ³è¼¸å…¥ (æŒ‰ä½ä¸æ”¾)" aria-label="èªéŸ³è¼¸å…¥">ğŸ¤</button>
                    <textarea id="user-input" placeholder="è¼¸å…¥è¨Šæ¯..." rows="1" aria-label="è¼¸å…¥è¨Šæ¯å€"></textarea>
                    <button type="submit" id="submit-btn" title="ç™¼é€">å‚³é€</button>
                </form>
            </div>
        </section>

        <!-- B. å·¥å…·è¦–åœ– (Tools View) -->
        <section id="view-tools" class="view-section" role="tabpanel" aria-labelledby="tab-tools">
            <h2 tabindex="-1" id="tools-title">æ–‡å­—è®€å– (Reader)</h2>
            
            <!-- æ–°å¢ï¼šå¿«é€Ÿ OCR åŠŸèƒ½å€å¡Š -->
            <div class="settings-card" style="border-color: var(--accent-color);">
                <h3>ğŸ“¸ Chandra OCR</h3>
                <input type="file" id="quick-ocr-input" class="visually-hidden" accept="image/*,application/pdf" onchange="handleQuickOCRFileSelect()">
                
                <button type="button" id="quick-ocr-btn" class="action-btn high-contrast" onclick="triggerQuickOCR()">
                    ğŸ“¸ æ‹æ” / å–å¾—æ–‡å­— (å¼·åˆ¶ä½¿ç”¨ Chandra)
                </button>
                <p style="font-size:0.9rem; color:#aaa;">* æŒ‰ Alt + O å¿«é€Ÿå•Ÿå‹•ã€‚çµæœå°‡ç›´æ¥é¡¯ç¤ºæ–¼ä¸‹æ–¹ã€‚</p>
                
                <!-- çµæœé¡¯ç¤ºå€ï¼Œæ”¯æ´ç„¦é»å°èˆª -->
                <div id="quick-ocr-output" role="region" aria-label="æ–‡å­—è­˜åˆ¥çµæœ" tabindex="-1">
                    (ç­‰å¾…æ‹æ”...)
                </div>
            </div>

            <div class="settings-card">
                <h3>ğŸ“„ ä¿—æ¥­è®€å– (General Reader)</h3>
                <p style="color:#aaa; font-size:0.9rem;">
                    2025 æ–°åŠŸèƒ½ï¼šçµåˆã€Œæ–‡å­—å±¤ã€èˆ‡ã€Œè¦–è¦º AIã€é€²è¡Œé€é æ ¡å°ã€‚
                    å³ä½¿è¶…é 100 é ä¹Ÿèƒ½å®Œæ•´è¼¸å‡ºä¸éºæ¼ã€‚
                </p>
                <input type="file" id="pdf-tool-input" class="visually-hidden" accept="application/pdf" onchange="handlePDFToolFileSelect()">
                
                <button type="button" id="pdf-start-btn" class="action-btn" onclick="document.getElementById('pdf-tool-input').click()" disabled>
                    é¸æ“‡ PDF æª”æ¡ˆä¸¦åˆ†æ
                </button>
                
                <div style="margin-top:10px;">
                    <label class="check-btn">
                        <input type="checkbox" id="pdf-translate"> <span>OCR å¾Œç¿»è­¯æˆç¹é«”ä¸­æ–‡</span>
                    </label>
                </div>
            </div>

            <div class="settings-card">
                <h3>ğŸ’¾ è³‡æ–™åŒ¯å‡º (Export)</h3>
                <button type="button" id="copy-btn" class="action-btn secondary hidden" onclick="copyResult()">è¤‡è£½å…¨éƒ¨å°è©±</button>
                <button type="button" id="export-txt-btn" class="action-btn secondary hidden" onclick="exportChat('txt')">åŒ¯å‡ºç‚º TXT</button>
                <button type="button" id="export-html-btn" class="action-btn secondary hidden" onclick="exportChat('html')">åŒ¯å‡ºç‚º HTML</button>
                <p style="color:#777; font-size:0.9rem;">* åŒ¯å‡ºæŒ‰éˆ•å°‡åœ¨æœ‰å°è©±å…§å®¹å¾Œé¡¯ç¤ºã€‚</p>
            </div>
        </section>

        <!-- C. è¨­å®šè¦–åœ– (Settings View) -->
        <section id="view-settings" class="view-section" role="tabpanel" aria-labelledby="tab-settings">
            <h2 tabindex="-1" id="settings-title">ç³»çµ±è¨­å®š (Settings)</h2>

            <div id="settings-area">
                <div class="settings-card">
                    <h3>ğŸ¤– AI å°è©±æ¨¡å‹è¨­å®š</h3>
                    <div style="background: #442200; color: #ffcc88; padding: 8px; border-radius: 4px; margin-bottom: 10px; font-size: 0.9rem;">
                        âš ï¸ 2025 æç¤ºï¼šæ¨è–¦ä½¿ç”¨ Google Gemini æˆ– OpenRouterã€‚
                    </div>
                    
                    <label>ä¸»è¦æœå‹™å•† (å°è©±/åˆ†æ):</label>
                    <select id="provider-select" onchange="handleProviderChange(true)">
                        <option value="gemini">Google Gemini (æ¨è–¦)</option>
                        <option value="openrouter">OpenRouter (æ¨è–¦)</option>
                        <option value="openai">OpenAI</option>
                        <option value="groq">Groq</option>
                        <option value="mistral">Mistral AI</option>
                        <option value="perplexity">Perplexity</option>
                    </select>

                    <label>å°è©± AI API Key:</label>
                    <input type="password" id="api-key" placeholder="åœ¨æ­¤è²¼ä¸Šæ‚¨çš„ API Key" autocomplete="off">
                    
                    <label>æ¨¡å‹éæ¿¾:</label>
                    <input type="text" id="model-filter-input" placeholder="è¼¸å…¥é—œéµå­—ç¯©é¸..." oninput="handleModelFilter()">
                    
                    <label>é¸æ“‡æ¨¡å‹:</label>
                    <div style="display:flex; gap:10px;">
                        <select id="model-select" onchange="handleModelSelectChange()" style="margin-bottom:0;"></select>
                        <button type="button" id="refresh-btn" class="secondary" onclick="fetchOnlineModels()" style="width:auto; margin:0;">æ›´æ–°</button>
                    </div>
                    <div id="custom-model-wrapper" class="hidden" style="margin-top:10px;">
                        <input type="text" id="custom-model-input" placeholder="æ‰‹å‹•è¼¸å…¥æ¨¡å‹ ID" onchange="handleCustomInputChange()">
                    </div>
                </div>

                <!-- æ–°å¢ï¼šChandra OCR å°ˆå±¬è¨­å®š -->
                <div class="settings-card" style="border-left: 5px solid #ff00ff;">
                    <h3>ğŸ“¸ Chandra OCR è¨­å®š (Datalab)</h3>
                    <p style="font-size:0.9rem; color:#ccc;">æ­¤è¨­å®šå°ˆç”¨æ–¼ã€Œæ–‡å­—è®€å–ã€åŠŸèƒ½ä¸­çš„å¿«é€Ÿ OCRã€‚</p>
                    
                    <label>Datalab API Key:</label>
                    <input type="password" id="datalab-key" placeholder="åœ¨æ­¤è¼¸å…¥ Chandra / Datalab API Key">
                    
                    <label>è¾¨è­˜ç²¾ç¢ºåº¦ (Accuracy):</label>
                    <select id="datalab-mode">
                        <option value="fast">å¿«é€Ÿ (Fast)</option>
                        <option value="balanced" selected>å¹³è¡¡ (Balanced)</option>
                        <option value="accurate">é«˜ç²¾ç¢ºåº¦ (Accurate) - è²»ç”¨è¼ƒé«˜</option>
                    </select>
                    <p style="font-size:0.9rem; color:#aaa;">* ã€Œé«˜ç²¾ç¢ºåº¦ã€æ¨¡å¼æœƒå¼·åˆ¶é€²è¡Œå®Œæ•´åˆ†æï¼Œé©åˆæ‰‹å¯«æˆ–è¤‡é›œæ’ç‰ˆï¼Œä½†æ¶ˆè€—é»æ•¸è¼ƒå¤šã€‚</p>
                </div>

                <div class="settings-card">
                    <h3>ğŸ› ï¸ ä»»å‹™åˆ†å·¥ (Task Assignment)</h3>
                    <div style="display:flex; flex-wrap:wrap; gap:10px;">
                        <button type="button" class="secondary" onclick="setSpecificConfig('ocr')" style="flex:1;">è¨­ç‚º OCR å°ˆç”¨</button>
                        <button type="button" class="secondary" onclick="setSpecificConfig('translate')" style="flex:1;">è¨­ç‚º ç¿»è­¯ å°ˆç”¨</button>
                        <button type="button" class="danger" onclick="clearSpecificConfigs()" style="flex:1;">é‡ç½®åˆ†å·¥</button>
                    </div>
                    <div id="config-status-display" aria-live="polite" style="margin-top:10px; color:#aaa; font-size:0.9rem;"></div>
                </div>

                <div class="settings-card">
                    <h3>ğŸ¤ èªéŸ³èˆ‡æ“ä½œ</h3>
                    <select id="voice-engine" onchange="saveVoiceSettings()">
                        <option value="browser">ç€è¦½å™¨åŸç”Ÿ (å…è²»)</option>
                        <option value="openai">OpenAI Whisper (ä»˜è²»)</option>
                        <option value="groq">Groq Whisper (å¿«é€Ÿ)</option>
                    </select>
                    <input type="password" id="voice-api-key" placeholder="èªéŸ³å°ˆç”¨ Key (é¸å¡«)" onchange="saveVoiceSettings()">
                    
                    <label class="check-btn">
                        <input type="checkbox" id="enter-to-send" checked> <span>æŒ‰ Enter éµå‚³é€</span>
                    </label>
                    <label class="check-btn" id="openrouter-settings" class="hidden">
                        <input type="checkbox" id="openrouter-web-search"> <span>å•Ÿç”¨è¯ç¶²æœå°‹ (OpenRouter)</span>
                    </label>
                    
                    <label>å›æ‡‰é€¾æ™‚ (ç§’):</label>
                    <input type="number" id="timeout-setting" value="120">
                </div>

                <div class="settings-card">
                    <h3>ğŸ“ ç³»çµ±æŒ‡ä»¤ (System Prompts)</h3>
                    <div class="utility-row">
                        <button type="button" id="tab-chat" class="secondary" onclick="switchPromptEditor('chat')">ä¸€èˆ¬å°è©±</button>
                        <button type="button" id="tab-ocr" class="secondary" onclick="switchPromptEditor('ocr')">OCR å°ˆç”¨</button>
                        <button type="button" id="tab-translate" class="secondary" onclick="switchPromptEditor('translate')">ç¿»è­¯å°ˆç”¨</button>
                    </div>
                    <textarea id="system-prompt" rows="5" placeholder="åœ¨æ­¤è¼¸å…¥ç³»çµ±æŒ‡ä»¤..."></textarea>
                </div>

                <div class="settings-card" style="border-color: #550000;">
                    <h3>ğŸ› éŒ¯èª¤æ—¥èªŒ (Debug)</h3>
                    <textarea id="error-log-area" readonly rows="5" placeholder="ç„¡éŒ¯èª¤"></textarea>
                    <button type="button" class="secondary" onclick="copyErrorLog()">è¤‡è£½æ—¥èªŒ</button>
                </div>

                <button type="button" class="action-btn" onclick="saveSettings()">å„²å­˜æ‰€æœ‰è¨­å®š</button>
                <button type="button" class="action-btn secondary" onclick="restoreDefaults()">æ¢å¾©é è¨­å€¼</button>
            </div>
        </section>
    </main>

    <!-- 3. åº•éƒ¨å°èˆªæ¬„ -->
    <nav class="bottom-nav" role="tablist">
        <button type="button" class="nav-btn active" id="nav-chat" role="tab" aria-selected="true" aria-controls="view-chat" onclick="switchTab('chat')">
            <span class="icon">ğŸ’¬</span>
            <span>å°è©±</span>
        </button>
        <button type="button" class="nav-btn" id="nav-tools" role="tab" aria-selected="false" aria-controls="view-tools" onclick="switchTab('tools')">
            <span class="icon">ğŸ› ï¸</span>
            <span>æ–‡å­—è®€å–</span>
        </button>
        <button type="button" class="nav-btn" id="nav-settings" role="tab" aria-selected="false" aria-controls="view-settings" onclick="switchTab('settings')">
            <span class="icon">âš™ï¸</span>
            <span>è¨­å®š</span>
        </button>
    </nav>

    <script>
        // --- æ ¸å¿ƒè®Šæ•¸ï¼šCloudflare Worker ä»£ç† ---
        const USER_WORKER_URL = "https://ai-helper-for-blind.cyeric20.workers.dev/";

        // --- å…¨åŸŸè®Šæ•¸ï¼šé»æ€§è¨˜æ†¶ã€æ­·å²ç´€éŒ„ã€ä¸Šä¸€å€‹åˆ†é  ---
        let stickyMemory = { type: null, content: null, mime: null, count: 0 };
        let lastActiveTabId = 'chat'; 
        
        // --- æ ¸å¿ƒ 1: åˆ†é åˆ‡æ›é‚è¼¯ ---
        function switchTab(tabId) {
            document.querySelectorAll('.view-section').forEach(el => el.classList.remove('active'));
            document.querySelectorAll('.nav-btn').forEach(el => {
                el.classList.remove('active');
                el.setAttribute('aria-selected', 'false');
            });

            const targetView = document.getElementById(`view-${tabId}`);
            const targetNav = document.getElementById(`nav-${tabId}`);
            
            if (targetView && targetNav) {
                targetView.classList.add('active');
                targetNav.classList.add('active');
                targetNav.setAttribute('aria-selected', 'true');
                if (tabId === 'chat') document.getElementById('user-input').focus();
                else { const title = document.getElementById(`${tabId}-title`); if (title) title.focus(); }
            }
            
            if (tabId !== 'settings') {
                lastActiveTabId = tabId;
            }
        }

        // --- æ ¸å¿ƒ 2: åŸå§‹èˆ‡æ–°å¢é‚è¼¯ ---
        
        class UniversalTextNormalizer {
            static getScriptType(char) {
                if (!char) return 'other';
                const code = char.charCodeAt(0);
                if ((code >= 0x4E00 && code <= 0x9FFF) || (code >= 0x3040 && code <= 0x30FF) || (code >= 0xAC00 && code <= 0xD7AF)) return 'cjk';
                if ((code >= 0x0E00 && code <= 0x0E7F) || (code >= 0x1780 && code <= 0x17FF)) return 'sea';
                if ((code >= 0x0600 && code <= 0x06FF) || (code >= 0x0590 && code <= 0x05FF)) return 'rtl';
                if ((code >= 0x0041 && code <= 0x005A) || (code >= 0x0061 && code <= 0x007A) || (code >= 0x0030 && code <= 0x0039) || (code >= 0x00C0 && code <= 0x024F)) return 'latin';
                return 'other';
            }
            static normalize(text) {
                if (!text) return "";
                let res = text.replace(/\r\n/g, "\n").replace(/\r/g, "\n").replace(/([a-zA-Z])-\n([a-zA-Z])/g, "$1$2");
                const lines = res.split("\n");
                let processed = "";
                for (let i = 0; i < lines.length; i++) {
                    let curr = lines[i].trim();
                    if (curr.length === 0) { processed += "\n\n"; continue; }
                    if (i < lines.length - 1) {
                        let next = lines[i + 1].trim();
                        if (next.length === 0) { processed += curr + "\n"; continue; }
                        let lastChar = curr.slice(-1);
                        let nextChar = next.charAt(0);
                        const typeA = this.getScriptType(lastChar);
                        const typeB = this.getScriptType(nextChar);
                        if ((typeA === 'cjk' || typeA === 'sea') && (typeB === 'cjk' || typeB === 'sea')) processed += curr; 
                        else if ((typeA === 'cjk' && typeB === 'latin') || (typeA === 'latin' && typeB === 'cjk')) processed += curr;
                        else if (/^[-*â€¢]/.test(next) || /^[-*â€¢]/.test(curr)) processed += curr + "\n";
                        else processed += curr + " ";
                    } else { processed += curr; }
                }
                processed = processed.replace(/([\u2e80-\u9fff])\s+([\u2e80-\u9fff])/g, "$1$2");
                processed = processed.replace(/([\u2e80-\u9fff])\s+([a-zA-Z0-9])/g, "$1$2");
                processed = processed.replace(/([a-zA-Z0-9])\s+([\u2e80-\u9fff])/g, "$1$2");
                return processed.replace(/\n{3,}/g, "\n\n").trim();
            }
        }

        window.reportError = function(msg, errObj) {
            const time = new Date().toLocaleTimeString();
            const errText = errObj ? (errObj.stack || errObj.message || JSON.stringify(errObj)) : "N/A";
            const logArea = document.getElementById('error-log-area');
            if (logArea) logArea.value += `[${time}] ${msg}\n${errText}\n----------------\n`;
            console.error(msg, errObj);
            updateStatusBar(`éŒ¯èª¤: ${msg}`, 'error');
            playAudioCue('error');
        };

        window.addEventListener('pdfjs-loaded', () => {
            const btn = document.getElementById('pdf-start-btn');
            if (btn) {
                btn.innerText = "ğŸ“„ é¸æ“‡ PDF æª”æ¡ˆä¸¦åˆ†æ";
                btn.disabled = false;
            }
            showReadyStatus();
        });

        const DEFAULT_CHAT_PROMPT = `# Persona
You are a top-tier AI visual and information assistant dedicated to serving visually impaired individuals. Your core duty is to act as an extension of the user's eyes and brain, providing information that is safe, precise, and easy to receive via Screen Reader software.

# Global Rules
Regardless of the task, you must strictly adhere to the following three major principles:

1. **Language Standards**:
   - **Sole Output Language**: Traditional Chinese (Hong Kong style vocabulary).
   - **Translation Requirement**: If the source data is in a foreign language, you must digest and translate it into fluent Chinese. It is **strictly prohibited** to display the original text in the output (unless the user specifically requests a comparison).

2. **Accessibility Format**:
   - **Markdown Structure**: You must utilize \`#\` (headings) and \`-\` (lists) to establish a clear hierarchy, facilitating navigation by screen readers.
   - **Symbol Ban**: It is **strictly prohibited** to output \`[ ]\` (square brackets) or \`{ }\` (curly braces) or any decorative symbols that might interfere with the reading rhythm. When citing sources, state them directly in the narrative; do not use notations like \`[1]\`.

3. **Content Style**:
   - Provided the information is rich, the text must be concise and refined, avoiding redundancy. The main points must be placed at the very beginning.`;

        // ã€æ›´æ–°ã€‘ç¬¬ä¸€å°ˆå±¬æŒ‡ä»¤ï¼šæ··åˆæ¨¡å¼ (æ–‡å­—+åœ–ç‰‡)
        const HYBRID_PROMPT = `# SYSTEM ROLE
You are a specialized "Hybrid OCR & Accessibility Engine" for visually impaired users.
You will receive two inputs for a single PDF page:
1. **Raw Text**: Extracted via software (may contain garbled text/mojibake).
2. **Page Image**: The visual ground truth.

# MISSION
Reconstruct the page content into perfect **Markdown** format by cross-referencing the Raw Text and the Page Image.

# STRICT EXECUTION RULES
1. **Zero Omission Policy**:
   - Transcribe EVERY single character visible in the image.
   - Do NOT summarize. Do NOT skip headers, footers, or sidebars.
   - If the "Raw Text" is incomplete, rely on the "Page Image" to fill in the gaps.

2. **Image Description (Accessibility)**:
   - If the page contains charts, diagrams, or photos, you must insert a description block in the exact location.
   - Format: \`> ğŸ–¼ï¸ [åœ–ç‰‡æè¿°]: <Detailed description in Traditional Chinese (Hong Kong)>\`
   - Description must be objective and detailed (colors, positions, text inside image).

3. **Format & Language**:
   - Use strict Markdown (Headers \`#\`, Lists \`-\`, Tables \`| |\`).
   - If the content is in a foreign language, translate it to **Traditional Chinese (Hong Kong)** immediately.
   - If the content is already Chinese, preserve it exactly.

# OUTPUT
Output ONLY the final Markdown content. No conversational filler (e.g., "Here is the text").`;

        // ã€æ›´æ–°ã€‘ç¬¬äºŒå°ˆå±¬æŒ‡ä»¤ï¼šç´”è¦–è¦ºæ¨¡å¼ (åƒ…åœ–ç‰‡)
        const VISUAL_PROMPT = `# SYSTEM ROLE
You are a high-precision "Visual OCR Expert" for visually impaired users.
You will receive a **Page Image**.

# MISSION
Visually recognize and transcribe all text from the image into **Markdown**, and describe any visual elements.

# STRICT EXECUTION RULES
1. **Verbatim Transcription**:
   - Transcribe text exactly as seen. Do NOT summarize or paraphrase.
   - Pay attention to multi-column layouts; read from top-left to bottom-right logically.
   - Include page numbers and small print.

2. **Visual Description**:
   - Detect all non-text elements (photos, icons, charts).
   - Insert a description block at the corresponding position.
   - Format: \`> ğŸ–¼ï¸ [åœ–ç‰‡æè¿°]: <Detailed description in Traditional Chinese (Hong Kong)>\`

3. **Format & Language**:
   - Output must be in **Traditional Chinese (Hong Kong)**.
   - If the original text is English/Other, translate it fluently while preserving the original structure.
   - Use Markdown tables for any grid data found in the image.

# OUTPUT
Output ONLY the final Markdown content. Do not output code blocks (\`\`\`markdown) wrapper, just the raw content.`;
        
        // ç‚ºäº†ç›¸å®¹è¨­å®šä»‹é¢çš„ "DEFAULT_OCR_PROMPT"ï¼Œæˆ‘å€‘å…ˆç”¨ HYBRID å¡«å……ï¼Œä½†å¯¦éš›åŸ·è¡Œæœƒå‹•æ…‹åˆ‡æ›
        const DEFAULT_OCR_PROMPT = HYBRID_PROMPT;
        
        const DEFAULT_TRANSLATE_PROMPT = `# ROLE
You are a world-class Translator and Terminologist fluent in all major languages, specializing in "Traditional Chinese (Hong Kong variant)". Your work is defined by three core principles: Faithfulness (ä¿¡), Expressiveness (é”), and Elegance (é›…).

# TASK
Translate the provided input text into high-quality **Traditional Chinese (Hong Kong)**.

# STRICT GUIDELINES (Must Follow)
1. **NO Summarization**: Translate every single sentence. Do not omit any details, technical terms, or explanations.
2. **Localization (Hong Kong Style)**:
   - Use HK-specific vocabulary (e.g., "Smart phone" -> æ™ºèƒ½é›»è©±, "Project" -> å°ˆæ¡ˆ/é …ç›®, "Quality" -> è³ªç´ , "Software" -> è»Ÿä»¶).
   - Avoid Mainland Chinese or Taiwanese idioms unless they are standard in HK professional contexts.
3. **Formatting**: Preserve the original Markdown structure (headings, bullets, links).
4. **No Filler**: Do not output "Here is the translation" or explanations. Just output the translation.

# OUTPUT
Directly provide the final, polished Traditional Chinese translation.`;
        
        const PROMPT_VERSION_KEY = "prompt_ver_2025_release_v8_hybrid_final";

        const PROVIDERS = {
            gemini: { prompt: DEFAULT_CHAT_PROMPT, defaultModel: "gemini-flash-latest", canFetch: true, listUrl: "https://generativelanguage.googleapis.com/v1beta/models?key={KEY}", models: ["gemini-flash-latest", "gemini-2.5-flash", "gemini-2.0-flash", "gemini-1.5-pro", "gemini-1.5-flash"] },
            openrouter: { prompt: DEFAULT_CHAT_PROMPT, defaultModel: "qwen/qwen2.5-vl-72b-instruct", canFetch: true, listUrl: "https://openrouter.ai/api/v1/models", models: ["qwen/qwen2.5-vl-72b-instruct", "openai/gpt-4o-mini", "anthropic/claude-3.5-sonnet", "google/gemini-2.0-flash-001"] },
            // datalab å·²å¾ä¸»è¦å°è©±åˆ—è¡¨ä¸­ç§»é™¤ï¼Œåƒ…ä¿ç•™å…§éƒ¨å®šç¾©ä¾› callAI ä½¿ç”¨
            datalab: { prompt: DEFAULT_OCR_PROMPT, defaultModel: "chandra", canFetch: false, listUrl: "", models: ["chandra"] },
            mistral: { prompt: DEFAULT_CHAT_PROMPT, defaultModel: "mistral-large-latest", canFetch: true, listUrl: "https://api.mistral.ai/v1/models", models: ["mistral-large-latest"] },
            openai: { prompt: DEFAULT_CHAT_PROMPT, defaultModel: "gpt-4o", canFetch: true, listUrl: "https://api.openai.com/v1/models", models: ["gpt-4o"] },
            groq: { prompt: DEFAULT_CHAT_PROMPT, defaultModel: "llama-3.3-70b-versatile", canFetch: true, listUrl: "https://api.groq.com/openai/v1/models", models: ["llama-3.3-70b-versatile"] },
            perplexity: { prompt: DEFAULT_CHAT_PROMPT, defaultModel: "sonar-pro", canFetch: false, models: ["sonar-pro"] }
        };

        let currentActiveModelId = "";
        let selectedFile = null;
        let recognition = null; 
        let mediaRecorder = null;
        let audioChunks = [];
        let chatHistory = [];
        let audioContext = null;
        let allCurrentModels = [];
        let isVoiceRecording = false;
        let specificConfigs = { ocr: null, translate: null };
        let memoryPrompts = { chat: "", ocr: "", translate: "" };
        let currentEditingMode = 'chat'; 

        const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        function ensureAudioContext() {
            if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
            if (audioContext.state === 'suspended') audioContext.resume().catch(e => console.error(e));
        }

        ['click', 'touchstart', 'keydown'].forEach(evt => {
            document.addEventListener(evt, ensureAudioContext, { once: false, passive: true });
        });
        
        document.addEventListener('keydown', handleGlobalShortcuts);

        function initVoiceButtonEvents() {
            const btn = document.getElementById('voice-btn');
            if (!btn) return;
            btn.addEventListener('touchstart', (e) => { e.preventDefault(); ensureAudioContext(); startVoiceRecording(); }, {passive: false});
            btn.addEventListener('touchend', (e) => { e.preventDefault(); stopVoiceRecording(); });
            btn.addEventListener('mousedown', (e) => { ensureAudioContext(); startVoiceRecording(); });
            btn.addEventListener('mouseup', (e) => { stopVoiceRecording(); });
            btn.addEventListener('mouseleave', (e) => { if(isVoiceRecording) stopVoiceRecording(); });
            btn.addEventListener('contextmenu', (e) => e.preventDefault());
        }

        function handleGlobalShortcuts(e) {
            if (!e.altKey || !e.shiftKey) return;
            const key = e.key.toLowerCase();
            
            if (key === 'o') { e.preventDefault(); triggerQuickOCR(); return; }

            if (key === 'v') { e.preventDefault(); ensureAudioContext(); isVoiceRecording ? stopVoiceRecording() : startVoiceRecording(); return; }
            const actions = {
                's': () => switchTab('settings'),
                'c': { id: 'copy-btn' },
                't': { id: 'export-txt-btn' },
                'h': { id: 'export-html-btn' },
                'u': { id: 'upload-btn' },
                'n': { id: 'new-chat-btn' },
                'k': { id: 'submit-btn' },
                'i': { id: 'user-input', type: 'focus' },
                '1': () => switchTab('chat'),
                '2': () => switchTab('tools'),
                '3': () => switchTab('settings')
            };
            if (actions[key]) {
                e.preventDefault(); ensureAudioContext();
                if (typeof actions[key] === 'function') actions[key]();
                else {
                    const target = document.getElementById(actions[key].id);
                    if (target) { if (actions[key].type === 'focus') target.focus(); else target.click(); }
                }
            }
        }

        document.addEventListener('DOMContentLoaded', async () => {
            try {
                if (!localStorage.getItem(PROMPT_VERSION_KEY)) {
                    ['gemini', 'openrouter', 'openai', 'groq', 'perplexity', 'mistral'].forEach(p => localStorage.removeItem(`${p}_prompt`));
                    localStorage.setItem(PROMPT_VERSION_KEY, 'true');
                }
                const savedProvider = localStorage.getItem('provider');
                const savedTimeout = localStorage.getItem('timeout_setting');
                if (savedTimeout) document.getElementById('timeout-setting').value = savedTimeout;
                
                const orSearch = document.getElementById('openrouter-web-search');
                if(orSearch) orSearch.checked = (localStorage.getItem('openrouter_web_search') === 'true');
                
                const savedVoiceEngine = localStorage.getItem('voice_engine');
                if (savedVoiceEngine) document.getElementById('voice-engine').value = savedVoiceEngine;
                const savedVoiceKey = localStorage.getItem('voice_api_key');
                if (savedVoiceKey) document.getElementById('voice-api-key').value = savedVoiceKey;
                const savedEnter = localStorage.getItem('enter_to_send');
                document.getElementById('enter-to-send').checked = (savedEnter === null || savedEnter === 'true');

                // è¼‰å…¥ Chandra OCR è¨­å®š
                const savedDatalabKey = localStorage.getItem('datalab_key');
                if (savedDatalabKey) document.getElementById('datalab-key').value = savedDatalabKey;
                const savedDatalabMode = localStorage.getItem('datalab_mode');
                if (savedDatalabMode) document.getElementById('datalab-mode').value = savedDatalabMode;

                const savedSpecifics = localStorage.getItem('specific_configs');
                if (savedSpecifics) { specificConfigs = JSON.parse(savedSpecifics); }
                updateConfigStatusDisplay();

                memoryPrompts.ocr = localStorage.getItem('custom_prompt_ocr') || DEFAULT_OCR_PROMPT;
                memoryPrompts.translate = localStorage.getItem('custom_prompt_translate') || DEFAULT_TRANSLATE_PROMPT;

                if (savedProvider && PROVIDERS[savedProvider]) {
                    // å¦‚æœä¹‹å‰çš„è¨­å®šæ˜¯ datalab (å› ç‚ºèˆŠç‰ˆæœ‰)ï¼Œå¼·åˆ¶åˆ‡å› gemini
                    if (savedProvider === 'datalab') {
                        document.getElementById('provider-select').value = 'gemini';
                        localStorage.setItem('provider', 'gemini');
                    } else {
                        document.getElementById('provider-select').value = savedProvider;
                    }
                } else {
                    document.getElementById('provider-select').value = 'gemini'; 
                }
                
                handleProviderChange(false); 
                initVoiceSystem();
                initPasteImage();
                initDragAndDrop();
                initEnterKey();
                initVoiceButtonEvents();
                
                const pauseToggle = document.getElementById('pause-send');
                if(pauseToggle) pauseToggle.checked = false;

                const hasKey = document.getElementById('api-key').value.trim().length > 0;
                if (!hasKey) {
                    switchTab('settings');
                    showTransientStatus('è«‹å…ˆè¨­å®š API Key', 'error');
                } else {
                    switchTab('chat');
                }

            } catch (e) { window.reportError("Init Error", e); }
        });

        function triggerQuickOCR() {
            switchTab('tools');
            document.getElementById('quick-ocr-input').click();
        }

        async function handleQuickOCRFileSelect() {
            const input = document.getElementById('quick-ocr-input');
            const file = input.files[0];
            if (!file) return;
            
            // å¾å°ˆç”¨æ¬„ä½æˆ– localStorage è®€å– Datalab Key
            const datalabKey = document.getElementById('datalab-key').value.trim() || localStorage.getItem('datalab_key');
            
            if (!datalabKey) {
                alert("âš ï¸ éŒ¯èª¤ï¼šå¿«é€Ÿ OCR å¿…é ˆè¨­å®š Chandra / Datalab API Keyã€‚\n\nè«‹å‰å¾€ã€Œè¨­å®šã€é é¢çš„ã€ŒğŸ“¸ Chandra OCR è¨­å®šã€å€å¡Šè¼¸å…¥ Keyã€‚");
                switchTab('settings');
                document.getElementById('datalab-key').focus();
                return;
            }

            const outputDiv = document.getElementById('quick-ocr-output');
            outputDiv.innerHTML = '<p>æ­£åœ¨é€é Chandra OCR é€²è¡Œåˆ†æï¼Œè«‹ç¨å€™...</p>';
            outputDiv.focus(); 
            
            updateStatusBar("æ­£åœ¨è­˜åˆ¥æ–‡å­— (Chandra)...", "busy");
            playAudioCue('start');

            try {
                let fileData = await readFileAsBase64(file);
                
                // å¼·åˆ¶ä½¿ç”¨ Datalab å‘¼å«ï¼Œä¸¦å‚³å…¥å°ˆç”¨ Key
                const res = await callAI(
                    'datalab', 
                    DEFAULT_OCR_PROMPT, 
                    [], 
                    "", 
                    fileData,
                    file.type, 
                    null,
                    'chandra',
                    datalabKey 
                );
                
                const safeHTML = DOMPurify.sanitize(marked.parse(res));
                outputDiv.innerHTML = safeHTML;
                
                playAudioCue('success');
                outputDiv.focus();
                updateStatusBar("è­˜åˆ¥å®Œæˆ");
                
            } catch (e) {
                window.reportError("Quick OCR Failed", e);
                outputDiv.innerHTML = `<p style="color:#ff5555; font-weight:bold;">âš ï¸ è­˜åˆ¥å¤±æ•—ï¼š${e.message}</p>`;
                outputDiv.focus();
            }
            input.value = '';
        }

        function switchPromptEditor(mode) {
            const textarea = document.getElementById('system-prompt');
            memoryPrompts[currentEditingMode] = textarea.value;
            currentEditingMode = mode;
            textarea.value = memoryPrompts[mode];
            document.getElementById('tab-chat').classList.toggle('secondary', mode !== 'chat');
            document.getElementById('tab-ocr').classList.toggle('secondary', mode !== 'ocr');
            document.getElementById('tab-translate').classList.toggle('secondary', mode !== 'translate');
            document.getElementById('tab-chat').classList.toggle('active', mode === 'chat'); 
        }

        function setSpecificConfig(type) {
            const provider = document.getElementById('provider-select').value;
            const model = currentActiveModelId;
            specificConfigs[type] = { provider, model };
            localStorage.setItem('specific_configs', JSON.stringify(specificConfigs));
            const currentKey = document.getElementById('api-key').value;
            if (currentKey) localStorage.setItem(`${provider}_key`, currentKey.trim());
            updateConfigStatusDisplay();
            showTransientStatus(`å·²è¨­å®š ${type} å°ˆç”¨æ¨¡å‹`);
        }

        function clearSpecificConfigs() {
            specificConfigs = { ocr: null, translate: null };
            localStorage.removeItem('specific_configs');
            updateConfigStatusDisplay();
            showTransientStatus("å·²é‡ç½®åˆ†å·¥è¨­å®š");
        }

        function updateConfigStatusDisplay() {
            const display = document.getElementById('config-status-display');
            let html = "";
            html += specificConfigs.ocr ? `â€¢ OCR: ${specificConfigs.ocr.provider} / ${specificConfigs.ocr.model}<br>` : "";
            html += specificConfigs.translate ? `â€¢ ç¿»è­¯: ${specificConfigs.translate.provider} / ${specificConfigs.translate.model}` : "";
            display.innerHTML = html || "ç›®å‰è·Ÿéš¨ä¸»è¦è¨­å®š";
        }

        function playAudioCue(type) {
            if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            const now = audioContext.currentTime;
            
            if (type === 'start') { 
                oscillator.type = 'sine'; oscillator.frequency.setValueAtTime(880, now); gainNode.gain.setValueAtTime(0.1, now); oscillator.start(now); oscillator.stop(now + 0.1); 
            } else if (type === 'success') { 
                oscillator.type = 'sine'; oscillator.frequency.setValueAtTime(440, now); oscillator.frequency.exponentialRampToValueAtTime(880, now + 0.15); gainNode.gain.setValueAtTime(0.1, now); oscillator.start(now); oscillator.stop(now + 0.2); 
            } else if (type === 'error') { 
                oscillator.type = 'sawtooth'; oscillator.frequency.setValueAtTime(150, now); gainNode.gain.setValueAtTime(0.15, now); oscillator.start(now); oscillator.stop(now + 0.4); 
            } else if (type === 'abort') {
                oscillator.type = 'triangle'; oscillator.frequency.setValueAtTime(400, now); oscillator.frequency.linearRampToValueAtTime(200, now + 0.1); gainNode.gain.setValueAtTime(0.1, now); oscillator.start(now); oscillator.stop(now + 0.1);
            }
        }

        function resetConversation() {
            chatHistory = []; 
            stickyMemory = { type: null, content: null, mime: null, count: 0 };
            document.getElementById('chat-output').innerHTML = ""; 
            document.getElementById('user-input').value = "";
            selectedFile = null;
            document.getElementById('upload-btn').innerText = "ğŸ“ æª”æ¡ˆ/æ‹ç…§";
            document.getElementById('upload-btn').classList.remove('active');
            document.getElementById('file-input').value = "";
            toggleExportButtons(false);
            showTransientStatus("å°è©±èˆ‡è¨˜æ†¶å·²æ¸…é™¤");
        }

        function handlePDFToolFileSelect() {
            const input = document.getElementById('pdf-tool-input');
            if (input.files.length > 0) {
                processPDFTool(input.files[0]);
            }
            input.value = ""; 
        }
        
        function isCanvasBlank(canvas) {
            try {
                const ctx = canvas.getContext('2d', { willReadFrequently: true });
                const imageData = ctx.getImageData(canvas.width/2 - 25, canvas.height/2 - 25, 50, 50);
                const data = imageData.data;
                for(let i = 0; i < data.length; i += 4) {
                    if (data[i+3] > 0 && (data[i] < 250 || data[i+1] < 250 || data[i+2] < 250)) return false; 
                }
                return true;
            } catch(e) { return false; }
        }

        async function processPDFTool(file) {
            if (typeof window.pdfjsLib === 'undefined') { alert("PDF æ ¸å¿ƒè¼‰å…¥ä¸­..."); return; }
            if (!file || file.type !== 'application/pdf') { alert("è«‹é¸æ“‡ PDF"); return; }
            
            resetConversation(); playAudioCue('start');
            switchTab('chat');
            
            const needTranslate = document.getElementById('pdf-translate').checked;

            try {
                updateStatusBar("æ­£åœ¨åˆå§‹åŒ–æ··åˆé–±è®€æ¨¡å¼...", "busy");
                // æ”¹ç‚ºå…¨æ–°çš„æ··åˆè™•ç†æ¨¡å¼
                await performHybridAIProcessing(file, needTranslate);

            } catch (e) { window.reportError("PDF Process Failed", e); }
        }

        async function performHybridAIProcessing(file, needTranslate) {
            const controller = new AbortController(); 
            let ocrProvider = specificConfigs.ocr ? specificConfigs.ocr.provider : document.getElementById('provider-select').value;
            let ocrModel = specificConfigs.ocr ? specificConfigs.ocr.model : currentActiveModelId;
            let ocrApiKey = (ocrProvider === document.getElementById('provider-select').value) ? document.getElementById('api-key').value : localStorage.getItem(`${ocrProvider}_key`);
            
            // ç‰¹æ®Šè™•ç†ï¼šå¦‚æœæ˜¯ Datalab (Chandra)ï¼Œä½¿ç”¨å…¶å°ˆç”¨ Key
            if (ocrProvider === 'datalab') {
                ocrApiKey = document.getElementById('datalab-key').value || localStorage.getItem('datalab_key');
            }

            if (!ocrApiKey) throw new Error(`ç¼ºå°‘ ${ocrProvider} Key`);

            // å¦‚æœä½¿ç”¨è€…é¸äº† Datalab (Chandra)ï¼Œä½¿ç”¨å…¶å°ˆå±¬çš„ Whole-File OCR
            if (ocrProvider === 'datalab') {
                 updateStatusBar("ä¸Šå‚³æ•´ä»½æ–‡ä»¶è‡³ Chandra OCR...", "busy");
                 let fileData = await readFileAsBase64(file);
                 let fullText = await callAI('datalab', DEFAULT_OCR_PROMPT, [], "", fileData, "application/pdf", controller.signal, 'chandra', ocrApiKey);
                 const aiMsg = addMessage('assistant', UniversalTextNormalizer.normalize(fullText));
                 setTimeout(() => aiMsg.focus(), 100);
                 updateStatusBar("å®Œæˆ");
                 playAudioCue('success');
                 return;
            }

            // ä¸€èˆ¬ AI (Gemini/OpenAI): æ¡ç”¨é€é æ··åˆæ¨¡å¼ (Sequential Hybrid Processing)
            const arrayBuffer = await file.arrayBuffer();
            const pdf = await window.pdfjsLib.getDocument({ data: arrayBuffer, cMapUrl: 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.0.379/cmaps/', cMapPacked: true }).promise;
            
            updateVisualProgress(true, `æº–å‚™è™•ç† ${pdf.numPages} é ...`);
            
            // å»ºç«‹ä¸€å€‹å³æ™‚é¡¯ç¤ºå®¹å™¨ï¼Œå› ç‚ºæˆ‘å€‘è¦ä¸²æµé¡¯ç¤ºæ¯ä¸€é 
            const containerDiv = document.createElement('div');
            containerDiv.className = `message assistant`;
            containerDiv.innerHTML = `<h1 class="msg-heading">AI åŠ©ç† (å³æ™‚è™•ç†ä¸­)ï¼š</h1><div class="markdown-body" id="streaming-output"></div>`;
            document.getElementById('chat-output').appendChild(containerDiv);
            const outputArea = containerDiv.querySelector('#streaming-output');
            toggleExportButtons(true);

            let fullAccumulatedText = "";

            for (let i = 1; i <= pdf.numPages; i++) {
                updateStatusBar(`æ­£åœ¨è™•ç†ç¬¬ ${i} / ${pdf.numPages} é ...`, "busy");
                document.getElementById('visual-progress').innerText = `Page ${i} / ${pdf.numPages}`;

                // 1. å–å¾— Text Layer (æ–‡å­—æç¤º)
                const page = await pdf.getPage(i);
                let textLayerContent = "";
                let hasExtractedText = false;
                
                try {
                    const textContent = await page.getTextContent();
                    textLayerContent = textContent.items.map(item => item.str).join(" ");
                    
                    // --- å¢å¼·é©—è­‰é‚è¼¯ï¼šæ¸…æ´—èˆ‡é©—è­‰ ---
                    const totalLen = textLayerContent.length;
                    
                    // æ¢ä»¶ 1: é•·åº¦å¿…é ˆ <= 8000 ä¸” > 20 (é¿å…æ¥µçŸ­æˆ–æ¥µé•·çš„æ–‡å­—)
                    if (totalLen > 20 && totalLen <= 8000) {
                        
                        // æ¢ä»¶ 2: åƒåœ¾å­—ç¬¦æ¯”ä¾‹æª¢æŸ¥ (Garbage Ratio Check)
                        // æœ‰æ•ˆå­—ç¬¦å®šç¾©ï¼šä¸­æ—¥éŸ“ã€è‹±æ–‡ã€æ•¸å­—ã€ç©ºç™½ã€æ¨™æº–æ¨™é»ç¬¦è™Ÿ
                        const validMatches = textLayerContent.match(/[\u4e00-\u9fff\u3000-\u303f\uff00-\uffef\w\s.,?!:;"'()\[\]{}+-=%$#@]/g) || [];
                        const validCount = validMatches.length;
                        const garbageRatio = 1 - (validCount / totalLen);

                        // åªæœ‰ç•¶äº‚ç¢¼æ¯”ä¾‹å°æ–¼ 30% æ™‚ï¼Œæ‰è¦–ç‚ºæœ‰æ•ˆ
                        if (garbageRatio < 0.3) {
                             hasExtractedText = true;
                        } else {
                             console.warn(`Page ${i}: Garbage ratio too high (${(garbageRatio*100).toFixed(1)}%). Fallback to visual mode.`);
                        }
                    } else if (totalLen > 8000) {
                        console.warn(`Page ${i}: Text too long (${totalLen}). Fallback to visual mode.`);
                    }
                    // -----------------------------

                } catch (e) { console.warn(`Page ${i} text extraction failed`, e); }

                // 2. å–å¾— Visual Layer (å£“ç¸®åœ–ç‰‡)
                const viewportRaw = page.getViewport({ scale: 1.0 });
                // ä½¿ç”¨ 2.0 å€ç‡ä»¥ç¢ºä¿æ–‡å­—æ¸…æ™°ï¼Œä½†é™åˆ¶æœ€å¤§ç¶­åº¦ä»¥é˜² OOM
                const scale = Math.min(1536 / Math.max(viewportRaw.width, viewportRaw.height), 2.0);
                let canvas = document.createElement('canvas');
                canvas.width = page.getViewport({ scale }).width; 
                canvas.height = page.getViewport({ scale }).height;
                await page.render({ canvasContext: canvas.getContext('2d'), viewport: page.getViewport({ scale }) }).promise;
                
                if (isCanvasBlank(canvas)) {
                    canvas.remove();
                    continue; // ç©ºç™½é è·³é
                }
                
                // è½‰ç‚º JPEG æ ¼å¼ï¼Œå“è³ª 0.8ï¼Œå¹³è¡¡æ¸…æ™°åº¦èˆ‡å°åŒ…å¤§å°
                let imgBase64 = canvas.toDataURL('image/jpeg', 0.8).split(',')[1];

                // 3. æ ¹æ“šæå–çµæœé¸æ“‡å°ˆå±¬æŒ‡ä»¤ (Branching Logic)
                let selectedSystemPrompt = "";
                let userPromptContent = "";

                if (hasExtractedText) {
                    // æƒ…æ³ A: æˆåŠŸç²å–æœ‰æ•ˆå­—ç¬¦ -> ä½¿ç”¨æ··åˆæ¨¡å¼ (Hybrid Prompt)
                    // å°‡æå–çš„äº‚ç¢¼/æ–‡å­—ä½œç‚º "Raw Text" å‚³å…¥ï¼Œä¸¦é™„ä¸Šåœ–ç‰‡
                    selectedSystemPrompt = HYBRID_PROMPT;
                    userPromptContent = `[Page ${i} Raw Text Start]\n${textLayerContent.substring(0, 8000)}\n[Page ${i} Raw Text End]\n\nPlease process this page according to the Hybrid rules.`;
                } else {
                    // æƒ…æ³ B: ç²å–å¤±æ•— (ç´”åœ–/æƒæ/äº‚ç¢¼éå¤š/æ–‡å­—éé•·) -> ä½¿ç”¨ç´”è¦–è¦ºæ¨¡å¼ (Visual Prompt)
                    // åƒ…æŒ‡ç¤º AI é–±è®€åœ–ç‰‡
                    selectedSystemPrompt = VISUAL_PROMPT;
                    userPromptContent = `[Page ${i}]\nThis page has no extractable text layer (or text is corrupted). Please perform strict Visual OCR on the image.`;
                }

                // å¦‚æœç”¨æˆ¶å‹¾é¸äº†ç¿»è­¯ï¼Œæˆ‘å€‘åœ¨ User Prompt å°¾ç«¯å†å¼·èª¿ä¸€æ¬¡ï¼Œé›–ç„¶ System Prompt å·²åŒ…å«
                if (needTranslate) {
                    userPromptContent += "\n\nREMINDER: Translate the output into Traditional Chinese (Hong Kong).";
                }

                try {
                    // 4. å‘¼å« AI
                    let pageResult = await callAI(
                        ocrProvider, 
                        selectedSystemPrompt, 
                        [], // No history for OCR pages to save context window
                        userPromptContent, 
                        imgBase64, 
                        "image/jpeg", 
                        controller.signal, 
                        ocrModel, 
                        ocrApiKey
                    );
                    
                    // æ ¼å¼åŒ–è¼¸å‡º
                    let cleanResult = UniversalTextNormalizer.normalize(pageResult);
                    fullAccumulatedText += `${cleanResult}\n\n`;
                    
                    // è¿½åŠ ç¯€é»æ¨¡å¼ (Append Node)
                    const pageNode = document.createElement('div');
                    pageNode.className = 'new-page';
                    pageNode.style.marginBottom = "20px";
                    pageNode.style.borderBottom = "1px dashed #444";
                    pageNode.style.paddingBottom = "20px";
                    // åŠ ä¸Šé ç¢¼æ¨™ç¤ºï¼Œæ–¹ä¾¿é–±è®€
                    pageNode.innerHTML = `<h3>Page ${i}</h3>` + DOMPurify.sanitize(marked.parse(cleanResult));
                    outputArea.appendChild(pageNode);
                    
                } catch (e) {
                    console.error(`Page ${i} AI Error:`, e);
                    const errorNode = document.createElement('div');
                    errorNode.innerHTML = `<p style="color:red">Page ${i} Error: ${e.message}</p>`;
                    outputArea.appendChild(errorNode);
                } finally {
                    // 5. è¨˜æ†¶é«”é‡‹æ”¾ (Critical for long PDFs)
                    canvas.remove();
                    canvas = null;
                    imgBase64 = null;
                }

                // 6. åˆ†é å»¶é² (Stability Delay)
                // Gemini 2.5 Flash é›–ç„¶å¿«ï¼Œä½†ç‚ºäº†é¿å…ç¬é–“ä¸¦ç™¼å°è‡´ç€è¦½å™¨å¡é “æˆ– API 429ï¼Œä¿ç•™çŸ­æš«ç·©è¡
                if (ocrProvider === 'gemini') {
                    await sleep(6000); // 6ç§’
                } else {
                    await sleep(500); // å…¶ä»–æ¨¡å‹ 0.5ç§’
                }
            }

            updateVisualProgress(false);
            updateStatusBar("æ–‡ä»¶è™•ç†å®Œæˆ");
            playAudioCue('success');
            containerDiv.focus();
        }

        function updateVisualProgress(show, text="") {
            const el = document.getElementById('visual-progress');
            if (show) { el.classList.add('active'); el.innerText = text; } 
            else { el.classList.remove('active'); el.innerText = ""; }
        }

        function initVoiceSystem() {
            const engine = document.getElementById('voice-engine').value;
            if (engine === 'browser') initBrowserSpeech(); 
            else if (recognition) { recognition.stop(); recognition = null; }
        }

        function initBrowserSpeech() {
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                recognition = new SpeechRecognition(); 
                recognition.lang = 'zh-HK'; recognition.continuous = true; recognition.interimResults = true; 
                recognition.onstart = () => { isVoiceRecording=true; document.getElementById('voice-btn').classList.add('recording'); updateStatusBar('è†è½ä¸­...', 'recording'); playAudioCue('start'); };
                recognition.onresult = (e) => {
                    let t = ''; for (let i = e.resultIndex; i < e.results.length; ++i) if (e.results[i].isFinal) t += e.results[i][0].transcript;
                    if (t) document.getElementById('user-input').value += (document.getElementById('user-input').value ? " " : "") + t;
                };
                recognition.onerror = () => { stopVoiceInputUI(); playAudioCue('error'); };
                recognition.onend = () => { if(isVoiceRecording) playAudioCue('abort'); stopVoiceInputUI(); };
            }
        }

        function getSupportedMimeType() {
            if (MediaRecorder.isTypeSupported('audio/mp4')) return 'audio/mp4';
            if (MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) return 'audio/webm;codecs=opus';
            if (MediaRecorder.isTypeSupported('audio/webm')) return 'audio/webm';
            return ''; 
        }

        async function startVoiceRecording() {
            ensureAudioContext(); if (isVoiceRecording) return;
            const engine = document.getElementById('voice-engine').value;
            if (engine === 'browser') { if (recognition) try { recognition.start(); } catch(e){} }
            else {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    const mimeType = getSupportedMimeType();
                    const options = mimeType ? { mimeType } : undefined;
                    
                    mediaRecorder = new MediaRecorder(stream, options); 
                    audioChunks = []; 
                    mediaRecorder.ondataavailable = e => audioChunks.push(e.data);
                    mediaRecorder.onstop = async () => { 
                        await processWhisperAudio(new Blob(audioChunks, {type: mediaRecorder.mimeType}), engine, mediaRecorder.mimeType); 
                        stream.getTracks().forEach(t=>t.stop()); 
                    };
                    mediaRecorder.start(); isVoiceRecording = true; document.getElementById('voice-btn').classList.add('recording'); playAudioCue('start');
                } catch (e) { showTransientStatus('éº¥å…‹é¢¨éŒ¯èª¤', 'error'); }
            }
        }

        function stopVoiceRecording() {
            if (!isVoiceRecording) return;
            ensureAudioContext(); isVoiceRecording = false; playAudioCue('success');
            if (document.getElementById('voice-engine').value === 'browser' && recognition) recognition.stop();
            else if (mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop();
        }

        function stopVoiceInputUI() {
            isVoiceRecording = false; document.getElementById('voice-btn').classList.remove('recording');
            if (!document.getElementById('status-bar').classList.contains('busy')) showReadyStatus();
        }

        async function processWhisperAudio(blob, engine, mime) {
            let apiKey = document.getElementById('voice-api-key').value || document.getElementById('api-key').value;
            if (!apiKey) return alert("éœ€ API Key");
            const fd = new FormData(); fd.append('file', blob, `rec.${mime.includes('mp4')?'mp4':'webm'}`);
            fd.append('model', engine === 'openai' ? 'whisper-1' : 'whisper-large-v3');
            updateStatusBar("èªéŸ³è½‰è­¯ä¸­...", "busy");
            try {
                const res = await fetch(engine==='openai'?"https://api.openai.com/v1/audio/transcriptions":"https://api.groq.com/openai/v1/audio/transcriptions", { method:'POST', headers:{'Authorization':`Bearer ${apiKey}`}, body:fd });
                const data = await res.json();
                if (data.text) { document.getElementById('user-input').value += (document.getElementById('user-input').value ? " " : "") + data.text; showReadyStatus(); }
            } catch(e) { window.reportError("Whisper Error", e); }
            finally { stopVoiceInputUI(); }
        }

        function saveVoiceSettings() { localStorage.setItem('voice_engine', document.getElementById('voice-engine').value); localStorage.setItem('voice_api_key', document.getElementById('voice-api-key').value); initVoiceSystem(); }
        function initPasteImage() { document.addEventListener('paste', e => { const f = e.clipboardData.files[0]; if(f && f.type.startsWith('image/')) handleFileSelect(f); }); }
        function initDragAndDrop() { const d = document.getElementById('view-chat'); d.ondragover = e => {e.preventDefault(); d.style.background='#222'}; d.ondragleave = () => d.style.background=''; d.ondrop = e => {e.preventDefault(); d.style.background=''; handleFileSelect(e.dataTransfer.files[0]);}; }
        function initEnterKey() { document.getElementById('user-input').onkeydown = e => { if(e.key==='Enter' && !e.shiftKey && document.getElementById('enter-to-send').checked) { e.preventDefault(); document.getElementById('submit-btn').click(); } }; }
        
        function updateStatusBar(t, s='ready') { 
            const b = document.getElementById('status-bar'); 
            b.setAttribute('aria-live', s === 'error' ? 'assertive' : 'polite');
            b.className = s; 
            b.innerText = t; 
        }

        function showReadyStatus() { updateStatusBar("ç³»çµ±å·²å•Ÿå‹•ï¼Œè«‹é¸æ“‡åŠŸèƒ½"); }
        function showTransientStatus(m, t='success') { updateStatusBar(m, t==='error'?'error':'ready'); setTimeout(()=>{ if(!document.getElementById('status-bar').classList.contains('busy')) showReadyStatus(); }, 3000); }
        
        function addMessage(role, content) {
            const div = document.createElement('div'); div.className = `message ${role}`; div.tabIndex = -1;
            div.innerHTML = `<h1 class="msg-heading">${role==='user'?'æ‚¨ï¼š':'AIï¼š'}</h1><div class="markdown-body" dir="auto">${role==='user'?content:DOMPurify.sanitize(marked.parse(content))}</div>`;
            document.getElementById('chat-output').appendChild(div); 
            toggleExportButtons(true);
            return div;
        }
        function toggleExportButtons(show) { ['copy-btn','export-txt-btn','export-html-btn'].forEach(id=>document.getElementById(id).classList.toggle('hidden', !show)); }
        
        function handleProviderChange(save=true) {
            const p = document.getElementById('provider-select').value; 
            const c = PROVIDERS[p];
            
            // é‡è¦ï¼šæ­¤è™•åƒ…è™•ç†èŠå¤©æœå‹™å•†çš„ Keyï¼ŒDatalab å·²åˆ†é›¢
            if (p !== 'datalab') {
                document.getElementById('api-key').value = localStorage.getItem(`${p}_key`) || "";
            }
            
            memoryPrompts.chat = localStorage.getItem(`${p}_prompt`) || c.prompt;
            if (currentEditingMode === 'chat') document.getElementById('system-prompt').value = memoryPrompts.chat;
            
            const orSet = document.getElementById('openrouter-settings');
            if(orSet) orSet.classList.toggle('hidden', p!=='openrouter');
            
            allCurrentModels = JSON.parse(localStorage.getItem(`${p}_model_list`)) || c.models;
            handleModelFilter();
            currentActiveModelId = localStorage.getItem(`${p}_model`) || c.defaultModel;
            document.getElementById('refresh-btn').style.display = c.canFetch ? 'block' : 'none';
            if(save) localStorage.setItem('provider', p);
            showReadyStatus();
        }
        function handleModelFilter() {
            const f = document.getElementById('model-filter-input').value.toLowerCase();
            updateModelSelect(allCurrentModels.filter(m=>m.toLowerCase().includes(f)), currentActiveModelId);
        }
        function updateModelSelect(list, active) {
            const s = document.getElementById('model-select'); s.innerHTML = "";
            let found = false;
            list.forEach(m => { const o = document.createElement('option'); o.value=m; o.innerText=m; if(m===active) found=true; s.appendChild(o); });
            s.appendChild(new Option("è‡ªè¡Œè¼¸å…¥...", "CUSTOM"));
            const w = document.getElementById('custom-model-wrapper');
            if(found) { s.value=active; w.classList.add('hidden'); } else { s.value="CUSTOM"; w.classList.remove('hidden'); document.getElementById('custom-model-input').value=active; }
        }
        
        async function fetchOnlineModels() {
            const p = document.getElementById('provider-select').value; const k = document.getElementById('api-key').value;
            if(!k && p!=='openrouter') return alert("éœ€ API Key");
            const btn = document.getElementById('refresh-btn'); btn.innerText="è®€å–ä¸­..."; btn.disabled=true;
            try {
                let list=[];
                if(p==='openrouter') list=(await(await fetch("https://openrouter.ai/api/v1/models")).json()).data.map(m=>m.id);
                else if(p==='gemini') list=(await(await fetch(PROVIDERS[p].listUrl.replace('{KEY}',k))).json()).models.filter(m=>m.supportedGenerationMethods?.includes("generateContent")).map(m=>m.name.replace("models/",""));
                else list=(await(await fetch(PROVIDERS[p].listUrl, {headers:{'Authorization':`Bearer ${k}`}})).json()).data.map(m=>m.id);
                
                if(list && list.length > 0) { 
                    localStorage.setItem(`${p}_model_list`, JSON.stringify(list)); 
                    allCurrentModels=list; 
                    handleModelFilter(); 
                    showTransientStatus("æ¨¡å‹æ¸…å–®å·²æ›´æ–°ä¸¦å„²å­˜"); 
                } else {
                    throw new Error("æ‰¾ä¸åˆ°å¯ç”¨æ¨¡å‹");
                }
            } catch(e) { window.reportError("æ›´æ–°å¤±æ•—", e); } 
            finally { btn.innerText="æ›´æ–°"; btn.disabled=false; }
        }

        function handleModelSelectChange() {
            const s = document.getElementById('model-select');
            if(s.value==="CUSTOM") document.getElementById('custom-model-wrapper').classList.remove('hidden');
            else { document.getElementById('custom-model-wrapper').classList.add('hidden'); currentActiveModelId=s.value; }
        }
        function handleCustomInputChange() { currentActiveModelId = document.getElementById('custom-model-input').value.trim(); }
        
        function saveSettings() {
            const p = document.getElementById('provider-select').value;
            const m = document.getElementById('model-select').value==="CUSTOM" ? document.getElementById('custom-model-input').value : document.getElementById('model-select').value;
            memoryPrompts[currentEditingMode] = document.getElementById('system-prompt').value;
            
            // å„²å­˜ä¸€èˆ¬å°è©± AI è¨­å®š
            localStorage.setItem(`${p}_prompt`, memoryPrompts.chat);
            localStorage.setItem('custom_prompt_ocr', memoryPrompts.ocr);
            localStorage.setItem('custom_prompt_translate', memoryPrompts.translate);
            localStorage.setItem(`${p}_key`, document.getElementById('api-key').value.trim());
            localStorage.setItem(`${p}_model`, m); currentActiveModelId = m;
            
            // å„²å­˜ Chandra OCR è¨­å®š
            localStorage.setItem('datalab_key', document.getElementById('datalab-key').value.trim());
            localStorage.setItem('datalab_mode', document.getElementById('datalab-mode').value);

            localStorage.setItem('timeout_setting', document.getElementById('timeout-setting').value);
            localStorage.setItem('enter_to_send', document.getElementById('enter-to-send').checked);
            localStorage.setItem('openrouter_web_search', document.getElementById('openrouter-web-search').checked);
            saveVoiceSettings(); 
            showTransientStatus("è¨­å®šå·²å„²å­˜");
            switchTab(lastActiveTabId || 'chat');
        }

        function restoreDefaults() {
            const p = document.getElementById('provider-select').value; 
            memoryPrompts.chat = PROVIDERS[p].prompt;
            memoryPrompts.ocr = DEFAULT_OCR_PROMPT;
            memoryPrompts.translate = DEFAULT_TRANSLATE_PROMPT;
            localStorage.removeItem(`${p}_prompt`);
            localStorage.removeItem('custom_prompt_ocr');
            localStorage.removeItem('custom_prompt_translate');
            document.getElementById('system-prompt').value = memoryPrompts[currentEditingMode];
            
            // é è¨­æ¨¡å¼
            document.getElementById('datalab-mode').value = 'balanced';

            handleProviderChange(true); 
            showTransientStatus("å·²é‚„åŸé è¨­å€¼");
        }

        function copyResult() { navigator.clipboard.writeText(document.getElementById('chat-output').innerText).then(()=>showTransientStatus("å·²è¤‡è£½")); }
        function copyErrorLog() { navigator.clipboard.writeText(document.getElementById('error-log-area').value).then(()=>showTransientStatus("æ—¥èªŒå·²è¤‡è£½")); }
        function exportChat(fmt) {
            const c = document.getElementById('chat-output');
            const b = new Blob([fmt==='html'?`<html><body>${c.innerHTML}</body></html>`:c.innerText], {type:fmt==='html'?'text/html':'text/plain'});
            const a = document.createElement('a'); a.href = URL.createObjectURL(b); a.download = `export.${fmt}`; a.click();
        }
        
        async function handleFileSelect(f) {
            f = f || document.getElementById('file-input').files[0];
            if(f) { 
                selectedFile = f; 
                document.getElementById('upload-btn').innerText = `å·²é¸: ${f.name.substring(0,8)}...`;
                document.getElementById('upload-btn').classList.add('active'); 
                
                const isPaused = document.getElementById('pause-send').checked;
                if (!isPaused) {
                    showTransientStatus("å³å°‡è‡ªå‹•ç™¼é€...");
                    setTimeout(() => {
                        const event = new Event('submit', { cancelable: true });
                        document.querySelector('form').dispatchEvent(event); 
                    }, 700);
                } else {
                    showTransientStatus("æª”æ¡ˆå·²åŠ å…¥ï¼Œè«‹è¼¸å…¥æ–‡å­—å¾Œç™¼é€"); 
                    document.getElementById('user-input').focus();
                }
            }
        }

        function readFileAsBase64(f) { return new Promise((r,j)=>{const rd=new FileReader(); rd.onload=()=>r(rd.result.split(',')[1]); rd.onerror=j; rd.readAsDataURL(f);}); }
        function readFileAsText(f) { return new Promise((r,j)=>{const rd=new FileReader(); rd.onload=()=>r(rd.result); rd.onerror=j; rd.readAsText(f);}); }

        async function handleSubmit(e) {
            e.preventDefault(); ensureAudioContext();
            const txt = document.getElementById('user-input').value.trim();
            if(!txt && !selectedFile) return showTransientStatus("è«‹è¼¸å…¥å…§å®¹", 'error');
            
            playAudioCue('start'); updateStatusBar("è™•ç†ä¸­...", 'busy');
            const btn = document.getElementById('submit-btn'); btn.disabled=true;
            const ctl = new AbortController(); const tm = setTimeout(()=>ctl.abort(), document.getElementById('timeout-setting').value*1000);
            
            try {
                let input = txt; 
                let fileData = null; 
                let mime = null;

                if(selectedFile) {
                    if(selectedFile.type === 'application/pdf') {
                         const arrayBuffer = await selectedFile.arrayBuffer();
                         const pdf = await window.pdfjsLib.getDocument({ data: arrayBuffer, cMapUrl: 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.0.379/cmaps/', cMapPacked: true }).promise;
                         let pdfText = "";
                         for (let i = 1; i <= pdf.numPages; i++) {
                             const content = await pdf.getPage(i).then(p => p.getTextContent());
                             const str = content.items.map(item => item.str).join(" ");
                             pdfText += `[Page ${i}]\n${str}\n\n`;
                         }
                         
                        if(pdfText) { 
                            const cleanPdfText = UniversalTextNormalizer.normalize(pdfText);
                            input = `[æ–‡ä»¶å…§å®¹]:\n${cleanPdfText}\n\n[ç”¨æˆ¶æå•]:\n${txt}`;
                            stickyMemory = { type: 'text', content: cleanPdfText, count: 3 };
                        }
                    } 
                    else if (selectedFile.type.startsWith('image/')) {
                        fileData = await readFileAsBase64(selectedFile); 
                        mime = selectedFile.type;
                        stickyMemory = { type: 'image', content: fileData, mime: mime, count: 3 };
                    }
                    else if (selectedFile.type.startsWith('text/') || selectedFile.name.endsWith('.txt') || selectedFile.name.endsWith('.md') || selectedFile.name.endsWith('.js') || selectedFile.name.endsWith('.html') || selectedFile.name.endsWith('.css') || selectedFile.name.endsWith('.py')) {
                         const fileText = await readFileAsText(selectedFile);
                         input = `[æ–‡ä»¶å…§å®¹ (${selectedFile.name})]:\n${fileText}\n\n[ç”¨æˆ¶æå•]:\n${txt}`;
                         stickyMemory = { type: 'text', content: fileText, count: 3 };
                    }
                } 
                else if (stickyMemory.count > 0 && stickyMemory.content) {
                    stickyMemory.count--;
                    if (stickyMemory.type === 'image') {
                        fileData = stickyMemory.content;
                        mime = stickyMemory.mime;
                        showTransientStatus(`åœ–ç‰‡è¿½å•æ¨¡å¼ (å‰©é¤˜ ${stickyMemory.count} æ¬¡)`);
                    } else if (stickyMemory.type === 'text') {
                        input = `[æ–‡ä»¶å…§å®¹å›é¡§]:\n${stickyMemory.content}\n\n[ç”¨æˆ¶è¿½å•]:\n${txt}`;
                        showTransientStatus(`æ–‡ä»¶è¿½å•æ¨¡å¼ (å‰©é¤˜ ${stickyMemory.count} æ¬¡)`);
                    }
                }

                addMessage('user', txt || (selectedFile ? `[æª”æ¡ˆ: ${selectedFile.name}]` : "[è¿½å•æ¨¡å¼]"));
                
                document.getElementById('user-input').value = ""; 
                document.getElementById('upload-btn').innerText = "ğŸ“ æª”æ¡ˆ/æ‹ç…§"; 
                document.getElementById('upload-btn').classList.remove('active');
                selectedFile = null;
                
                const res = await callAI(
                    document.getElementById('provider-select').value, 
                    document.getElementById('system-prompt').value,
                    chatHistory, 
                    input, 
                    fileData, 
                    mime, 
                    ctl.signal
                );

                const aiMsg = addMessage('assistant', UniversalTextNormalizer.normalize(res)); 
                setTimeout(() => { aiMsg.focus(); }, 100);

                chatHistory.push({role: 'user', content: input}); 
                chatHistory.push({role: 'assistant', content: res});
                if (chatHistory.length > 20) chatHistory = chatHistory.slice(-20);

                playAudioCue('success'); showReadyStatus();
            } catch(e) { window.reportError("Submit Error", e); } finally { clearTimeout(tm); btn.disabled=false; }
        }

        async function callAI(p, sysPrompt, history, txt, file, mime, sig, ovModel, ovKey) {
            const k = ovKey || document.getElementById('api-key').value; 
            const m = ovModel || currentActiveModelId;
            
            if(!k) throw new Error("éœ€ API Key");

            // --- å€å¡Š 1: Chandra OCR (Datalab) å°ˆç”¨é‚è¼¯ ---
            if (p === 'datalab') {
                if (!file) throw new Error("Chandra OCR åƒ…æ”¯æ´æª”æ¡ˆ/åœ–ç‰‡è¼¸å…¥");
                
                const byteCharacters = atob(file);
                const byteNumbers = new Array(byteCharacters.length);
                for (let i = 0; i < byteCharacters.length; i++) {
                    byteNumbers[i] = byteCharacters.charCodeAt(i);
                }
                const byteArray = new Uint8Array(byteNumbers);
                const blob = new Blob([byteArray], {type: mime || 'application/pdf'});

                const formData = new FormData();
                formData.append('file', blob);
                formData.append('output_format', 'markdown');
                
                // å–å¾— Datalab æ¨¡å¼è¨­å®š (ä¾†è‡ª UI)
                const datalabMode = document.getElementById('datalab-mode').value || 'balanced';
                formData.append('mode', datalabMode); 
                
                const postReq = await fetch(USER_WORKER_URL, {
                    method: 'POST',
                    headers: { 
                        'X-Api-Key': k,
                        'X-Target-Url': 'https://www.datalab.to/api/v1/marker'
                    },
                    body: formData,
                    signal: sig
                });
                
                if (!postReq.ok) {
                    const errText = await postReq.text();
                    throw new Error(`Datalab Upload Failed: ${errText}`);
                }
                
                const postData = await postReq.json();
                const requestId = postData.request_id;
                
                while (true) {
                    if (sig && sig.aborted) throw new Error("ä½¿ç”¨è€…å–æ¶ˆæ“ä½œ");
                    
                    await new Promise(r => setTimeout(r, 1000));
                    
                    const checkReq = await fetch(USER_WORKER_URL, {
                        method: 'GET', 
                        headers: { 
                            'X-Api-Key': k,
                            'X-Target-Url': `https://www.datalab.to/api/v1/marker/${requestId}`
                        },
                        signal: sig
                    });
                    
                    if (!checkReq.ok) throw new Error("Datalab Check Failed");
                    
                    const checkData = await checkReq.json();
                    
                    if (checkData.status === 'complete') {
                        const resultMd = checkData.markdown || (checkData.result ? checkData.result.markdown : null) || JSON.stringify(checkData);
                        return resultMd;
                    } else if (checkData.status === 'failed') {
                        throw new Error(`Datalab Processing Failed: ${checkData.error || 'Unknown error'}`);
                    }
                }
            }
            
            // --- å€å¡Š 2: é€šç”¨ Chat AI (Gemini, OpenRouter...) ---
            
            let url = "", headers = { "Content-Type": "application/json", "Authorization": `Bearer ${k}` };
            let bodyObj = {};
            
            if(p === 'gemini') {
                url = `https://generativelanguage.googleapis.com/v1beta/models/${m}:generateContent?key=${k}`;
                delete headers['Authorization']; 
                
                let bodyContent = { 
                    system_instruction: { parts: [{ text: sysPrompt }] },
                    contents: [],
                    // ã€ä¿®æ­£ã€‘å¼·åˆ¶åŠ å…¥å®‰å…¨è¨­å®šï¼Œå…è¨±æ‰€æœ‰å…§å®¹é€šé
                    safetySettings: [
                        { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" },
                        { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" },
                        { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_NONE" },
                        { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_NONE" },
                        { category: "HARM_CATEGORY_CIVIC_INTEGRITY", threshold: "BLOCK_NONE" }
                    ]
                };
                history.forEach(msg => {
                    bodyContent.contents.push({
                        role: msg.role === 'user' ? 'user' : 'model',
                        parts: [{ text: msg.content }]
                    });
                });
                let currentParts = [];
                if (file) {
                    currentParts.push({ inline_data: { mime_type: mime || "image/jpeg", data: file } });
                }
                currentParts.push({ text: txt });
                bodyContent.contents.push({ role: "user", parts: currentParts });
                
                bodyObj = bodyContent;
            } 
            else {
                if (p === 'openrouter') {
                    url = "https://openrouter.ai/api/v1/chat/completions";
                    if(document.getElementById('openrouter-web-search').checked) bodyObj.plugins = [{id:"web"}];
                } else if (p === 'mistral') url = "https://api.mistral.ai/v1/chat/completions";
                else if (p === 'perplexity') url = "https://api.perplexity.ai/chat/completions";
                else if (p === 'openai') url = "https://api.openai.com/v1/chat/completions";
                else url = "https://api.groq.com/openai/v1/chat/completions";

                let messages = [];
                messages.push({ role: "system", content: sysPrompt });
                history.forEach(msg => {
                    messages.push({ role: msg.role, content: msg.content });
                });
                let currentContent = [];
                if (file) {
                    currentContent.push({ type: "text", text: txt });
                    currentContent.push({ type: "image_url", image_url: { url: `data:${mime};base64,${file}` } });
                } else {
                    currentContent = txt;
                }
                messages.push({ role: "user", content: currentContent });

                bodyObj = { ...bodyObj, model: m, messages: messages, temperature: 0.3 };
            }

            headers['X-Target-Url'] = url; 

            const r = await fetch(USER_WORKER_URL, {
                method: 'POST',
                headers: headers, 
                body: JSON.stringify(bodyObj), 
                signal: sig
            });

            if(!r.ok) throw new Error(await r.text());
            const d = await r.json();
            
            return p === 'gemini' ? (d.candidates?.[0]?.content?.parts?.[0]?.text) : (d.choices?.[0]?.message?.content);
        }
    </script>
</body>
</html>