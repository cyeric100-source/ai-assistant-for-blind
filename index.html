<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI è¦–éšœåŠ©ç† (2025 è¨˜æ†¶å¢å¼·ç‰ˆ)</title>
    
    <!-- å¼•å…¥ Marked.js è§£æ Markdown -->
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/lib/marked.umd.min.js"></script>
    
    <!-- å¼•å…¥ DOMPurify é€²è¡Œ HTML æ¶ˆæ¯’ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.8/purify.min.js"></script>

    <!-- ã€æ ¸å¿ƒè¨­å®šã€‘PDF.js v5.4.449 -->
    <script type="module">
        if (window.location.protocol === 'file:') {
            document.documentElement.innerHTML = `
                <body style="background:#000; color:#fff; display:flex; flex-direction:column; justify-content:center; align-items:center; height:100vh; margin:0; font-family:sans-serif;">
                    <h1 style="color:yellow; font-size:2.5rem; text-align:center;">âš ï¸ ç’°å¢ƒéŒ¯èª¤</h1>
                    <p style="font-size:1.5rem; text-align:center; max-width:800px; line-height:1.6;">
                        è«‹å°‡æ­¤å°ˆæ¡ˆä¸Šå‚³è‡³ <strong>GitHub</strong> ä¸¦é€é GitHub Pages é–‹å•Ÿã€‚
                    </p>
                </body>
            `;
            throw new Error("Local execution blocked.");
        }

        const PDF_BASE = './pdf-dist/pdf.mjs';
        const WORKER_URL = './pdf-dist/pdf.worker.mjs';

        async function initPdfSystem() {
            try {
                const response = await fetch(PDF_BASE, { method: 'HEAD' });
                if (!response.ok) throw new Error("æ‰¾ä¸åˆ°æ ¸å¿ƒæª”æ¡ˆ");
                const pdfjsLib = await import(PDF_BASE);
                window.pdfjsLib = pdfjsLib;
                pdfjsLib.GlobalWorkerOptions.workerSrc = WORKER_URL;
                console.log("PDF System Initialized");
                window.dispatchEvent(new Event('pdfjs-loaded'));
            } catch (e) {
                console.error("PDF Init Failed:", e);
                window.reportError("PDF æ ¸å¿ƒè¼‰å…¥å¤±æ•—", e);
                const btn = document.getElementById('pdf-start-btn');
                if (btn) {
                    btn.innerText = "âš ï¸ éŒ¯èª¤ï¼šæ‰¾ä¸åˆ° pdf-dist";
                    btn.classList.add('danger');
                    btn.disabled = true;
                }
            }
        }
        initPdfSystem();
    </script>
    
    <style>
        :root {
            --bg-color: #000000;
            --text-color: #FFFFFF;
            --accent-color: #FFFF00;
            --user-header-color: #0088ff;
            --ai-header-color: #FFFF00;
            --border-color: #555;
            --input-bg: #1A1A1A;
            --button-bg: #FFFF00;
            --button-text: #000000;
            --status-bg: #222;
            --tool-bg: #112233;
            --nav-bg: #111;
            --nav-active-bg: #333;
        }

        /* å…¨å±€é‡ç½®èˆ‡ä½ˆå±€ */
        * { box-sizing: border-box; }
        
        body {
            font-family: system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0; padding: 0;
            font-size: 1.1rem; line-height: 1.5;
            height: 100dvh;
            display: grid;
            grid-template-rows: auto 1fr auto;
            overflow: hidden;
        }

        /* 1. é ‚éƒ¨ç‹€æ…‹åˆ— */
        header {
            background: var(--status-bg);
            border-bottom: 1px solid var(--border-color);
            z-index: 100;
            flex-shrink: 0;
        }

        #status-bar {
            padding: 8px; text-align: center; font-weight: bold;
            font-size: 1rem; color: #fff;
            transition: background-color 0.3s;
        }
        #status-bar.ready { background: #004400; }
        #status-bar.busy { background: #664400; }
        #status-bar.error { background: #660000; }
        #status-bar.recording { background: #aa0000; animation: pulse 1s infinite; }
        
        #visual-progress {
            background: #333; color: #88ccff; font-size: 0.85rem; 
            text-align: center; padding: 2px; display: none;
        }
        #visual-progress.active { display: block; }

        /* 2. ä¸»å…§å®¹å€åŸŸ (Tab Views) */
        main {
            position: relative;
            overflow: hidden;
            background: var(--bg-color);
        }

        .view-section {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            overflow-y: auto;
            padding: 15px;
            display: none;
            flex-direction: column;
        }

        .view-section.active {
            display: flex;
        }
        
        /* [Chat View] ç‰¹åˆ¥ä½ˆå±€ */
        #view-chat {
            padding: 0; 
        }
        #chat-container {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            padding-bottom: 20px;
        }
        #input-area-wrapper {
            flex-shrink: 0;
            background: #111;
            border-top: 1px solid var(--border-color);
            padding: 10px;
        }

        /* 3. åº•éƒ¨å°èˆªæ¬„ */
        .bottom-nav {
            background: var(--nav-bg);
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: space-around;
            align-items: center;
            height: 70px;
            flex-shrink: 0;
            z-index: 200;
        }

        .nav-btn {
            background: transparent; border: none;
            color: #888;
            font-size: 0.9rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            flex: 1;
            height: 100%;
            cursor: pointer;
            padding: 5px;
        }
        .nav-btn span.icon { font-size: 1.5rem; margin-bottom: 4px; display: block; }
        .nav-btn.active {
            color: var(--accent-color);
            background: var(--nav-active-bg);
            border-top: 3px solid var(--accent-color);
        }
        .nav-btn:focus-visible { outline: 3px solid var(--accent-color); box-shadow: inset 0 0 10px #fff; }

        /* é€šç”¨å…ƒä»¶æ¨£å¼ */
        h2 { 
            font-size: 1.3rem; color: #88ccff; border-bottom: 2px solid #333; 
            padding-bottom: 5px; margin-top: 0; margin-bottom: 15px;
        }
        h3 { color: #ccc; margin: 15px 0 10px 0; font-size: 1.1rem; }

        input, select, textarea {
            width: 100%; padding: 12px; margin-bottom: 15px;
            background: var(--input-bg); border: 1px solid var(--border-color);
            color: var(--text-color); font-size: 1.1rem; border-radius: 6px;
        }
        
        button.action-btn {
            width: 100%; padding: 14px; font-size: 1.1rem; font-weight: bold;
            border-radius: 8px; margin-bottom: 12px; cursor: pointer;
            background-color: var(--button-bg); color: var(--button-text); border: none;
        }
        button.secondary { background-color: #333; color: #fff; border: 1px solid #777; }
        button.danger { background-color: #550000; color: #ffcccc; border: 1px solid #ff4444; }
        button.high-contrast { background-color: #FFD700; color: #000; border: 2px solid #FFF; font-size: 1.2rem; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }

        /* OCR çµæœå€å°ˆç”¨æ¨£å¼ */
        #quick-ocr-output {
            background: #111; border: 2px solid #444; border-radius: 8px;
            padding: 15px; min-height: 100px; margin-top: 10px;
            white-space: pre-wrap; word-break: break-word;
        }
        #quick-ocr-output:focus { outline: 3px solid var(--accent-color); background: #222; }

        /* å°è©±æ°£æ³¡æ¨£å¼ */
        .message {
            background: #111; padding: 15px; margin-bottom: 20px;
            border-left: 5px solid var(--border-color);
            border-radius: 4px;
        }
        .message.user { border-left-color: var(--user-header-color); background: #0a0a1a; }
        .message.assistant { border-left-color: var(--ai-header-color); background: #1a1a0a; }
        .message h1.msg-heading { font-size: 1rem; color: #888; margin: 0 0 5px 0; border: none; }
        
        /* è¼¸å…¥å€æ¨£å¼ */
        .input-row { display: flex; gap: 8px; align-items: flex-end; }
        #user-input { min-height: 60px; max-height: 150px; margin-bottom: 0; resize: none; }
        #voice-btn { 
            width: 60px; height: 60px; border-radius: 50%; 
            display: flex; align-items: center; justify-content: center;
            font-size: 1.5rem; padding: 0; margin: 0;
            flex-shrink: 0;
        }
        #voice-btn.recording { background-color: #ff3333 !important; animation: pulse 1s infinite; }
        #submit-btn { width: 70px; height: 60px; margin: 0; flex-shrink: 0; padding: 5px; font-size: 1rem; }
        
        /* Utility Row & Checkbox */
        .utility-row { display: flex; gap: 10px; margin-bottom: 10px; overflow-x: auto; padding-bottom: 5px; align-items: center; }
        .utility-row button { white-space: nowrap; font-size: 0.9rem; padding: 8px 12px; margin: 0; width: auto; flex-shrink: 0; }

        /* æ¨™æº– Checkbox æ¨£å¼ (å°è©±é å°ˆç”¨) */
        .chat-check-btn {
            display: inline-flex; align-items: center;
            background: #333; border: 1px solid #777; color: #fff;
            padding: 8px 12px; border-radius: 6px;
            font-size: 0.9rem; cursor: pointer; white-space: nowrap;
            user-select: none;
        }
        .chat-check-btn input {
            width: 18px; height: 18px; margin: 0 8px 0 0;
            accent-color: var(--accent-color); /* å¼·èª¿è‰² */
        }
        /* å‹¾é¸æ™‚é«˜äº® */
        .chat-check-btn:has(input:checked) {
            border-color: var(--accent-color);
            background: #2a2a00;
        }

        /* è¨­å®šé æ¨£å¼ */
        .settings-card {
            background: #1a1a1a; padding: 15px; border-radius: 8px;
            border: 1px solid #333; margin-bottom: 20px;
        }
        
        .check-btn {
            display: flex; align-items: center; background: #222; padding: 10px;
            border-radius: 6px; margin-bottom: 10px; border: 1px solid #444;
        }
        .check-btn input { width: 25px; height: 25px; margin: 0 10px 0 0; }

        .hidden { display: none !important; }
        .visually-hidden { position: absolute; width: 1px; height: 1px; overflow: hidden; clip: rect(0,0,0,0); }
        
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }

        /* é›»è…¦ç‰ˆé©é…ï¼šå´é‚Šæ¬„ */
        @media (min-width: 768px) {
            body {
                grid-template-rows: auto 1fr;
                grid-template-columns: 200px 1fr;
            }
            header { grid-column: 1 / -1; }
            .bottom-nav {
                grid-row: 2; grid-column: 1;
                flex-direction: column; justify-content: flex-start;
                height: 100%; padding-top: 20px;
                border-top: none; border-right: 1px solid var(--border-color);
            }
            .nav-btn { height: auto; padding: 20px; width: 100%; border-top: none; border-left: 4px solid transparent; }
            .nav-btn.active { border-top: none; border-left-color: var(--accent-color); }
            main { grid-row: 2; grid-column: 2; }
        }
    </style>
</head>
<body>

    <!-- 1. é ‚éƒ¨ç‹€æ…‹ -->
    <header role="banner">
        <div id="status-bar" role="status" aria-live="polite">ç³»çµ±åˆå§‹åŒ–ä¸­...</div>
        <div id="visual-progress" aria-hidden="true"></div>
    </header>

    <!-- 2. ä¸»å…§å®¹å€ (åŒ…å«ä¸‰å€‹è¦–åœ–) -->
    <main>
        <!-- A. å°è©±è¦–åœ– (Chat View) -->
        <section id="view-chat" class="view-section active" role="tabpanel" aria-labelledby="tab-chat">
            <div id="chat-container">
                <div class="message assistant">
                    <h1 class="msg-heading">AI åŠ©ç†ï¼š</h1>
                    <div class="markdown-body">ä½ å¥½ï¼æˆ‘æ˜¯ä½ çš„ AI è¦–éšœåŠ©ç†ã€‚è«‹è¼¸å…¥æ–‡å­—ã€ä¸Šå‚³åœ–ç‰‡/PDFï¼Œæˆ–ä½¿ç”¨èªéŸ³é€²è¡Œå°è©±ã€‚</div>
                </div>
                <div id="chat-output"></div>
            </div>

            <!-- è¼¸å…¥æ§åˆ¶å€ (å›ºå®šåœ¨å°è©±é åº•éƒ¨) -->
            <div id="input-area-wrapper">
                <div class="utility-row">
                    <!-- 1. æª”æ¡ˆä¸Šå‚³æŒ‰éˆ• -->
                    <button type="button" id="upload-btn" class="secondary" onclick="document.getElementById('file-input').click()">ğŸ“ æª”æ¡ˆ/æ‹ç…§</button>
                    
                    <!-- 2. æš«åœå‚³é€ Checkbox -->
                    <label class="chat-check-btn">
                        <input type="checkbox" id="pause-send">
                        <span>æš«åœç™¼é€</span>
                    </label>

                    <!-- 3. æ¸…é™¤æŒ‰éˆ• -->
                    <button type="button" id="new-chat-btn" class="danger" onclick="resetConversation()">ğŸ—‘ï¸ æ¸…é™¤</button>
                    
                    <!-- éš±è—çš„ File Input -->
                    <input type="file" id="file-input" class="visually-hidden" accept="*/*" onchange="handleFileSelect()">
                </div>
                
                <form onsubmit="handleSubmit(event)" class="input-row">
                    <button type="button" id="voice-btn" class="secondary" title="èªéŸ³è¼¸å…¥ (æŒ‰ä½ä¸æ”¾)" aria-label="èªéŸ³è¼¸å…¥">ğŸ¤</button>
                    <textarea id="user-input" placeholder="è¼¸å…¥è¨Šæ¯..." rows="1" aria-label="è¼¸å…¥è¨Šæ¯å€"></textarea>
                    <button type="submit" id="submit-btn" title="ç™¼é€">å‚³é€</button>
                </form>
            </div>
        </section>

        <!-- B. å·¥å…·è¦–åœ– (Tools View) -->
        <section id="view-tools" class="view-section" role="tabpanel" aria-labelledby="tab-tools">
            <h2 tabindex="-1" id="tools-title">å·¥å…·ç®± (Tools)</h2>
            
            <!-- æ–°å¢ï¼šå¿«é€Ÿ OCR åŠŸèƒ½å€å¡Š -->
            <div class="settings-card" style="border-color: var(--accent-color);">
                <h3>ğŸ“¸ å¿«é€Ÿæ–‡å­—è­˜åˆ¥ (Quick OCR)</h3>
                <input type="file" id="quick-ocr-input" class="visually-hidden" accept="image/*,application/pdf" onchange="handleQuickOCRFileSelect()">
                
                <button type="button" id="quick-ocr-btn" class="action-btn high-contrast" onclick="triggerQuickOCR()">
                    ğŸ“¸ æ‹æ” / å–å¾—æ–‡å­—
                </button>
                <p style="font-size:0.9rem; color:#aaa;">* æŒ‰ Alt + O å¿«é€Ÿå•Ÿå‹•ã€‚çµæœå°‡ç›´æ¥é¡¯ç¤ºæ–¼ä¸‹æ–¹ã€‚</p>
                
                <!-- çµæœé¡¯ç¤ºå€ï¼Œæ”¯æ´ç„¦é»å°èˆª -->
                <div id="quick-ocr-output" role="region" aria-label="æ–‡å­—è­˜åˆ¥çµæœ" tabindex="-1">
                    (ç­‰å¾…æ‹æ”...)
                </div>
            </div>

            <div class="settings-card">
                <h3>ğŸ“„ PDF æ™ºèƒ½é–±è®€ (OCR & ç¿»è­¯)</h3>
                <input type="file" id="pdf-tool-input" class="visually-hidden" accept="application/pdf" onchange="handlePDFToolFileSelect()">
                
                <button type="button" id="pdf-start-btn" class="action-btn" onclick="document.getElementById('pdf-tool-input').click()" disabled>
                    é¸æ“‡ PDF æª”æ¡ˆä¸¦åˆ†æ
                </button>
                
                <div style="margin-top:10px;">
                    <label class="check-btn">
                        <input type="checkbox" id="pdf-always-ai"> <span>å¼·åˆ¶ä½¿ç”¨ AI OCR (è·³éæ–‡å­—æå–)</span>
                    </label>
                    <label class="check-btn">
                        <input type="checkbox" id="pdf-translate"> <span>OCR å¾Œç¿»è­¯æˆç¹é«”ä¸­æ–‡</span>
                    </label>
                </div>
            </div>

            <div class="settings-card">
                <h3>ğŸ’¾ è³‡æ–™åŒ¯å‡º (Export)</h3>
                <button type="button" id="copy-btn" class="action-btn secondary hidden" onclick="copyResult()">è¤‡è£½å…¨éƒ¨å°è©±</button>
                <button type="button" id="export-txt-btn" class="action-btn secondary hidden" onclick="exportChat('txt')">åŒ¯å‡ºç‚º TXT</button>
                <button type="button" id="export-html-btn" class="action-btn secondary hidden" onclick="exportChat('html')">åŒ¯å‡ºç‚º HTML</button>
                <p style="color:#777; font-size:0.9rem;">* åŒ¯å‡ºæŒ‰éˆ•å°‡åœ¨æœ‰å°è©±å…§å®¹å¾Œé¡¯ç¤ºã€‚</p>
            </div>
        </section>

        <!-- C. è¨­å®šè¦–åœ– (Settings View) -->
        <section id="view-settings" class="view-section" role="tabpanel" aria-labelledby="tab-settings">
            <h2 tabindex="-1" id="settings-title">ç³»çµ±è¨­å®š (Settings)</h2>

            <div id="settings-area">
                <div class="settings-card">
                    <h3>ğŸ¤– AI æ¨¡å‹è¨­å®š</h3>
                    <div style="background: #442200; color: #ffcc88; padding: 8px; border-radius: 4px; margin-bottom: 10px; font-size: 0.9rem;">
                        âš ï¸ 2025 æç¤ºï¼šæ¨è–¦ä½¿ç”¨ Google Gemini æˆ– OpenRouterã€‚
                    </div>
                    
                    <label>ä¸»è¦æœå‹™å•†:</label>
                    <select id="provider-select" onchange="handleProviderChange(true)">
                        <option value="gemini">Google Gemini (æ¨è–¦)</option>
                        <option value="openrouter">OpenRouter (æ¨è–¦)</option>
                        <option value="datalab">Datalab (Chandra OCR)</option>
                        <option value="openai">OpenAI</option>
                        <option value="groq">Groq</option>
                        <option value="mistral">Mistral AI</option>
                        <option value="perplexity">Perplexity</option>
                    </select>

                    <label>API Key:</label>
                    <input type="password" id="api-key" placeholder="åœ¨æ­¤è²¼ä¸Šæ‚¨çš„ API Key" autocomplete="off">
                    
                    <label>æ¨¡å‹éæ¿¾:</label>
                    <input type="text" id="model-filter-input" placeholder="è¼¸å…¥é—œéµå­—ç¯©é¸..." oninput="handleModelFilter()">
                    
                    <label>é¸æ“‡æ¨¡å‹:</label>
                    <div style="display:flex; gap:10px;">
                        <select id="model-select" onchange="handleModelSelectChange()" style="margin-bottom:0;"></select>
                        <button type="button" id="refresh-btn" class="secondary" onclick="fetchOnlineModels()" style="width:auto; margin:0;">æ›´æ–°</button>
                    </div>
                    <div id="custom-model-wrapper" class="hidden" style="margin-top:10px;">
                        <input type="text" id="custom-model-input" placeholder="æ‰‹å‹•è¼¸å…¥æ¨¡å‹ ID" onchange="handleCustomInputChange()">
                    </div>
                </div>

                <div class="settings-card">
                    <h3>ğŸ› ï¸ ä»»å‹™åˆ†å·¥ (Task Assignment)</h3>
                    <div style="display:flex; flex-wrap:wrap; gap:10px;">
                        <button type="button" class="secondary" onclick="setSpecificConfig('ocr')" style="flex:1;">è¨­ç‚º OCR å°ˆç”¨</button>
                        <button type="button" class="secondary" onclick="setSpecificConfig('translate')" style="flex:1;">è¨­ç‚º ç¿»è­¯ å°ˆç”¨</button>
                        <button type="button" class="danger" onclick="clearSpecificConfigs()" style="flex:1;">é‡ç½®åˆ†å·¥</button>
                    </div>
                    <div id="config-status-display" aria-live="polite" style="margin-top:10px; color:#aaa; font-size:0.9rem;"></div>
                </div>

                <div class="settings-card">
                    <h3>ğŸ¤ èªéŸ³èˆ‡æ“ä½œ</h3>
                    <select id="voice-engine" onchange="saveVoiceSettings()">
                        <option value="browser">ç€è¦½å™¨åŸç”Ÿ (å…è²»)</option>
                        <option value="openai">OpenAI Whisper (ä»˜è²»)</option>
                        <option value="groq">Groq Whisper (å¿«é€Ÿ)</option>
                    </select>
                    <input type="password" id="voice-api-key" placeholder="èªéŸ³å°ˆç”¨ Key (é¸å¡«)" onchange="saveVoiceSettings()">
                    
                    <label class="check-btn">
                        <input type="checkbox" id="enter-to-send" checked> <span>æŒ‰ Enter éµå‚³é€</span>
                    </label>
                    <label class="check-btn" id="openrouter-settings" class="hidden">
                        <input type="checkbox" id="openrouter-web-search"> <span>å•Ÿç”¨è¯ç¶²æœå°‹ (OpenRouter)</span>
                    </label>
                    
                    <label>å›æ‡‰é€¾æ™‚ (ç§’):</label>
                    <input type="number" id="timeout-setting" value="120">
                </div>

                <div class="settings-card">
                    <h3>ğŸ“ ç³»çµ±æŒ‡ä»¤ (System Prompts)</h3>
                    <div class="utility-row">
                        <button type="button" id="tab-chat" class="secondary" onclick="switchPromptEditor('chat')">ä¸€èˆ¬å°è©±</button>
                        <button type="button" id="tab-ocr" class="secondary" onclick="switchPromptEditor('ocr')">OCR å°ˆç”¨</button>
                        <button type="button" id="tab-translate" class="secondary" onclick="switchPromptEditor('translate')">ç¿»è­¯å°ˆç”¨</button>
                    </div>
                    <textarea id="system-prompt" rows="5" placeholder="åœ¨æ­¤è¼¸å…¥ç³»çµ±æŒ‡ä»¤..."></textarea>
                </div>

                <div class="settings-card" style="border-color: #550000;">
                    <h3>ğŸ› éŒ¯èª¤æ—¥èªŒ (Debug)</h3>
                    <textarea id="error-log-area" readonly rows="5" placeholder="ç„¡éŒ¯èª¤"></textarea>
                    <button type="button" class="secondary" onclick="copyErrorLog()">è¤‡è£½æ—¥èªŒ</button>
                </div>

                <button type="button" class="action-btn" onclick="saveSettings()">å„²å­˜æ‰€æœ‰è¨­å®š</button>
                <button type="button" class="action-btn secondary" onclick="restoreDefaults()">æ¢å¾©é è¨­å€¼</button>
            </div>
        </section>
    </main>

    <!-- 3. åº•éƒ¨å°èˆªæ¬„ -->
    <nav class="bottom-nav" role="tablist">
        <button type="button" class="nav-btn active" id="nav-chat" role="tab" aria-selected="true" aria-controls="view-chat" onclick="switchTab('chat')">
            <span class="icon">ğŸ’¬</span>
            <span>å°è©±</span>
        </button>
        <button type="button" class="nav-btn" id="nav-tools" role="tab" aria-selected="false" aria-controls="view-tools" onclick="switchTab('tools')">
            <span class="icon">ğŸ› ï¸</span>
            <span>å·¥å…·</span>
        </button>
        <button type="button" class="nav-btn" id="nav-settings" role="tab" aria-selected="false" aria-controls="view-settings" onclick="switchTab('settings')">
            <span class="icon">âš™ï¸</span>
            <span>è¨­å®š</span>
        </button>
    </nav>

    <script>
        // --- å…¨åŸŸè®Šæ•¸ï¼šé»æ€§è¨˜æ†¶ã€æ­·å²ç´€éŒ„ã€ä¸Šä¸€å€‹åˆ†é  ---
        let stickyMemory = { type: null, content: null, mime: null, count: 0 };
        let lastActiveTabId = 'chat'; 
        
        // --- æ ¸å¿ƒ 1: åˆ†é åˆ‡æ›é‚è¼¯ ---
        function switchTab(tabId) {
            document.querySelectorAll('.view-section').forEach(el => el.classList.remove('active'));
            document.querySelectorAll('.nav-btn').forEach(el => {
                el.classList.remove('active');
                el.setAttribute('aria-selected', 'false');
            });

            const targetView = document.getElementById(`view-${tabId}`);
            const targetNav = document.getElementById(`nav-${tabId}`);
            
            if (targetView && targetNav) {
                targetView.classList.add('active');
                targetNav.classList.add('active');
                targetNav.setAttribute('aria-selected', 'true');
                if (tabId === 'chat') document.getElementById('user-input').focus();
                else { const title = document.getElementById(`${tabId}-title`); if (title) title.focus(); }
            }
            
            if (tabId !== 'settings') {
                lastActiveTabId = tabId;
            }
        }

        // --- æ ¸å¿ƒ 2: åŸå§‹èˆ‡æ–°å¢é‚è¼¯ ---
        
        class UniversalTextNormalizer {
            static getScriptType(char) {
                if (!char) return 'other';
                const code = char.charCodeAt(0);
                if ((code >= 0x4E00 && code <= 0x9FFF) || (code >= 0x3040 && code <= 0x30FF) || (code >= 0xAC00 && code <= 0xD7AF)) return 'cjk';
                if ((code >= 0x0E00 && code <= 0x0E7F) || (code >= 0x1780 && code <= 0x17FF)) return 'sea';
                if ((code >= 0x0600 && code <= 0x06FF) || (code >= 0x0590 && code <= 0x05FF)) return 'rtl';
                if ((code >= 0x0041 && code <= 0x005A) || (code >= 0x0061 && code <= 0x007A) || (code >= 0x0030 && code <= 0x0039) || (code >= 0x00C0 && code <= 0x024F)) return 'latin';
                return 'other';
            }
            static normalize(text) {
                if (!text) return "";
                let res = text.replace(/\r\n/g, "\n").replace(/\r/g, "\n").replace(/([a-zA-Z])-\n([a-zA-Z])/g, "$1$2");
                const lines = res.split("\n");
                let processed = "";
                for (let i = 0; i < lines.length; i++) {
                    let curr = lines[i].trim();
                    if (curr.length === 0) { processed += "\n\n"; continue; }
                    if (i < lines.length - 1) {
                        let next = lines[i + 1].trim();
                        if (next.length === 0) { processed += curr + "\n"; continue; }
                        let lastChar = curr.slice(-1);
                        let nextChar = next.charAt(0);
                        const typeA = this.getScriptType(lastChar);
                        const typeB = this.getScriptType(nextChar);
                        if ((typeA === 'cjk' || typeA === 'sea') && (typeB === 'cjk' || typeB === 'sea')) processed += curr; 
                        else if ((typeA === 'cjk' && typeB === 'latin') || (typeA === 'latin' && typeB === 'cjk')) processed += curr;
                        else if (/^[-*â€¢]/.test(next) || /^[-*â€¢]/.test(curr)) processed += curr + "\n";
                        else processed += curr + " ";
                    } else { processed += curr; }
                }
                processed = processed.replace(/([\u2e80-\u9fff])\s+([\u2e80-\u9fff])/g, "$1$2");
                processed = processed.replace(/([\u2e80-\u9fff])\s+([a-zA-Z0-9])/g, "$1$2");
                processed = processed.replace(/([a-zA-Z0-9])\s+([\u2e80-\u9fff])/g, "$1$2");
                return processed.replace(/\n{3,}/g, "\n\n").trim();
            }
        }

        window.reportError = function(msg, errObj) {
            const time = new Date().toLocaleTimeString();
            const errText = errObj ? (errObj.stack || errObj.message || JSON.stringify(errObj)) : "N/A";
            const logArea = document.getElementById('error-log-area');
            if (logArea) logArea.value += `[${time}] ${msg}\n${errText}\n----------------\n`;
            console.error(msg, errObj);
            // ä¿®æ­£ï¼šç¢ºä¿éŒ¯èª¤ç‹€æ…‹èƒ½è§¸ç™¼å¼·åˆ¶èªéŸ³å›é¥‹
            updateStatusBar(`éŒ¯èª¤: ${msg}`, 'error');
            playAudioCue('error');
        };

        window.addEventListener('pdfjs-loaded', () => {
            const btn = document.getElementById('pdf-start-btn');
            if (btn) {
                btn.innerText = "ğŸ“„ é¸æ“‡ PDF æª”æ¡ˆä¸¦åˆ†æ";
                btn.disabled = false;
            }
            showReadyStatus();
        });

        const DEFAULT_CHAT_PROMPT = `# Persona
You are a top-tier AI visual and information assistant dedicated to serving visually impaired individuals. Your core duty is to act as an extension of the user's eyes and brain, providing information that is safe, precise, and easy to receive via Screen Reader software.

# Global Rules
Regardless of the task, you must strictly adhere to the following three major principles:

1. **Language Standards**:
   - **Sole Output Language**: Traditional Chinese (Hong Kong style vocabulary).
   - **Translation Requirement**: If the source data is in a foreign language, you must digest and translate it into fluent Chinese. It is **strictly prohibited** to display the original text in the output (unless the user specifically requests a comparison).

2. **Accessibility Format**:
   - **Markdown Structure**: You must utilize \`#\` (headings) and \`-\` (lists) to establish a clear hierarchy, facilitating navigation by screen readers.
   - **Symbol Ban**: It is **strictly prohibited** to output \`[ ]\` (square brackets) or \`{ }\` (curly braces) or any decorative symbols that might interfere with the reading rhythm. When citing sources, state them directly in the narrative; do not use notations like \`[1]\`.

3. **Content Style**:
   - Provided the information is rich, the text must be concise and refined, avoiding redundancy. The main points must be placed at the very beginning.

---

## Task: Web Search
If a user sends you a question, to ensure data accuracy, even if you believe you know the answer, you must perform an online search to obtain the latest and most accurate information.

## Task: Visual Analysis
When a user uploads an image, process it according to the following classification logic:

### A. If the image contains "Text"
1. **Priority Recognition**: Use high-level visual capabilities to recognize all visible text. If the image is blurry, tilted, or dim, infer the semantics to complete the content.
2. **Translation Output**: List the text content directly. If it is not in Chinese, directly provide a Traditional Chinese translation and explanation; do not retain the original text.

### B. If the image is primarily of "Animals or Plants"
1. **Species Identification**: Search online based on visual features to identify the species.
2. **Background Investigation**: Search online for its scientific name, common name, habits, distribution, and characteristics.
3. **Output**: Write an explanatory article containing the species name and detailed characteristics.

### C. If the image is primarily "Product Packaging (Box/Can/Bottle)"
1. **Information Extraction**: Read the brand, model, and key text on the packaging.
2. **Deep Research**: Use this information as keywords to search online, covering uses, methods of use, very detailed user reviews and comments, and pros/cons.
3. **Output**: Combining "visual information" and "online information," write a complete product guide/shopping advice article. This must include **no fewer than 500 words** of user reviews and comments.

### D. If the image is a "Screenshot" (UI/UX Mode)
1. **Focus Report**: First, point out the item that is currently selected, highlighted, or in focus.
2. **Interface Scan**: List other visible items on the screen.
3. **Status Filtering**:
   - Actionable options (e.g., Checkbox/Switch): Only report "positive status" (e.g., Checked, Enabled/On).
   - If an option is unchecked/disabled, **only read out the item name**; do not report its status.

### E. If the image is a "Brand or Institutional Logo"
1. **Identification**: Identify the brand or organization the logo belongs to. If it cannot be recognized at a glance, use visual features to perform a reverse image search.
2. **Introduction**: Provide a brief background introduction of the entity.

### F. Other Scenarios (Environments, Objects, People, etc.)
1. **Scene Description**: Provide an objective and exhaustive scan of the environment. Describe the overall layout first, then describe important details.
2. If a PDF or other document is received, read the document content, analyze it, and then display the **detailed** key content.
3. If a video, audio, or other media file or URL is received, deeply understand the visual and audio content, and then display the **detailed** key content.`;

        const DEFAULT_OCR_PROMPT = `# SYSTEM ROLE
You are a high-precision OCR (Optical Character Recognition) Engine designed for visually impaired users. You are NOT a conversational assistant. You are a text extraction machine.

# PRIMARY TASK
Your ONLY objective is to transcribe 100% of the visible text from the provided image/PDF document into textual format.

# STRICT COMPLIANCE RULES (ZERO TOLERANCE)
1.  **VERBATIM TRANSCRIPTION**:
    -   Extract EVERY single character, number, symbol, and punctuation mark exactly as seen.
    -   **ABSOLUTELY NO SUMMARIES**. Do not summarize the content.
    -   **ABSOLUTELY NO OMISSIONS**. Do not skip "unimportant" parts like footers, page numbers, or fine print.
    -   **NO DESCRIPTIONS**: Do not describe the image (e.g., never say "This is an invoice"). Just output the text.

2.  **FORMATTING**:
    -   Use **Markdown** to preserve the visual structure (headings, lists, tables).
    -   If there is a table, you MUST output a Markdown table.
    -   If there is text in multiple columns, linearize it logically (column by column).

3.  **ACCURACY & HALLUCINATION DEFENSE**:
    -   If a word is blurry or illegible, mark it as \`[?]\`. Do not guess.
    -   Do not correct spelling errors found in the source text. Transcribe them exactly as they appear.

4.  **MULTILINGUAL SUPPORT**:
    -   Detect the language automatically (Traditional Chinese, English, etc.).
    -   Do not translate unless the text is extracted first. (For this specific specific prompt, purely extract).

# OUTPUT FORMAT
Start immediately with the extracted text. Do not provide any introductory or concluding remarks.`;
        
        const DEFAULT_TRANSLATE_PROMPT = `# ROLE
You are a world-class Translator and Terminologist fluent in all major languages, specializing in "Traditional Chinese (Hong Kong variant)". Your work is defined by three core principles: Faithfulness (ä¿¡), Expressiveness (é”), and Elegance (é›…).

# TASK
Translate the provided input text into high-quality **Traditional Chinese (Hong Kong)**.

# STRICT GUIDELINES (Must Follow)
1. **NO Summarization**: Translate every single sentence. Do not omit any details, technical terms, or explanations.
2. **Localization (Hong Kong Style)**:
   - Use HK-specific vocabulary (e.g., "Smart phone" -> æ™ºèƒ½é›»è©±, "Project" -> å°ˆæ¡ˆ/é …ç›®, "Quality" -> è³ªç´ , "Software" -> è»Ÿä»¶).
   - Avoid Mainland Chinese or Taiwanese idioms unless they are standard in HK professional contexts.
3. **Tone Consistency**: Maintain the original tone (Formal/Casual/Academic) of the source text.
4. **Formatting**: Preserve the original Markdown structure (headings, bullets, links).
5. **No Filler**: Do not output "Here is the translation" or explanations. Just output the translation.

# PROCESS (Internal)
1. **Analyze**: Understand the context, genre, and tone.
2. **Translate**: Convert text to HK Traditional Chinese.
3. **Refine**: Check for flow, naturalness, and strict adherence to HK terminology.

# OUTPUT
Directly provide the final, polished Traditional Chinese translation.`;
        
        const PROMPT_VERSION_KEY = "prompt_ver_2025_release_v6_ocr_feature";

        const PROVIDERS = {
            gemini: { prompt: DEFAULT_CHAT_PROMPT, defaultModel: "gemini-flash-latest", canFetch: true, listUrl: "https://generativelanguage.googleapis.com/v1beta/models?key={KEY}", models: ["gemini-flash-latest", "gemini-2.0-flash-exp", "gemini-1.5-pro", "gemini-1.5-flash"] },
            openrouter: { prompt: DEFAULT_CHAT_PROMPT, defaultModel: "google/gemini-2.0-flash-exp:free", canFetch: true, listUrl: "https://openrouter.ai/api/v1/models", models: ["google/gemini-2.0-flash-exp:free", "openai/gpt-4o", "anthropic/claude-3.5-sonnet"] },
            datalab: { prompt: DEFAULT_OCR_PROMPT, defaultModel: "chandra", canFetch: false, listUrl: "", models: ["chandra"] },
            mistral: { prompt: DEFAULT_CHAT_PROMPT, defaultModel: "mistral-large-latest", canFetch: true, listUrl: "https://api.mistral.ai/v1/models", models: ["mistral-large-latest"] },
            openai: { prompt: DEFAULT_CHAT_PROMPT, defaultModel: "gpt-4o", canFetch: true, listUrl: "https://api.openai.com/v1/models", models: ["gpt-4o"] },
            groq: { prompt: DEFAULT_CHAT_PROMPT, defaultModel: "llama-3.3-70b-versatile", canFetch: true, listUrl: "https://api.groq.com/openai/v1/models", models: ["llama-3.3-70b-versatile"] },
            perplexity: { prompt: DEFAULT_CHAT_PROMPT, defaultModel: "sonar-pro", canFetch: false, models: ["sonar-pro"] }
        };

        let currentActiveModelId = "";
        let selectedFile = null;
        let recognition = null; 
        let mediaRecorder = null;
        let audioChunks = [];
        let chatHistory = [];
        let audioContext = null;
        let allCurrentModels = [];
        let isVoiceRecording = false;
        let specificConfigs = { ocr: null, translate: null };
        let memoryPrompts = { chat: "", ocr: "", translate: "" };
        let currentEditingMode = 'chat'; 

        const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        function ensureAudioContext() {
            if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
            if (audioContext.state === 'suspended') audioContext.resume().catch(e => console.error(e));
        }

        ['click', 'touchstart', 'keydown'].forEach(evt => {
            document.addEventListener(evt, ensureAudioContext, { once: false, passive: true });
        });
        
        document.addEventListener('keydown', handleGlobalShortcuts);

        function initVoiceButtonEvents() {
            const btn = document.getElementById('voice-btn');
            if (!btn) return;
            btn.addEventListener('touchstart', (e) => { e.preventDefault(); ensureAudioContext(); startVoiceRecording(); }, {passive: false});
            btn.addEventListener('touchend', (e) => { e.preventDefault(); stopVoiceRecording(); });
            btn.addEventListener('mousedown', (e) => { ensureAudioContext(); startVoiceRecording(); });
            btn.addEventListener('mouseup', (e) => { stopVoiceRecording(); });
            btn.addEventListener('mouseleave', (e) => { if(isVoiceRecording) stopVoiceRecording(); });
            btn.addEventListener('contextmenu', (e) => e.preventDefault());
        }

        function handleGlobalShortcuts(e) {
            if (!e.altKey || !e.shiftKey) return;
            const key = e.key.toLowerCase();
            
            // æ–°å¢ï¼šAlt + O è§¸ç™¼ Quick OCR
            if (key === 'o') { e.preventDefault(); triggerQuickOCR(); return; }

            if (key === 'v') { e.preventDefault(); ensureAudioContext(); isVoiceRecording ? stopVoiceRecording() : startVoiceRecording(); return; }
            const actions = {
                's': () => switchTab('settings'),
                'c': { id: 'copy-btn' },
                't': { id: 'export-txt-btn' },
                'h': { id: 'export-html-btn' },
                'u': { id: 'upload-btn' },
                'n': { id: 'new-chat-btn' },
                'k': { id: 'submit-btn' },
                'i': { id: 'user-input', type: 'focus' },
                '1': () => switchTab('chat'),
                '2': () => switchTab('tools'),
                '3': () => switchTab('settings')
            };
            if (actions[key]) {
                e.preventDefault(); ensureAudioContext();
                if (typeof actions[key] === 'function') actions[key]();
                else {
                    const target = document.getElementById(actions[key].id);
                    if (target) { if (actions[key].type === 'focus') target.focus(); else target.click(); }
                }
            }
        }

        document.addEventListener('DOMContentLoaded', async () => {
            try {
                if (!localStorage.getItem(PROMPT_VERSION_KEY)) {
                    ['gemini', 'openrouter', 'openai', 'groq', 'perplexity', 'mistral'].forEach(p => localStorage.removeItem(`${p}_prompt`));
                    localStorage.setItem(PROMPT_VERSION_KEY, 'true');
                }
                const savedProvider = localStorage.getItem('provider');
                const savedTimeout = localStorage.getItem('timeout_setting');
                if (savedTimeout) document.getElementById('timeout-setting').value = savedTimeout;
                
                const orSearch = document.getElementById('openrouter-web-search');
                if(orSearch) orSearch.checked = (localStorage.getItem('openrouter_web_search') === 'true');
                
                const savedVoiceEngine = localStorage.getItem('voice_engine');
                if (savedVoiceEngine) document.getElementById('voice-engine').value = savedVoiceEngine;
                const savedVoiceKey = localStorage.getItem('voice_api_key');
                if (savedVoiceKey) document.getElementById('voice-api-key').value = savedVoiceKey;
                const savedEnter = localStorage.getItem('enter_to_send');
                document.getElementById('enter-to-send').checked = (savedEnter === null || savedEnter === 'true');

                const savedSpecifics = localStorage.getItem('specific_configs');
                if (savedSpecifics) { specificConfigs = JSON.parse(savedSpecifics); }
                updateConfigStatusDisplay();

                memoryPrompts.ocr = localStorage.getItem('custom_prompt_ocr') || DEFAULT_OCR_PROMPT;
                memoryPrompts.translate = localStorage.getItem('custom_prompt_translate') || DEFAULT_TRANSLATE_PROMPT;

                if (savedProvider && PROVIDERS[savedProvider]) {
                    document.getElementById('provider-select').value = savedProvider;
                } else {
                    document.getElementById('provider-select').value = 'gemini'; 
                }
                
                handleProviderChange(false); 
                initVoiceSystem();
                initPasteImage();
                initDragAndDrop();
                initEnterKey();
                initVoiceButtonEvents();
                
                // æš«åœå‚³é€é è¨­ä¸å‹¾é¸
                const pauseToggle = document.getElementById('pause-send');
                if(pauseToggle) pauseToggle.checked = false;

                const hasKey = document.getElementById('api-key').value.trim().length > 0;
                if (!hasKey) {
                    switchTab('settings');
                    showTransientStatus('è«‹å…ˆè¨­å®š API Key', 'error');
                } else {
                    switchTab('chat');
                }

            } catch (e) { window.reportError("Init Error", e); }
        });

        // --- æ–°å¢åŠŸèƒ½ï¼šè§¸ç™¼ Quick OCR ---
        function triggerQuickOCR() {
            // åˆ‡æ›åˆ°å·¥å…·é é¢ä»¥é¡¯ç¤ºçµæœ
            switchTab('tools');
            // è§¸ç™¼éš±è—çš„æª”æ¡ˆè¼¸å…¥æ¡†
            document.getElementById('quick-ocr-input').click();
        }

        // --- æ–°å¢åŠŸèƒ½ï¼šè™•ç† Quick OCR æª”æ¡ˆ ---
        async function handleQuickOCRFileSelect() {
            const input = document.getElementById('quick-ocr-input');
            const file = input.files[0];
            if (!file) return;
            
            // é‡ç½® UI èˆ‡ç„¦é»
            const outputDiv = document.getElementById('quick-ocr-output');
            outputDiv.innerHTML = '<p>åˆ†æä¸­ï¼Œè«‹ç¨å€™...</p>';
            outputDiv.focus(); // è®“è®€å±è»Ÿé«”çŸ¥é“é€™è£¡æœ‰è®ŠåŒ–
            
            updateStatusBar("æ­£åœ¨è­˜åˆ¥æ–‡å­— (OCR)...", "busy");
            playAudioCue('start');

            try {
                // è®€å–æª”æ¡ˆç‚º Base64
                let fileData = await readFileAsBase64(file);
                
                // å‘¼å« AI (ä½¿ç”¨ç¨ç«‹çš„ OCR Promptï¼Œä¸å¸¶å°è©±æ­·å²)
                const res = await callAI(
                    document.getElementById('provider-select').value,
                    DEFAULT_OCR_PROMPT, // å¼·åˆ¶ä½¿ç”¨ OCR å°ˆç”¨æŒ‡ä»¤
                    [], // ç©ºæ­·å²ç´€éŒ„
                    "", // ä¸å¸¶ç”¨æˆ¶æ–‡å­—
                    fileData,
                    file.type, // å‚³éæ­£ç¢ºçš„ MIME Type (image/* æˆ– application/pdf)
                    null // ä¸è¨­å®š abort signal
                );
                
                // è™•ç†ä¸¦é¡¯ç¤ºçµæœ
                const safeHTML = DOMPurify.sanitize(marked.parse(res));
                outputDiv.innerHTML = safeHTML;
                
                // ç„¡éšœç¤™ï¼šæ’­æ”¾æˆåŠŸéŸ³æ•ˆä¸¦å¼·åˆ¶èšç„¦ï¼Œè®“è®€å±è»Ÿé«”æœ—è®€
                playAudioCue('success');
                outputDiv.focus();
                updateStatusBar("è­˜åˆ¥å®Œæˆ");
                
            } catch (e) {
                window.reportError("Quick OCR Failed", e);
                outputDiv.innerHTML = `<p style="color:#ff5555; font-weight:bold;">âš ï¸ è­˜åˆ¥å¤±æ•—ï¼š${e.message}</p>`;
                outputDiv.focus();
            }
            // æ¸…ç©º Input å…è¨±é‡è¤‡ä¸Šå‚³ç›¸åŒæª”æ¡ˆ
            input.value = '';
        }

        function switchPromptEditor(mode) {
            const textarea = document.getElementById('system-prompt');
            memoryPrompts[currentEditingMode] = textarea.value;
            currentEditingMode = mode;
            textarea.value = memoryPrompts[mode];
            document.getElementById('tab-chat').classList.toggle('secondary', mode !== 'chat');
            document.getElementById('tab-ocr').classList.toggle('secondary', mode !== 'ocr');
            document.getElementById('tab-translate').classList.toggle('secondary', mode !== 'translate');
            document.getElementById('tab-chat').classList.toggle('active', mode === 'chat'); 
        }

        function setSpecificConfig(type) {
            const provider = document.getElementById('provider-select').value;
            const model = currentActiveModelId;
            specificConfigs[type] = { provider, model };
            localStorage.setItem('specific_configs', JSON.stringify(specificConfigs));
            const currentKey = document.getElementById('api-key').value;
            if (currentKey) localStorage.setItem(`${provider}_key`, currentKey.trim());
            updateConfigStatusDisplay();
            showTransientStatus(`å·²è¨­å®š ${type} å°ˆç”¨æ¨¡å‹`);
        }

        function clearSpecificConfigs() {
            specificConfigs = { ocr: null, translate: null };
            localStorage.removeItem('specific_configs');
            updateConfigStatusDisplay();
            showTransientStatus("å·²é‡ç½®åˆ†å·¥è¨­å®š");
        }

        function updateConfigStatusDisplay() {
            const display = document.getElementById('config-status-display');
            let html = "";
            html += specificConfigs.ocr ? `â€¢ OCR: ${specificConfigs.ocr.provider} / ${specificConfigs.ocr.model}<br>` : "";
            html += specificConfigs.translate ? `â€¢ ç¿»è­¯: ${specificConfigs.translate.provider} / ${specificConfigs.translate.model}` : "";
            display.innerHTML = html || "ç›®å‰è·Ÿéš¨ä¸»è¦è¨­å®š";
        }

        function playAudioCue(type) {
            if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            const now = audioContext.currentTime;
            
            if (type === 'start') { 
                oscillator.type = 'sine'; oscillator.frequency.setValueAtTime(880, now); gainNode.gain.setValueAtTime(0.1, now); oscillator.start(now); oscillator.stop(now + 0.1); 
            } else if (type === 'success') { 
                oscillator.type = 'sine'; oscillator.frequency.setValueAtTime(440, now); oscillator.frequency.exponentialRampToValueAtTime(880, now + 0.15); gainNode.gain.setValueAtTime(0.1, now); oscillator.start(now); oscillator.stop(now + 0.2); 
            } else if (type === 'error') { 
                oscillator.type = 'sawtooth'; oscillator.frequency.setValueAtTime(150, now); gainNode.gain.setValueAtTime(0.15, now); oscillator.start(now); oscillator.stop(now + 0.4); 
            } else if (type === 'abort') {
                oscillator.type = 'triangle'; oscillator.frequency.setValueAtTime(400, now); oscillator.frequency.linearRampToValueAtTime(200, now + 0.1); gainNode.gain.setValueAtTime(0.1, now); oscillator.start(now); oscillator.stop(now + 0.1);
            }
        }

        function resetConversation() {
            chatHistory = []; 
            stickyMemory = { type: null, content: null, mime: null, count: 0 };
            document.getElementById('chat-output').innerHTML = ""; 
            document.getElementById('user-input').value = "";
            selectedFile = null;
            document.getElementById('upload-btn').innerText = "ğŸ“ æª”æ¡ˆ/æ‹ç…§";
            document.getElementById('upload-btn').classList.remove('active');
            document.getElementById('file-input').value = "";
            toggleExportButtons(false);
            showTransientStatus("å°è©±èˆ‡è¨˜æ†¶å·²æ¸…é™¤");
        }

        function handlePDFToolFileSelect() {
            const input = document.getElementById('pdf-tool-input');
            if (input.files.length > 0) {
                processPDFTool(input.files[0]);
            }
            input.value = ""; 
        }
        
        function isCanvasBlank(canvas) {
            try {
                const ctx = canvas.getContext('2d', { willReadFrequently: true });
                const imageData = ctx.getImageData(canvas.width/2 - 25, canvas.height/2 - 25, 50, 50);
                const data = imageData.data;
                for(let i = 0; i < data.length; i += 4) {
                    if (data[i+3] > 0 && (data[i] < 250 || data[i+1] < 250 || data[i+2] < 250)) return false; 
                }
                return true;
            } catch(e) { return false; }
        }

        async function processPDFTool(file) {
            if (typeof window.pdfjsLib === 'undefined') { alert("PDF æ ¸å¿ƒè¼‰å…¥ä¸­..."); return; }
            if (!file || file.type !== 'application/pdf') { alert("è«‹é¸æ“‡ PDF"); return; }
            
            resetConversation(); playAudioCue('start');
            switchTab('chat');
            
            const alwaysAI = document.getElementById('pdf-always-ai').checked;
            const needTranslate = document.getElementById('pdf-translate').checked;

            try {
                updateStatusBar("æ­£åœ¨åˆ†æ PDF...", "busy");
                let extractedText = "";
                let sourceMode = "text";

                if (!alwaysAI) {
                    const localText = await extractTextFromPDF_Accurate(file);
                    const cleanText = localText ? localText.replace(/\s/g, '') : "";
                    if (cleanText.length > 50 && !/[\uFFFD]/.test(cleanText.slice(0, 100))) {
                        extractedText = UniversalTextNormalizer.normalize(localText);
                        sourceMode = "text";
                        updateStatusBar("æ–‡å­—æå–æˆåŠŸï¼Œæº–å‚™è™•ç†...", "busy");
                    } else {
                        sourceMode = "image";
                    }
                } else {
                    sourceMode = "image";
                }

                await performAIProcessing(file, sourceMode, extractedText, needTranslate);

            } catch (e) { window.reportError("PDF Error", e); }
        }

        async function performAIProcessing(file, sourceMode, textData, needTranslate) {
            const controller = new AbortController(); 
            let accumulatedText = "";

            if (sourceMode === "image") {
                let ocrProvider = specificConfigs.ocr ? specificConfigs.ocr.provider : document.getElementById('provider-select').value;
                let ocrModel = specificConfigs.ocr ? specificConfigs.ocr.model : currentActiveModelId;
                let ocrApiKey = (ocrProvider === document.getElementById('provider-select').value) ? document.getElementById('api-key').value : localStorage.getItem(`${ocrProvider}_key`);
                if (!ocrApiKey) throw new Error(`ç¼ºå°‘ ${ocrProvider} Key`);

                const arrayBuffer = await file.arrayBuffer();
                const pdf = await window.pdfjsLib.getDocument({ data: arrayBuffer, cMapUrl: './pdf-dist/cmaps/', cMapPacked: true }).promise;
                updateVisualProgress(true, `OCR è™•ç†ä¸­...`);
                
                for (let i = 1; i <= pdf.numPages; i++) {
                    if (i % 5 === 0) document.getElementById('visual-progress').innerText = `OCR: ${i} / ${pdf.numPages}`;
                    const page = await pdf.getPage(i);
                    const viewportRaw = page.getViewport({ scale: 1.0 });
                    const scale = Math.min(1536 / Math.max(viewportRaw.width, viewportRaw.height), 2.0);
                    const canvas = document.createElement('canvas');
                    canvas.width = page.getViewport({ scale }).width; canvas.height = page.getViewport({ scale }).height;
                    await page.render({ canvasContext: canvas.getContext('2d'), viewport: page.getViewport({ scale }) }).promise;
                    
                    if (!isCanvasBlank(canvas)) {
                        const imgBase64 = canvas.toDataURL('image/jpeg', 0.6).split(',')[1];
                        let pageText = await callAI(ocrProvider, DEFAULT_OCR_PROMPT, [], "Transcribe EXACTLY.", imgBase64, "image/jpeg", controller.signal, ocrModel, ocrApiKey);
                        accumulatedText += `[Page ${i}]\n${UniversalTextNormalizer.normalize(pageText)}\n\n`;
                    }
                    canvas.remove(); await sleep(200); 
                }
                updateVisualProgress(false);
            } else {
                accumulatedText = textData; 
            }

            if (needTranslate) {
                let transProvider = specificConfigs.translate ? specificConfigs.translate.provider : document.getElementById('provider-select').value;
                let transModel = specificConfigs.translate ? specificConfigs.translate.model : currentActiveModelId;
                let transApiKey = (transProvider === document.getElementById('provider-select').value) ? document.getElementById('api-key').value : localStorage.getItem(`${transProvider}_key`);
                updateStatusBar("æ­£åœ¨ç¿»è­¯...", "busy");
                const res = await callAI(transProvider, memoryPrompts.translate, [], `[SOURCE]:\n${accumulatedText}`, null, null, controller.signal, transModel, transApiKey);
                
                // ä¿®æ­£é‡é»ï¼šç²å–å›å‚³çš„ div ä¸¦ç§»å‹•ç„¦é»
                const aiMsg = addMessage('assistant', UniversalTextNormalizer.normalize(res));
                setTimeout(() => aiMsg.focus(), 100);

            } else {
                let displayText = accumulatedText.replace(/^\[Page (\d+)\]/gm, "## [Page $1]");
                // ä¿®æ­£é‡é»ï¼šç²å–å›å‚³çš„ div ä¸¦ç§»å‹•ç„¦é»
                const aiMsg = addMessage('assistant', displayText);
                setTimeout(() => aiMsg.focus(), 100);
            }

            playAudioCue('success'); updateStatusBar("å®Œæˆ");
        }

        function updateVisualProgress(show, text="") {
            const el = document.getElementById('visual-progress');
            if (show) { el.classList.add('active'); el.innerText = text; } 
            else { el.classList.remove('active'); el.innerText = ""; }
        }

        async function extractTextFromPDF_Accurate(file) {
            try {
                const arrayBuffer = await file.arrayBuffer();
                const pdf = await window.pdfjsLib.getDocument({ data: arrayBuffer, cMapUrl: './pdf-dist/cmaps/', cMapPacked: true }).promise;
                let fullText = "";
                for (let i = 1; i <= pdf.numPages; i++) {
                    const content = await pdf.getPage(i).then(p => p.getTextContent());
                    const items = content.items.filter(item => item.str.trim().length > 0);
                    if (items.length === 0) { fullText += `[Page ${i}]\n\n`; continue; }
                    
                    const viewport = await pdf.getPage(i).then(p => p.getViewport({scale:1.0}));
                    const normItems = items.map(it => ({ str: it.str, x: it.transform[4], y: viewport.height - it.transform[5], w: it.width, h: it.height || 10, fontHeight: Math.abs(it.transform[3]) }));
                    const columns = detectColumns(normItems, viewport.width);
                    
                    let pageStr = "";
                    for (const col of columns) {
                        col.sort((a, b) => (Math.abs(a.y - b.y) < Math.min(a.fontHeight, b.fontHeight)*0.5) ? (a.x - b.x) : (a.y - b.y));
                        pageStr += assembleLinesAdaptive(col) + "\n";
                    }
                    fullText += `[Page ${i}]\n${pageStr}\n\n`;
                }
                return fullText;
            } catch (e) { return null; }
        }

        function detectColumns(items, width) {
            const bins = new Array(Math.ceil(width/2)).fill(0);
            items.forEach(it => { for(let k=Math.floor(it.x/2); k<=Math.floor((it.x+it.w)/2); k++) if(k>=0 && k<bins.length) bins[k]=1; });
            let gaps=[], cur={s:-1,w:0};
            for(let i=Math.floor(bins.length*0.2); i<Math.floor(bins.length*0.8); i++) {
                if(bins[i]===0) { if(cur.s===-1) cur.s=i; cur.w++; }
                else { if(cur.w>0) { gaps.push({...cur}); cur={s:-1,w:0}; } }
            }
            const validGap = gaps.reduce((m,g)=>g.w>m.w?g:m, {w:0});
            if (validGap.w > bins.length*0.02) {
                const split = (validGap.s + validGap.w/2)*2;
                return [items.filter(i=>i.x+i.w<split), items.filter(i=>i.x>=split)];
            }
            return [items];
        }

        function assembleLinesAdaptive(items) {
            if(!items.length) return "";
            let res = "", last = null;
            for (let it of items) {
                if (last) {
                    if (it.y - last.y > Math.min(last.fontHeight, it.fontHeight)*0.5) res += "\n";
                    else {
                        const tA = UniversalTextNormalizer.getScriptType(last.str.slice(-1));
                        const tB = UniversalTextNormalizer.getScriptType(it.str.charAt(0));
                        const gap = it.x - (last.x + last.w);
                        if (tA==='sea'||tB==='sea'||tA==='rtl'||tB==='rtl') { if(gap>it.fontHeight*2) res+=" "; }
                        else if ((tA==='cjk'&&tB==='cjk')||(tA==='cjk'&&tB==='latin')||(tA==='latin'&&tB==='cjk')) { if(gap>it.fontHeight*1.5) res+=" "; }
                        else if (gap > it.fontHeight*0.35) res += " ";
                    }
                }
                res += it.str; last = it;
            }
            return res;
        }

        function initVoiceSystem() {
            const engine = document.getElementById('voice-engine').value;
            if (engine === 'browser') initBrowserSpeech(); 
            else if (recognition) { recognition.stop(); recognition = null; }
        }

        function initBrowserSpeech() {
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                recognition = new SpeechRecognition(); 
                recognition.lang = 'zh-HK'; recognition.continuous = true; recognition.interimResults = true; 
                recognition.onstart = () => { isVoiceRecording=true; document.getElementById('voice-btn').classList.add('recording'); updateStatusBar('è†è½ä¸­...', 'recording'); playAudioCue('start'); };
                recognition.onresult = (e) => {
                    let t = ''; for (let i = e.resultIndex; i < e.results.length; ++i) if (e.results[i].isFinal) t += e.results[i][0].transcript;
                    if (t) document.getElementById('user-input').value += (document.getElementById('user-input').value ? " " : "") + t;
                };
                recognition.onerror = () => { stopVoiceInputUI(); playAudioCue('error'); };
                recognition.onend = () => { if(isVoiceRecording) playAudioCue('abort'); stopVoiceInputUI(); };
            }
        }

        // --- æ–°å¢ï¼šæ™ºæ…§æ ¼å¼åµæ¸¬ (æ”¯æ´ iOS/Safari) ---
        function getSupportedMimeType() {
            // å„ªå…ˆæª¢æŸ¥ Safari æ”¯æ´çš„ mp4 (AAC) - å„ªå…ˆé †åº 1
            if (MediaRecorder.isTypeSupported('audio/mp4')) return 'audio/mp4';
            // å…¶æ¬¡æª¢æŸ¥ Chrome/Android æ”¯æ´çš„ webm - å„ªå…ˆé †åº 2
            if (MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) return 'audio/webm;codecs=opus';
            // æœ€å¾Œæ˜¯é€šç”¨ webm - å„ªå…ˆé †åº 3
            if (MediaRecorder.isTypeSupported('audio/webm')) return 'audio/webm';
            return ''; // è®“ç€è¦½å™¨ä½¿ç”¨é è¨­å€¼
        }

        async function startVoiceRecording() {
            ensureAudioContext(); if (isVoiceRecording) return;
            const engine = document.getElementById('voice-engine').value;
            if (engine === 'browser') { if (recognition) try { recognition.start(); } catch(e){} }
            else {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    
                    // ä¿®æ­£ï¼šä½¿ç”¨æ™ºæ…§åµæ¸¬å¾Œçš„ MIME Type
                    const mimeType = getSupportedMimeType();
                    const options = mimeType ? { mimeType } : undefined;
                    
                    mediaRecorder = new MediaRecorder(stream, options); 
                    audioChunks = []; 
                    mediaRecorder.ondataavailable = e => audioChunks.push(e.data);
                    mediaRecorder.onstop = async () => { 
                        // å‚³éå¯¦éš›ä½¿ç”¨çš„ mimeType çµ¦è™•ç†å‡½å¼
                        await processWhisperAudio(new Blob(audioChunks, {type: mediaRecorder.mimeType}), engine, mediaRecorder.mimeType); 
                        stream.getTracks().forEach(t=>t.stop()); 
                    };
                    mediaRecorder.start(); isVoiceRecording = true; document.getElementById('voice-btn').classList.add('recording'); playAudioCue('start');
                } catch (e) { showTransientStatus('éº¥å…‹é¢¨éŒ¯èª¤', 'error'); }
            }
        }

        function stopVoiceRecording() {
            if (!isVoiceRecording) return;
            ensureAudioContext(); isVoiceRecording = false; playAudioCue('success');
            if (document.getElementById('voice-engine').value === 'browser' && recognition) recognition.stop();
            else if (mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop();
        }

        function stopVoiceInputUI() {
            isVoiceRecording = false; document.getElementById('voice-btn').classList.remove('recording');
            if (!document.getElementById('status-bar').classList.contains('busy')) showReadyStatus();
        }

        async function processWhisperAudio(blob, engine, mime) {
            let apiKey = document.getElementById('voice-api-key').value || document.getElementById('api-key').value;
            if (!apiKey) return alert("éœ€ API Key");
            // ä¿®æ­£ï¼šæ ¹æ“š mime æ±ºå®šå‰¯æª”åï¼Œç¢ºä¿å¾Œç«¯èƒ½è­˜åˆ¥
            const fd = new FormData(); fd.append('file', blob, `rec.${mime.includes('mp4')?'mp4':'webm'}`);
            fd.append('model', engine === 'openai' ? 'whisper-1' : 'whisper-large-v3');
            updateStatusBar("èªéŸ³è½‰è­¯ä¸­...", "busy");
            try {
                const res = await fetch(engine==='openai'?"https://api.openai.com/v1/audio/transcriptions":"https://api.groq.com/openai/v1/audio/transcriptions", { method:'POST', headers:{'Authorization':`Bearer ${apiKey}`}, body:fd });
                const data = await res.json();
                if (data.text) { document.getElementById('user-input').value += (document.getElementById('user-input').value ? " " : "") + data.text; showReadyStatus(); }
            } catch(e) { window.reportError("Whisper Error", e); }
            finally { stopVoiceInputUI(); }
        }

        function saveVoiceSettings() { localStorage.setItem('voice_engine', document.getElementById('voice-engine').value); localStorage.setItem('voice_api_key', document.getElementById('voice-api-key').value); initVoiceSystem(); }
        function initPasteImage() { document.addEventListener('paste', e => { const f = e.clipboardData.files[0]; if(f && f.type.startsWith('image/')) handleFileSelect(f); }); }
        function initDragAndDrop() { const d = document.getElementById('view-chat'); d.ondragover = e => {e.preventDefault(); d.style.background='#222'}; d.ondragleave = () => d.style.background=''; d.ondrop = e => {e.preventDefault(); d.style.background=''; handleFileSelect(e.dataTransfer.files[0]);}; }
        function initEnterKey() { document.getElementById('user-input').onkeydown = e => { if(e.key==='Enter' && !e.shiftKey && document.getElementById('enter-to-send').checked) { e.preventDefault(); document.getElementById('submit-btn').click(); } }; }
        
        // ä¿®æ­£ï¼šå„ªåŒ–ç‹€æ…‹åˆ—æ›´æ–°é †åºï¼Œç¢ºä¿ aria-live ç”Ÿæ•ˆ
        function updateStatusBar(t, s='ready') { 
            const b = document.getElementById('status-bar'); 
            // 1. å…ˆè¨­å®š ARIA å±¬æ€§ (è®“è¢å¹•é–±è®€å™¨æº–å‚™å¥½)
            b.setAttribute('aria-live', s === 'error' ? 'assertive' : 'polite');
            // 2. è¨­å®šæ¨£å¼
            b.className = s; 
            // 3. æœ€å¾Œæ›´æ–°æ–‡å­— (è§¸ç™¼é–±è®€)
            b.innerText = t; 
        }

        function showReadyStatus() { updateStatusBar("æº–å‚™å°±ç·’"); }
        function showTransientStatus(m, t='success') { updateStatusBar(m, t==='error'?'error':'ready'); setTimeout(()=>{ if(!document.getElementById('status-bar').classList.contains('busy')) showReadyStatus(); }, 3000); }
        
        function addMessage(role, content) {
            const div = document.createElement('div'); div.className = `message ${role}`; div.tabIndex = -1;
            div.innerHTML = `<h1 class="msg-heading">${role==='user'?'æ‚¨ï¼š':'AIï¼š'}</h1><div class="markdown-body" dir="auto">${role==='user'?content:DOMPurify.sanitize(marked.parse(content))}</div>`;
            document.getElementById('chat-output').appendChild(div); 
            toggleExportButtons(true);
            return div;
        }
        function toggleExportButtons(show) { ['copy-btn','export-txt-btn','export-html-btn'].forEach(id=>document.getElementById(id).classList.toggle('hidden', !show)); }
        
        function handleProviderChange(save=true) {
            const p = document.getElementById('provider-select').value; const c = PROVIDERS[p];
            document.getElementById('api-key').value = localStorage.getItem(`${p}_key`) || "";
            memoryPrompts.chat = localStorage.getItem(`${p}_prompt`) || c.prompt;
            if (currentEditingMode === 'chat') document.getElementById('system-prompt').value = memoryPrompts.chat;
            
            const orSet = document.getElementById('openrouter-settings');
            if(orSet) orSet.classList.toggle('hidden', p!=='openrouter');
            
            allCurrentModels = JSON.parse(localStorage.getItem(`${p}_model_list`)) || c.models;
            handleModelFilter();
            currentActiveModelId = localStorage.getItem(`${p}_model`) || c.defaultModel;
            document.getElementById('refresh-btn').style.display = c.canFetch ? 'block' : 'none';
            if(save) localStorage.setItem('provider', p);
            showReadyStatus();
        }
        function handleModelFilter() {
            const f = document.getElementById('model-filter-input').value.toLowerCase();
            updateModelSelect(allCurrentModels.filter(m=>m.toLowerCase().includes(f)), currentActiveModelId);
        }
        function updateModelSelect(list, active) {
            const s = document.getElementById('model-select'); s.innerHTML = "";
            let found = false;
            list.forEach(m => { const o = document.createElement('option'); o.value=m; o.innerText=m; if(m===active) found=true; s.appendChild(o); });
            s.appendChild(new Option("è‡ªè¡Œè¼¸å…¥...", "CUSTOM"));
            const w = document.getElementById('custom-model-wrapper');
            if(found) { s.value=active; w.classList.add('hidden'); } else { s.value="CUSTOM"; w.classList.remove('hidden'); document.getElementById('custom-model-input').value=active; }
        }
        
        async function fetchOnlineModels() {
            const p = document.getElementById('provider-select').value; const k = document.getElementById('api-key').value;
            if(!k && p!=='openrouter') return alert("éœ€ API Key");
            const btn = document.getElementById('refresh-btn'); btn.innerText="è®€å–ä¸­..."; btn.disabled=true;
            try {
                let list=[];
                if(p==='openrouter') list=(await(await fetch("https://openrouter.ai/api/v1/models")).json()).data.map(m=>m.id);
                else if(p==='gemini') list=(await(await fetch(PROVIDERS[p].listUrl.replace('{KEY}',k))).json()).models.filter(m=>m.supportedGenerationMethods?.includes("generateContent")).map(m=>m.name.replace("models/",""));
                else if(p==='datalab') return; // Datalab ç„¡éœ€æ›´æ–°æ¨¡å‹
                else list=(await(await fetch(PROVIDERS[p].listUrl, {headers:{'Authorization':`Bearer ${k}`}})).json()).data.map(m=>m.id);
                
                if(list && list.length > 0) { 
                    localStorage.setItem(`${p}_model_list`, JSON.stringify(list)); 
                    allCurrentModels=list; 
                    handleModelFilter(); 
                    showTransientStatus("æ¨¡å‹æ¸…å–®å·²æ›´æ–°ä¸¦å„²å­˜"); 
                } else {
                    throw new Error("æ‰¾ä¸åˆ°å¯ç”¨æ¨¡å‹");
                }
            } catch(e) { window.reportError("æ›´æ–°å¤±æ•—", e); } 
            finally { btn.innerText="æ›´æ–°"; btn.disabled=false; }
        }

        function handleModelSelectChange() {
            const s = document.getElementById('model-select');
            if(s.value==="CUSTOM") document.getElementById('custom-model-wrapper').classList.remove('hidden');
            else { document.getElementById('custom-model-wrapper').classList.add('hidden'); currentActiveModelId=s.value; }
        }
        function handleCustomInputChange() { currentActiveModelId = document.getElementById('custom-model-input').value.trim(); }
        
        function saveSettings() {
            const p = document.getElementById('provider-select').value;
            const m = document.getElementById('model-select').value==="CUSTOM" ? document.getElementById('custom-model-input').value : document.getElementById('model-select').value;
            memoryPrompts[currentEditingMode] = document.getElementById('system-prompt').value;
            localStorage.setItem(`${p}_prompt`, memoryPrompts.chat);
            localStorage.setItem('custom_prompt_ocr', memoryPrompts.ocr);
            localStorage.setItem('custom_prompt_translate', memoryPrompts.translate);
            localStorage.setItem(`${p}_key`, document.getElementById('api-key').value.trim());
            localStorage.setItem(`${p}_model`, m); currentActiveModelId = m;
            localStorage.setItem('timeout_setting', document.getElementById('timeout-setting').value);
            localStorage.setItem('enter_to_send', document.getElementById('enter-to-send').checked);
            localStorage.setItem('openrouter_web_search', document.getElementById('openrouter-web-search').checked);
            saveVoiceSettings(); 
            showTransientStatus("è¨­å®šå·²å„²å­˜");
            switchTab(lastActiveTabId || 'chat');
        }

        function restoreDefaults() {
            const p = document.getElementById('provider-select').value; 
            memoryPrompts.chat = PROVIDERS[p].prompt;
            memoryPrompts.ocr = DEFAULT_OCR_PROMPT;
            memoryPrompts.translate = DEFAULT_TRANSLATE_PROMPT;
            localStorage.removeItem(`${p}_prompt`);
            localStorage.removeItem('custom_prompt_ocr');
            localStorage.removeItem('custom_prompt_translate');
            document.getElementById('system-prompt').value = memoryPrompts[currentEditingMode];
            handleProviderChange(true); 
            showTransientStatus("å·²é‚„åŸé è¨­å€¼");
        }

        function copyResult() { navigator.clipboard.writeText(document.getElementById('chat-output').innerText).then(()=>showTransientStatus("å·²è¤‡è£½")); }
        function copyErrorLog() { navigator.clipboard.writeText(document.getElementById('error-log-area').value).then(()=>showTransientStatus("æ—¥èªŒå·²è¤‡è£½")); }
        function exportChat(fmt) {
            const c = document.getElementById('chat-output');
            const b = new Blob([fmt==='html'?`<html><body>${c.innerHTML}</body></html>`:c.innerText], {type:fmt==='html'?'text/html':'text/plain'});
            const a = document.createElement('a'); a.href = URL.createObjectURL(b); a.download = `export.${fmt}`; a.click();
        }
        
        async function handleFileSelect(f) {
            f = f || document.getElementById('file-input').files[0];
            if(f) { 
                selectedFile = f; 
                document.getElementById('upload-btn').innerText = `å·²é¸: ${f.name.substring(0,8)}...`;
                document.getElementById('upload-btn').classList.add('active'); 
                
                if (f.type === 'application/pdf') {
                    // PDF Pre-processing hook
                }

                const isPaused = document.getElementById('pause-send').checked;
                if (!isPaused) {
                    showTransientStatus("å³å°‡è‡ªå‹•ç™¼é€...");
                    setTimeout(() => {
                        const event = new Event('submit', { cancelable: true });
                        document.querySelector('form').dispatchEvent(event); 
                    }, 700);
                } else {
                    showTransientStatus("æª”æ¡ˆå·²åŠ å…¥ï¼Œè«‹è¼¸å…¥æ–‡å­—å¾Œç™¼é€"); 
                    document.getElementById('user-input').focus();
                }
            }
        }

        function readFileAsBase64(f) { return new Promise((r,j)=>{const rd=new FileReader(); rd.onload=()=>r(rd.result.split(',')[1]); rd.onerror=j; rd.readAsDataURL(f);}); }
        function readFileAsText(f) { return new Promise((r,j)=>{const rd=new FileReader(); rd.onload=()=>r(rd.result); rd.onerror=j; rd.readAsText(f);}); }

        async function handleSubmit(e) {
            e.preventDefault(); ensureAudioContext();
            const txt = document.getElementById('user-input').value.trim();
            if(!txt && !selectedFile) return showTransientStatus("è«‹è¼¸å…¥å…§å®¹", 'error');
            
            playAudioCue('start'); updateStatusBar("è™•ç†ä¸­...", 'busy');
            const btn = document.getElementById('submit-btn'); btn.disabled=true;
            const ctl = new AbortController(); const tm = setTimeout(()=>ctl.abort(), document.getElementById('timeout-setting').value*1000);
            
            try {
                let input = txt; 
                let fileData = null; 
                let mime = null;

                if(selectedFile) {
                    if(selectedFile.type === 'application/pdf') {
                        const pdfText = await extractTextFromPDF_Accurate(selectedFile);
                        if(pdfText) { 
                            const cleanPdfText = UniversalTextNormalizer.normalize(pdfText);
                            input = `[æ–‡ä»¶å…§å®¹]:\n${cleanPdfText}\n\n[ç”¨æˆ¶æå•]:\n${txt}`;
                            stickyMemory = { type: 'text', content: cleanPdfText, count: 3 };
                        }
                    } 
                    else if (selectedFile.type.startsWith('image/')) {
                        fileData = await readFileAsBase64(selectedFile); 
                        mime = selectedFile.type;
                        stickyMemory = { type: 'image', content: fileData, mime: mime, count: 3 };
                    }
                    else if (selectedFile.type.startsWith('text/') || selectedFile.name.endsWith('.txt') || selectedFile.name.endsWith('.md') || selectedFile.name.endsWith('.js') || selectedFile.name.endsWith('.html') || selectedFile.name.endsWith('.css') || selectedFile.name.endsWith('.py')) {
                         const fileText = await readFileAsText(selectedFile);
                         input = `[æ–‡ä»¶å…§å®¹ (${selectedFile.name})]:\n${fileText}\n\n[ç”¨æˆ¶æå•]:\n${txt}`;
                         stickyMemory = { type: 'text', content: fileText, count: 3 };
                    }
                } 
                else if (stickyMemory.count > 0 && stickyMemory.content) {
                    stickyMemory.count--;
                    if (stickyMemory.type === 'image') {
                        fileData = stickyMemory.content;
                        mime = stickyMemory.mime;
                        showTransientStatus(`åœ–ç‰‡è¿½å•æ¨¡å¼ (å‰©é¤˜ ${stickyMemory.count} æ¬¡)`);
                    } else if (stickyMemory.type === 'text') {
                        input = `[æ–‡ä»¶å…§å®¹å›é¡§]:\n${stickyMemory.content}\n\n[ç”¨æˆ¶è¿½å•]:\n${txt}`;
                        showTransientStatus(`æ–‡ä»¶è¿½å•æ¨¡å¼ (å‰©é¤˜ ${stickyMemory.count} æ¬¡)`);
                    }
                }

                addMessage('user', txt || (selectedFile ? `[æª”æ¡ˆ: ${selectedFile.name}]` : "[è¿½å•æ¨¡å¼]"));
                
                document.getElementById('user-input').value = ""; 
                document.getElementById('upload-btn').innerText = "ğŸ“ æª”æ¡ˆ/æ‹ç…§"; 
                document.getElementById('upload-btn').classList.remove('active');
                selectedFile = null;
                
                const res = await callAI(
                    document.getElementById('provider-select').value, 
                    document.getElementById('system-prompt').value,
                    chatHistory, 
                    input, 
                    fileData, 
                    mime, 
                    ctl.signal
                );

                const aiMsg = addMessage('assistant', UniversalTextNormalizer.normalize(res)); 
                setTimeout(() => { aiMsg.focus(); }, 100);

                chatHistory.push({role: 'user', content: input}); 
                chatHistory.push({role: 'assistant', content: res});
                if (chatHistory.length > 20) chatHistory = chatHistory.slice(-20);

                playAudioCue('success'); showReadyStatus();
            } catch(e) { window.reportError("Submit Error", e); } finally { clearTimeout(tm); btn.disabled=false; }
        }

        async function callAI(p, sysPrompt, history, txt, file, mime, sig, ovModel, ovKey) {
            const k = ovKey || document.getElementById('api-key').value; 
            const m = ovModel || currentActiveModelId;
            
            if(!k) throw new Error("éœ€ API Key");

            // --- æ–°å¢ï¼šDatalab (Chandra OCR) å°ˆç”¨é‚è¼¯ ---
            if (p === 'datalab') {
                if (!file) throw new Error("Chandra OCR åƒ…æ”¯æ´æª”æ¡ˆ/åœ–ç‰‡è¼¸å…¥ (ä¸æ”¯æ´ç´”æ–‡å­—å°è©±)");
                
                // 1. Base64 è½‰ Blob (ç”¨æ–¼ FormData ä¸Šå‚³)
                const byteCharacters = atob(file);
                const byteNumbers = new Array(byteCharacters.length);
                for (let i = 0; i < byteCharacters.length; i++) {
                    byteNumbers[i] = byteCharacters.charCodeAt(i);
                }
                const byteArray = new Uint8Array(byteNumbers);
                const blob = new Blob([byteArray], {type: mime || 'application/pdf'});

                // 2. å»ºç«‹ä¸Šå‚³è«‹æ±‚
                const formData = new FormData();
                formData.append('file', blob);
                
                // 3. ä¸Šå‚³æª”æ¡ˆ (POST)
                const postReq = await fetch('https://www.datalab.to/api/v1/ocr', {
                    method: 'POST',
                    headers: { 'X-Api-Key': k },
                    body: formData,
                    signal: sig
                });
                
                if (!postReq.ok) {
                    const errText = await postReq.text();
                    throw new Error(`Datalab Upload Failed: ${errText}`);
                }
                
                const postData = await postReq.json();
                const requestId = postData.request_id;
                
                // 4. è¼ªè©¢æª¢æŸ¥ç‹€æ…‹ (Polling)
                while (true) {
                    if (sig.aborted) throw new Error("ä½¿ç”¨è€…å–æ¶ˆæ“ä½œ");
                    
                    // æ¯ç§’æª¢æŸ¥ä¸€æ¬¡
                    await new Promise(r => setTimeout(r, 1000));
                    
                    const checkReq = await fetch(`https://www.datalab.to/api/v1/ocr/${requestId}`, {
                        method: 'GET',
                        headers: { 'X-Api-Key': k },
                        signal: sig
                    });
                    
                    if (!checkReq.ok) throw new Error("Datalab Check Failed");
                    
                    const checkData = await checkReq.json();
                    
                    if (checkData.status === 'complete') {
                        return checkData.result.markdown; // æˆåŠŸï¼šå›å‚³ Markdown
                    } else if (checkData.status === 'failed') {
                        throw new Error(`Datalab Processing Failed: ${checkData.error || 'Unknown error'}`);
                    }
                    // status == 'processing' -> ç¹¼çºŒè¿´åœˆ
                }
            }
            // --- Datalab é‚è¼¯çµæŸ ---

            let body={}, url="", headers={'Content-Type':'application/json', 'Authorization':`Bearer ${k}`};
            
            if(p==='gemini') {
                url=`https://generativelanguage.googleapis.com/v1beta/models/${m}:generateContent?key=${k}`; delete headers['Authorization'];
                
                let bodyContent = { 
                    system_instruction: { parts: [{ text: sysPrompt }] },
                    contents: [] 
                };
                history.forEach(msg => {
                    bodyContent.contents.push({
                        role: msg.role === 'user' ? 'user' : 'model',
                        parts: [{ text: msg.content }]
                    });
                });
                let currentParts = [];
                if (file) {
                    currentParts.push({ inline_data: { mime_type: mime || "image/jpeg", data: file } });
                }
                currentParts.push({ text: txt });
                bodyContent.contents.push({ role: "user", parts: currentParts });

                body = bodyContent;
            } 
            else {
                if (p === 'openrouter') {
                    url = "https://openrouter.ai/api/v1/chat/completions";
                    headers['HTTP-Referer'] = 'https://ai-vision.app'; headers['X-Title'] = 'AI Vision';
                    if(document.getElementById('openrouter-web-search').checked) body.plugins = [{id:"web"}];
                } else if (p === 'mistral') url = "https://api.mistral.ai/v1/chat/completions";
                else if (p === 'perplexity') url = "https://api.perplexity.ai/chat/completions";
                else if (p === 'openai') url = "https://api.openai.com/v1/chat/completions";
                else url = "https://api.groq.com/openai/v1/chat/completions";

                let messages = [];
                messages.push({ role: "system", content: sysPrompt });
                history.forEach(msg => {
                    messages.push({ role: msg.role, content: msg.content });
                });
                let currentContent = [];
                if (file) {
                    currentContent.push({ type: "text", text: txt });
                    currentContent.push({ type: "image_url", image_url: { url: `data:${mime};base64,${file}` } });
                } else {
                    currentContent = txt;
                }
                messages.push({ role: "user", content: currentContent });

                body = { ...body, model: m, messages: messages, temperature: 0.3 };
            }
            
            const r = await fetch(url, {method:'POST', headers, body:JSON.stringify(body), signal:sig});
            if(!r.ok) throw new Error(await r.text());
            const d = await r.json();
            return p==='gemini' ? (d.candidates?.[0]?.content?.parts?.[0]?.text) : (d.choices?.[0]?.message?.content);
        }
    </script>
</body>
</html>