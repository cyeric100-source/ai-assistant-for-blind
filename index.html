<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI è¦–éšœåŠ©ç† (2025 å…¨èƒ½æ’ç‰ˆçµ‚æ¥µç‰ˆ)</title>
    
    <!-- å¼•å…¥ Marked.js è§£æ Markdown -->
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/lib/marked.umd.min.js"></script>
    
    <!-- å¼•å…¥ DOMPurify é€²è¡Œ HTML æ¶ˆæ¯’ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.8/purify.min.js"></script>

    <!-- ã€æ ¸å¿ƒè¨­å®šã€‘PDF.js v5.4.449 : è®€å–æœ¬åœ° pdf-dist è³‡æ–™å¤¾ -->
    <script type="module">
        if (window.location.protocol === 'file:') {
            document.documentElement.innerHTML = `
                <body style="background:#000; color:#fff; display:flex; flex-direction:column; justify-content:center; align-items:center; height:100vh; margin:0; font-family:sans-serif;">
                    <h1 style="color:yellow; font-size:2.5rem; text-align:center;">âš ï¸ ç’°å¢ƒéŒ¯èª¤</h1>
                    <p style="font-size:1.5rem; text-align:center; max-width:800px; line-height:1.6;">
                        ç‚ºäº†ç¢ºä¿åŠŸèƒ½æ­£å¸¸ï¼Œæœ¬ç¨‹å¼<strong>ä¸æ”¯æ´</strong>åœ¨æœ¬æ©Ÿç›´æ¥é–‹å•Ÿã€‚<br>
                        è«‹ä¸Šå‚³è‡³ GitHub Pages æˆ–ç·šä¸Šç¶²å€é–‹å•Ÿä½¿ç”¨ã€‚
                    </p>
                </body>
            `;
            throw new Error("Local execution blocked.");
        }

        const PDF_BASE = './pdf-dist/pdf.mjs';
        const WORKER_URL = './pdf-dist/pdf.worker.mjs';

        async function initPdfSystem() {
            try {
                const response = await fetch(PDF_BASE, { method: 'HEAD' });
                if (!response.ok) throw new Error("Missing pdf-dist");
                const pdfjsLib = await import(PDF_BASE);
                window.pdfjsLib = pdfjsLib;
                pdfjsLib.GlobalWorkerOptions.workerSrc = WORKER_URL;
                window.dispatchEvent(new Event('pdfjs-loaded'));
            } catch (e) {
                window.reportError("PDF æ ¸å¿ƒè¼‰å…¥å¤±æ•—ï¼", e);
            }
        }
        initPdfSystem();
    </script>
    
    <style>
        :root {
            --bg-color: #000000;
            --text-color: #FFFFFF;
            --accent-color: #FFFF00;
            --user-header-color: #0088ff;
            --ai-header-color: #FFFF00;
            --border-color: #555;
            --input-bg: #1A1A1A;
            --button-bg: #FFFF00;
            --button-text: #000000;
            --status-bg: #222;
        }

        body {
            font-family: system-ui, -apple-system, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0; padding: 0;
            font-size: 1.2rem; line-height: 1.6;
            padding-top: 60px;
            user-select: none;
        }
        
        .message-area { -webkit-user-select: text; user-select: text; }
        .container { max-width: 900px; margin: 0 auto; padding: 10px 10px 450px 10px; }
        .app-title { font-size: 1.5rem; text-align: center; margin: 10px 0; color: #ccc; font-weight: bold; }
        
        input, select, textarea {
            width: 100%; padding: 12px; margin-top: 5px; margin-bottom: 10px;
            background: var(--input-bg); border: 2px solid var(--border-color);
            color: var(--text-color); font-size: 1.1rem; border-radius: 6px; box-sizing: border-box;
        }

        button {
            background-color: var(--button-bg); color: var(--button-text);
            border: 2px solid #fff; padding: 12px; font-size: 1.1rem; font-weight: bold;
            border-radius: 8px; margin-top: 5px; cursor: pointer;
        }
        button:disabled { filter: grayscale(100%); opacity: 0.7; }
        
        .message {
            background: #111; padding: 15px; margin-bottom: 25px;
            border-left: 5px solid var(--border-color);
            overflow-wrap: break-word;
        }
        .message.user { border-left-color: var(--user-header-color); background: #0a0a1a; }
        .message.assistant { border-left-color: var(--ai-header-color); background: #1a1a0a; }

        .markdown-body h2 { color: #88CCFF; margin-top: 1.5em; border-bottom: 1px solid #333; padding-bottom: 5px; }
        .markdown-body table { width: 100%; border-collapse: collapse; margin-bottom: 1rem; }
        .markdown-body th, .markdown-body td { border: 1px solid #555; padding: 8px; text-align: left; }

        .controls-wrapper {
            position: fixed; bottom: 0; left: 0; right: 0;
            background: #000; border-top: 3px solid var(--accent-color);
            padding: 10px; z-index: 100;
        }

        #status-bar {
            position: fixed; top: 0; left: 0; right: 0;
            background: var(--status-bg); color: #fff;
            padding: 10px; text-align: center; font-weight: bold;
            border-bottom: 2px solid var(--border-color); z-index: 2000;
        }

        .hidden { display: none !important; }
        .row { display: flex; gap: 10px; margin-bottom: 8px; }
        .check-btn { flex: 1; display: flex; align-items: center; background: #222; padding: 10px; border-radius: 6px; cursor: pointer; }
    </style>
</head>
<body>

<div id="status-bar" role="status">ç³»çµ±åˆå§‹åŒ–ä¸­...</div>

<div class="container">
    <h1 class="app-title">AI è¦–éšœåŠ©ç† (2025 å…¨èƒ½æ’ç‰ˆçµ‚æ¥µç‰ˆ)</h1>

    <details id="settings-area">
        <summary><h2>è¨­å®š</h2></summary>
        <div>
            <label>AI æœå‹™å•†:</label>
            <select id="provider-select" onchange="handleProviderChange()">
                <option value="gemini">Google Gemini</option>
                <option value="openrouter">OpenRouter</option>
                <option value="openai">OpenAI</option>
            </select>
            <label>API Key:</label>
            <input type="password" id="api-key">
            <label>æ¨¡å‹é¸æ“‡:</label>
            <select id="model-select"></select>
            <button type="button" onclick="saveSettings()">å„²å­˜è¨­å®š</button>
        </div>
    </details>

    <details open style="background:#112233; border:2px solid #005588; padding:10px; border-radius:8px; margin-top:10px;">
        <summary><h2 style="display:inline; color:#88ccff;">PDF æ™ºèƒ½é–±è®€å·¥å…·ç®±</h2></summary>
        <div style="margin-top:15px;">
            <input type="file" id="pdf-tool-input" class="hidden" accept="application/pdf" onchange="handlePDFToolFileSelect()">
            <button type="button" id="pdf-start-btn" style="width:100%;" onclick="document.getElementById('pdf-tool-input').click()" disabled>ğŸ“„ é¸æ“‡ PDF é€²è¡Œå®Œæ•´é–±è®€</button>
            <div class="row" style="margin-top:10px;">
                <label class="check-btn"><input type="checkbox" id="pdf-translate"> <span>ç¿»è­¯æˆç¹é«”ä¸­æ–‡</span></label>
            </div>
        </div>
    </details>

    <div id="chat-output" class="message-area"></div>
</div>

<footer class="controls-wrapper">
    <form onsubmit="handleSubmit(event)">
        <div class="row">
            <input type="file" id="file-input" class="hidden" onchange="handleFileSelect()">
            <button type="button" onclick="document.getElementById('file-input').click()" style="flex:1;">é¸æ“‡æª”æ¡ˆ</button>
            <button type="button" onclick="resetConversation()" style="flex:1; background:#442222; color:white;">æ¸…é™¤å°è©±</button>
        </div>
        <div class="row">
            <button type="button" id="voice-btn" style="height:80px; width:100px;">æŒ‰ä½èªªè©±</button>
            <textarea id="user-input" placeholder="è¼¸å…¥è¨Šæ¯..." rows="3" style="flex:1;"></textarea>
            <button type="submit" style="height:80px; width:80px;">å‚³é€</button>
        </div>
    </form>
</footer>

<script>
    // --- ã€ä¿®æ­£ 1 & 2ã€‘æ–‡å­—æ’ç‰ˆå¼•æ“ ---
    class UniversalTextNormalizer {
        static getScriptType(char) {
            if (!char) return 'other';
            const code = char.charCodeAt(0);
            if ((code >= 0x4E00 && code <= 0x9FFF) || (code >= 0xAC00 && code <= 0xD7AF)) return 'cjk';
            if ((code >= 0x0E00 && code <= 0x0E7F)) return 'sea';
            if ((code >= 0x0041 && code <= 0x005A) || (code >= 0x0061 && code <= 0x007A) || (code >= 0x0030 && code <= 0x0039)) return 'latin';
            return 'other';
        }

        static normalize(text, mode = 'pdf') {
            if (!text) return "";
            let res = text.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
            res = res.replace(/([a-zA-Z])-\n([a-zA-Z])/g, "$1$2");

            const lines = res.split("\n");
            let processed = "";
            
            for (let i = 0; i < lines.length; i++) {
                let curr = lines[i].trim();
                if (curr.length === 0) { processed += "\n\n"; continue; }
                
                const isTable = (line) => line && (line.includes('|') || line.includes('---'));

                if (i < lines.length - 1) {
                    let next = lines[i + 1].trim();
                    if (next.length === 0 || isTable(curr) || isTable(next)) {
                        processed += curr + "\n";
                        continue;
                    }
                    
                    if (mode === 'ai' && (/^[-*â€¢#\d.]/.test(next) || /^[-*â€¢#]/.test(curr))) {
                        processed += curr + "\n";
                        continue;
                    }

                    let lastChar = curr.slice(-1);
                    let nextChar = next.charAt(0);
                    const typeA = this.getScriptType(lastChar);
                    const typeB = this.getScriptType(nextChar);

                    if ((typeA === 'cjk' || typeA === 'sea') && (typeB === 'cjk' || typeB === 'sea')) {
                        processed += curr; 
                    } else if ((typeA === 'cjk' && typeB === 'latin') || (typeA === 'latin' && typeB === 'cjk')) {
                         processed += curr;
                    } else {
                        processed += curr + " ";
                    }
                } else {
                    processed += curr;
                }
            }

            processed = processed.replace(/([\u4e00-\u9fff])\s+([\u4e00-\u9fff])/g, "$1$2");
            processed = processed.replace(/([\u4e00-\u9fff])\s+([a-zA-Z0-9])/g, "$1$2");
            processed = processed.replace(/([a-zA-Z0-9])\s+([\u4e00-\u9fff])/g, "$1$2");

            return processed.replace(/\n{3,}/g, "\n\n").trim();
        }
    }

    // --- ã€ä¿®æ­£ 3 & 4ã€‘PDF è™•ç†èˆ‡è¡¨æ ¼è¡çªè§£æ±º ---
    class AdvancedLayoutEngine {
        constructor(items, pageWidth) { 
            this.items = items; 
            this.pageWidth = pageWidth; 
        }

        process() {
            const lines = this.groupIntoLines(this.items);
            lines.sort((a, b) => a.y - b.y);
            
            let result = "";
            let currentBlock = [];
            for (let i = 0; i < lines.length; i++) {
                currentBlock.push(lines[i]);
                const nextLine = lines[i+1];
                // åˆ¤æ–·æ®µè½é–“è· (å¤§æ–¼ 1.5 å€è¡Œé«˜å‰‡æ–·é–‹)
                if (!nextLine || (nextLine.y - lines[i].y > lines[i].avgHeight * 1.5)) {
                    if (this.isTableBlock(currentBlock)) { 
                        result += this.renderMarkdownTable(currentBlock) + "\n\n"; 
                    } else { 
                        result += this.renderParagraphs(currentBlock) + "\n"; 
                    }
                    currentBlock = [];
                }
            }
            return result;
        }

        groupIntoLines(items) {
            const lines = [];
            // é å…ˆåˆä½µæ¥µè¿‘çš„ç‰‡æ®µ (è§£æ±º PDF æ–‡å­—ç¢è£‚å•é¡Œ)
            items.sort((a, b) => a.y - b.y || a.x - b.x);
            
            items.forEach(item => {
                const match = lines.find(l => Math.abs(l.y - item.y) < item.fontHeight * 0.4);
                if (match) {
                    const last = match.items[match.items.length - 1];
                    // å¦‚æœå…©å€‹ç‰‡æ®µè·é›¢å°æ–¼å­—é«”é«˜åº¦çš„ 20%ï¼Œç›´æ¥åˆä½µ
                    if (item.x - (last.x + last.w) < item.fontHeight * 0.2) {
                        last.str += item.str;
                        last.w = (item.x + item.w) - last.x;
                    } else {
                        match.items.push(item);
                    }
                } else {
                    lines.push({ y: item.y, avgHeight: item.fontHeight, items: [item] });
                }
            });
            lines.forEach(l => l.items.sort((a, b) => a.x - b.x));
            return lines;
        }

        isTableBlock(lines) {
            if (lines.length < 2) return false;
            // åš´æ ¼åˆ¤å®šï¼šæ¯ä¸€è¡Œéƒ½å¿…é ˆæœ‰è‡³å°‘å…©å€‹ç¨ç«‹ç‰‡æ®µï¼Œä¸”ç‰‡æ®µä¹‹é–“çš„æ°´å¹³é–“è·å¤§æ–¼å­—é«”é«˜åº¦
            let tableLikeLines = 0;
            lines.forEach(line => {
                let distinctGaps = 0;
                for (let i = 0; i < line.items.length - 1; i++) {
                    const gap = line.items[i+1].x - (line.items[i].x + line.items[i].w);
                    if (gap > line.avgHeight * 1.2) distinctGaps++;
                }
                if (distinctGaps >= 1) tableLikeLines++;
            });
            // è‡³å°‘è¦æœ‰ 60% çš„è¡Œçœ‹èµ·ä¾†åƒè¡¨æ ¼
            return (tableLikeLines / lines.length) > 0.6;
        }

        renderMarkdownTable(lines) {
            let md = "";
            lines.forEach((line, idx) => {
                let row = line.items.map(it => it.str.trim()).join(' | ');
                md += `| ${row} |\n`;
                if (idx === 0) md += `| ${line.items.map(() => '---').join(' | ')} |\n`;
            });
            return md;
        }

        renderParagraphs(lines) {
            return lines.map(l => l.items.map(it => it.str).join(' ')).join('\n');
        }
    }

    async function performAIProcessing(file, sourceMode, textData, needTranslate) {
        const controller = new AbortController(); 
        let pagesContent = [];

        if (sourceMode === "image") {
            const arrayBuffer = await file.arrayBuffer();
            const pdf = await window.pdfjsLib.getDocument({ data: arrayBuffer }).promise;
            updateStatusBar(`OCR è™•ç†ä¸­ (å…± ${pdf.numPages} é )...`, "busy");
            
            for (let i = 1; i <= pdf.numPages; i++) {
                const page = await pdf.getPage(i);
                const viewport = page.getViewport({ scale: 2.0 });
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = viewport.width; canvas.height = viewport.height;
                await page.render({ canvasContext: ctx, viewport }).promise;
                
                const imgBase64 = canvas.toDataURL('image/jpeg', 0.8).split(',')[1];
                const rawText = await callAI(document.getElementById('provider-select').value, "Transcribe exactly.", imgBase64, "image/jpeg", controller.signal, null, null, DEFAULT_OCR_PROMPT);
                pagesContent.push(UniversalTextNormalizer.normalize(rawText, 'ai'));
                canvas.remove();
            }
        } else {
            // æ–‡å­—ç‰ˆ PDF åˆ†å‰²èˆ‡é‡æ–°æ’ç‰ˆ
            const pageMarkers = textData.split(/\[PAGE_SEP_(\d+)\]/);
            for (let i = 1; i < pageMarkers.length; i += 2) {
                const content = pageMarkers[i+1];
                pagesContent.push(UniversalTextNormalizer.normalize(content, 'pdf'));
            }
        }

        // æº–å‚™é¡¯ç¤ºå‰æ‰åŠ å…¥æ¨™é¡Œ
        let finalOutput = pagesContent.map((c, i) => `## [Page ${i + 1}]\n\n${c}`).join('\n\n');

        if (needTranslate) {
            updateStatusBar("æ­£åœ¨ç¿»è­¯...", "busy");
            const res = await callAI(document.getElementById('provider-select').value, `[SOURCE]:\n${finalOutput}`, null, null, controller.signal, null, null, DEFAULT_TRANSLATE_PROMPT);
            addMessage('assistant', res);
        } else {
            addMessage('assistant', finalOutput);
        }
        updateStatusBar("ä»»å‹™å®Œæˆ", "ready");
    }

    async function extractTextFromPDF_Accurate(file) {
        try {
            const arrayBuffer = await file.arrayBuffer();
            const pdf = await window.pdfjsLib.getDocument({ data: arrayBuffer }).promise;
            let output = "";
            for (let i = 1; i <= pdf.numPages; i++) {
                const page = await pdf.getPage(i);
                const content = await page.getTextContent();
                const viewport = page.getViewport({ scale: 1.0 });
                const items = content.items.map(it => ({
                    str: it.str,
                    x: it.transform[4],
                    y: viewport.height - it.transform[5],
                    w: it.width,
                    fontHeight: Math.abs(it.transform[3])
                }));
                const engine = new AdvancedLayoutEngine(items, viewport.width);
                output += `[PAGE_SEP_${i}]` + engine.process();
            }
            return output;
        } catch (e) { return null; }
    }

    // --- ç³»çµ±åŸºç¤åŠŸèƒ½ ---
    const DEFAULT_CHAT_PROMPT = "ä½ æ˜¯ä¸€ä½åŠ©ç†ï¼Œè«‹ç”¨ç¹é«”ä¸­æ–‡å›ç­”ã€‚";
    const DEFAULT_OCR_PROMPT = "è«‹ç²¾ç¢ºè½‰éŒ„æ–‡å­—ï¼Œä¿æŒçµæ§‹ã€‚";
    const DEFAULT_TRANSLATE_PROMPT = "è«‹å°‡å…§å®¹ç¿»è­¯æˆç¹é«”ä¸­æ–‡ï¼Œä¿ç•™ [Page X] æ¨™è¨˜ã€‚";
    const PROVIDERS = {
        gemini: { models: ["gemini-2.0-flash", "gemini-1.5-pro"] },
        openrouter: { models: ["google/gemini-2.0-flash-001", "openai/gpt-4o"] },
        openai: { models: ["gpt-4o"] }
    };
    let currentActiveModelId = "";
    let selectedFile = null;

    window.reportError = (m, e) => { document.getElementById('status-bar').innerText = m; console.error(e); };

    function handleProviderChange() {
        const p = document.getElementById('provider-select').value;
        const s = document.getElementById('model-select');
        s.innerHTML = "";
        PROVIDERS[p].models.forEach(m => {
            const o = document.createElement('option'); o.value = m; o.innerText = m; s.appendChild(o);
        });
        currentActiveModelId = s.value;
    }

    function saveSettings() {
        localStorage.setItem('api_key', document.getElementById('api-key').value);
        currentActiveModelId = document.getElementById('model-select').value;
        alert("è¨­å®šå„²å­˜");
    }

    function updateStatusBar(t, s = 'ready') {
        const b = document.getElementById('status-bar');
        b.innerText = t; b.style.background = s === 'busy' ? '#664400' : '#222';
    }

    function addMessage(role, content) {
        const div = document.createElement('div');
        div.className = `message ${role}`;
        div.innerHTML = `<div class="markdown-body">${DOMPurify.sanitize(marked.parse(content))}</div>`;
        document.getElementById('chat-output').appendChild(div);
        div.scrollIntoView();
        return div;
    }

    async function callAI(p, txt, file, mime, sig, ovModel, ovKey, sys) {
        const k = ovKey || document.getElementById('api-key').value;
        const m = ovModel || currentActiveModelId;
        if (!k) throw new Error("Need API Key");
        let url, body, headers = { 'Content-Type': 'application/json' };
        if (p === 'gemini') {
            url = `https://generativelanguage.googleapis.com/v1beta/models/${m}:generateContent?key=${k}`;
            body = { system_instruction: { parts: [{ text: sys }] }, contents: [{ role: "user", parts: file ? [{ inline_data: { mime_type: mime, data: file } }, { text: txt }] : [{ text: txt }] }] };
        } else {
            url = p === 'openai' ? "https://api.openai.com/v1/chat/completions" : "https://openrouter.ai/api/v1/chat/completions";
            headers['Authorization'] = `Bearer ${k}`;
            body = { model: m, messages: [{ role: "system", content: sys }, { role: "user", content: txt }] };
        }
        const r = await fetch(url, { method: 'POST', headers, body: JSON.stringify(body), signal: sig });
        const d = await r.json();
        return p === 'gemini' ? d.candidates[0].content.parts[0].text : d.choices[0].message.content;
    }

    function handlePDFToolFileSelect() {
        const f = document.getElementById('pdf-tool-input').files[0];
        if (f) processPDFTool(f);
    }

    async function processPDFTool(file) {
        updateStatusBar("åˆ†æ PDF...", "busy");
        const raw = await extractTextFromPDF_Accurate(file);
        const needTrans = document.getElementById('pdf-translate').checked;
        if (!raw || raw.replace(/\s/g, '').length < 100) {
            await performAIProcessing(file, "image", null, needTrans);
        } else {
            await performAIProcessing(file, "text", raw, needTrans);
        }
    }

    function handleFileSelect() {
        selectedFile = document.getElementById('file-input').files[0];
    }

    async function handleSubmit(e) {
        e.preventDefault();
        const txt = document.getElementById('user-input').value;
        if (!txt) return;
        updateStatusBar("æ€è€ƒä¸­...", "busy");
        addMessage('user', txt);
        try {
            const res = await callAI(document.getElementById('provider-select').value, txt, null, null, null, null, null, DEFAULT_CHAT_PROMPT);
            addMessage('assistant', res);
            document.getElementById('user-input').value = "";
        } catch (e) { reportError("å¤±æ•—", e); }
        finally { updateStatusBar("å°±ç·’"); }
    }

    function resetConversation() { document.getElementById('chat-output').innerHTML = ""; }

    window.addEventListener('pdfjs-loaded', () => {
        document.getElementById('pdf-start-btn').disabled = false;
        updateStatusBar("æº–å‚™å°±ç·’");
        handleProviderChange();
    });
</script>
</body>
</html>