<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI è¦–éšœåŠ©ç† (2025 å…¨èƒ½æ’ç‰ˆä¿®æ­£ç‰ˆ)</title>
    
    <!-- å¼•å…¥ Marked.js è§£æ Markdown -->
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/lib/marked.umd.min.js"></script>
    
    <!-- å¼•å…¥ DOMPurify é€²è¡Œ HTML æ¶ˆæ¯’ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.8/purify.min.js"></script>

    <!-- ã€æ ¸å¿ƒè¨­å®šã€‘PDF.js v5.4.449 : è®€å–æœ¬åœ° pdf-dist è³‡æ–™å¤¾ -->
    <script type="module">
        // è¨­å®šæœ¬åœ°è·¯å¾‘ (åŸºæ–¼ GitHub Desktop ä¸Šå‚³çµæ§‹)
        const PDF_BASE = './pdf-dist/pdf.mjs';
        const WORKER_URL = './pdf-dist/pdf.worker.mjs';

        async function initPdfSystem() {
            try {
                // 1. è¼‰å…¥ä¸»ç¨‹å¼åº«
                const pdfjsLib = await import(PDF_BASE);
                window.pdfjsLib = pdfjsLib;

                // 2. è¨­å®š Worker
                pdfjsLib.GlobalWorkerOptions.workerSrc = WORKER_URL;
                
                console.log("PDF System Initialized (Local Mode with Semantic Engine)");
                window.dispatchEvent(new Event('pdfjs-loaded'));

            } catch (e) {
                console.error("PDF Init Failed:", e);
                window.reportError("PDF æ ¸å¿ƒè¼‰å…¥å¤±æ•— (è«‹ç¢ºèª pdf-dist è³‡æ–™å¤¾æ­£ç¢º)", e);
            }
        }
        initPdfSystem();
    </script>
    
    <style>
        :root {
            --bg-color: #000000;
            --text-color: #FFFFFF;
            --accent-color: #FFFF00;      /* é»ƒè‰²é«˜äº® */
            --user-header-color: #0088ff; /* ç”¨æˆ¶æ¨™é¡Œè‰² */
            --ai-header-color: #FFFF00;   /* AI æ¨™é¡Œè‰² */
            --border-color: #555;
            --input-bg: #1A1A1A;
            --button-bg: #FFFF00;
            --button-text: #000000;
            --status-bg: #222;
            --tool-bg: #112233;
            --active-tab-bg: #004488;
            --active-tab-text: #ffffff;
        }

        body {
            font-family: system-ui, -apple-system, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0; padding: 0;
            font-size: 1.2rem; line-height: 1.6;
            padding-top: 60px;
            -webkit-user-select: none;
            user-select: none;
        }
        
        .message-area, #system-prompt, #user-input, input, #error-log-area {
            -webkit-user-select: text;
            user-select: text;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 10px 10px 450px 10px;
        }

        .app-title { 
            font-size: 1.5rem; text-align: center; margin: 10px 0; color: #ccc; font-weight: bold;
        }
        
        details h2 { 
            font-size: 1.4rem; color: #ccc; 
            border-bottom: 2px solid #333; padding-bottom: 5px; margin-top: 10px; 
            display: inline-block;
        }

        input, select, textarea {
            width: 100%; padding: 12px; margin-top: 5px; margin-bottom: 10px;
            background: var(--input-bg); border: 2px solid var(--border-color);
            color: var(--text-color); font-size: 1.1rem; border-radius: 6px; box-sizing: border-box;
        }

        #system-prompt, #error-log-area {
            min-height: 150px;
            resize: vertical;
            overflow-y: auto;
            font-family: monospace;
            line-height: 1.4;
        }
        
        *:focus-visible { outline: 4px solid var(--accent-color) !important; }

        button {
            background-color: var(--button-bg); color: var(--button-text);
            border: 2px solid #fff; padding: 12px; font-size: 1.1rem; font-weight: bold;
            border-radius: 8px; margin-top: 5px; cursor: pointer; touch-action: manipulation;
        }
        button:disabled { filter: grayscale(100%); opacity: 0.7; cursor: not-allowed; }
        button.secondary { background-color: #333; color: #fff; border-color: #777; }
        
        button.mini-copy-btn {
            background-color: #333; color: #fff; border: 1px solid #777;
            padding: 6px 12px; font-size: 0.9rem; margin-top: 10px;
            width: auto; display: inline-block;
        }
        button.mini-copy-btn:hover { background-color: #555; }
        
        button.danger {
            background-color: #550000; color: #ffcccc; border-color: #ff4444;
        }

        button.tool-btn {
            background-color: #0066cc; color: white; border: 2px solid #44aaff;
        }
        
        button.recording {
            background-color: #ff3333 !important; 
            color: #ffffff !important; 
            border-color: #ffaaaa !important;
            transform: scale(0.98);
            box-shadow: inset 0 0 10px #000;
        }
        
        .assign-btn-group {
            display: flex; gap: 8px; margin-bottom: 15px; flex-wrap: wrap;
        }
        .assign-btn-group button {
            flex: 1; font-size: 1rem; padding: 8px; margin-top: 0; min-width: 120px;
            background-color: #224466; color: #fff; border: 1px solid #4488cc;
        }
        .assign-btn-group button.reset {
            background-color: #442222; border-color: #cc6666;
        }

        #config-status-display {
            background: #1a1a1a; border: 1px solid #444; padding: 10px; 
            border-radius: 6px; margin-bottom: 15px; font-size: 0.95rem; color: #aaa;
        }
        #config-status-display strong { color: #88ccff; }
        #config-status-display .highlight { color: var(--accent-color); }

        .prompt-tabs {
            display: flex; gap: 2px; margin-top: 15px;
        }
        .prompt-tabs button {
            flex: 1; border-bottom-left-radius: 0; border-bottom-right-radius: 0;
            margin-top: 0; border-bottom: none; background: #333; color: #aaa;
            font-size: 1rem; padding: 10px 5px;
        }
        .prompt-tabs button.active {
            background: var(--active-tab-bg); color: var(--active-tab-text);
            border-color: #fff; font-weight: bold;
        }

        details { border: 1px solid var(--border-color); padding: 10px; border-radius: 8px; margin-bottom: 10px; background: #111; }
        summary { cursor: pointer; padding: 5px; }
        
        .pdf-tool-group {
            background: var(--tool-bg); border: 2px solid #005588;
        }
        .pdf-tool-group h2 { color: #88ccff; border-bottom-color: #005588; }
        
        .message-area { min-height: 100px; padding-bottom: 20px; }
        
        .message {
            background: #111; padding: 15px; margin-bottom: 25px;
            border-left: 5px solid var(--border-color);
            overflow-wrap: break-word; word-wrap: break-word; word-break: break-word;
        }
        .message:focus { outline: none; border-left: 8px solid var(--accent-color); background: #222; }

        .message h1.msg-heading {
            font-size: 1.4rem; margin: 0 0 10px 0; padding-bottom: 5px;
            border-bottom: 1px dashed #444; line-height: 1.3;
        }

        .message.user { border-left-color: var(--user-header-color); background: #0a0a1a; }
        .message.user h1.msg-heading { color: var(--user-header-color); }
        
        .message.assistant { border-left-color: var(--ai-header-color); background: #1a1a0a; }
        .message.assistant h1.msg-heading { color: var(--ai-header-color); }

        .message.error { border-left-color: #ff0000; background: #330000; }
        .message.error h1.msg-heading { color: #ff5555; }

        .markdown-body { line-height: 1.7; overflow-wrap: break-word; }
        .markdown-body h1, .markdown-body h2 { color: #88CCFF; border-bottom: none; margin-top: 1.5em; }
        .markdown-body p { margin-bottom: 10px; white-space: pre-wrap; } 
        .markdown-body pre { 
            background: #222; padding: 10px; overflow-x: auto; 
            border: 1px solid #444; white-space: pre; 
        }
        .markdown-body code { background: #333; padding: 2px 4px; word-break: break-all; }

        .controls-wrapper {
            position: fixed; bottom: 0; left: 0; right: 0;
            background: #000; border-top: 3px solid var(--accent-color);
            padding: 10px; z-index: 100;
        }

        .row { display: flex; gap: 10px; margin-bottom: 8px; align-items: flex-end; }
        
        .check-btn {
            display: flex; align-items: center; justify-content: center;
            background: #222; border: 1px solid #555; color: #fff;
            padding: 10px; border-radius: 6px; flex: 1;
            cursor: pointer; margin-top: 5px;
            height: auto; min-height: 52px;
        }
        .check-btn input { width: 20px; height: 20px; margin: 0 8px 0 0; }

        #user-input {
            margin: 0; min-height: 80px; max-height: 200px;
            resize: vertical; overflow-y: auto; flex: 1;
            transition: border-color 0.2s;
        }
        #user-input.dragover { border-color: var(--accent-color) !important; background-color: #222; }

        #status-bar-container {
            position: fixed; top: 0; left: 0; right: 0;
            z-index: 2000; display: flex; flex-direction: column;
        }
        
        #status-bar {
            background: var(--status-bg); color: #fff;
            padding: 10px; text-align: center;
            font-weight: bold; font-size: 1.1rem;
            border-bottom: 2px solid var(--border-color);
            transition: background-color 0.3s;
        }
        
        #visual-progress {
            background: #333; color: #88ccff; font-size: 0.9rem; 
            text-align: center; padding: 2px; border-bottom: 1px solid #444;
            display: none; 
        }
        #visual-progress.active { display: block; }

        #status-bar.ready { background: #004400; border-bottom-color: #00ff00; }
        #status-bar.busy { background: #664400; border-bottom-color: #ffff00; }
        #status-bar.error { background: #660000; border-bottom-color: #ff0000; }
        #status-bar.recording { background: #aa0000; border-bottom-color: #ff0000; animation: pulse-status 1s infinite; }
        
        @keyframes pulse-status {
             0% { background-color: #aa0000; }
             50% { background-color: #ff0000; }
             100% { background-color: #aa0000; }
        }

        .hidden { display: none !important; }
        .visually-hidden { position: absolute; width: 1px; height: 1px; overflow: hidden; clip: rect(0,0,0,0); }
        
        #custom-model-wrapper { margin-top: -5px; margin-bottom: 10px; }
        .settings-subsection { border: 1px solid #444; padding: 10px; border-radius: 6px; margin: 10px 0; background: #222; }
        .settings-subsection h3 { margin: 0 0 10px 0; font-size: 1.1rem; color: var(--accent-color); }
        .export-actions { margin-bottom: 20px; display: flex; gap: 10px; }
        
        .cors-notice { background: #442200; color: #ffcc88; padding: 8px; border-radius: 4px; margin-bottom: 10px; font-size: 0.95rem; border: 1px solid #ffaa00; }
    </style>
</head>
<body>

<!-- ç‹€æ…‹åˆ—å®¹å™¨ -->
<div id="status-bar-container">
    <div id="status-bar" role="status" aria-live="polite" tabindex="-1">ç³»çµ±åˆå§‹åŒ–ä¸­...</div>
    <div id="visual-progress" aria-hidden="true"></div>
</div>

<div class="container">
    <h1 class="app-title">AI è¦–éšœåŠ©ç† (2025 å…¨èƒ½æ’ç‰ˆä¿®æ­£ç‰ˆ)</h1>

    <!-- è¨­å®šå€ -->
    <details id="settings-area">
        <summary role="button" aria-expanded="false" id="settings-summary" aria-keyshortcuts="Alt+Shift+S">
            <h2>è¨­å®š (Alt+Shift+S)</h2>
        </summary>
        
        <div style="margin-top: 15px;">
            <div class="cors-notice">
                <strong>âš ï¸ é€£ç·šæç¤º (2025)ï¼š</strong> 
                æœ¬ç¨‹å¼ä½¿ç”¨æœ¬åœ°æ ¸å¿ƒè™•ç† PDFï¼Œé€£ç·šæ›´ç©©å®šã€‚æ¨è–¦ä½¿ç”¨ <strong>Google Gemini</strong> æˆ– <strong>OpenRouter</strong> é€²è¡Œ AI å°è©±ã€‚
            </div>

            <label for="provider-select">ä¸»è¦ AI æœå‹™å•†:</label>
            <select id="provider-select" onchange="handleProviderChange()">
                <option value="gemini">Google Gemini (æ¨è–¦ - ç©©å®šå¿«é€Ÿ)</option>
                <option value="openrouter">OpenRouter (è¬ç”¨ä¸­è½‰ - æ¨è–¦)</option>
                <option value="openai">OpenAI (å¯èƒ½éœ€ Proxy)</option>
                <option value="groq">Groq (å¯èƒ½éœ€ Proxy)</option>
                <option value="mistral">Mistral AI</option>
                <option value="perplexity">Perplexity</option>
            </select>

            <label for="api-key">ä¸»è¦ API Key:</label>
            <input type="password" id="api-key" placeholder="åœ¨æ­¤è²¼ä¸Šæ‚¨çš„ API Key" autocomplete="off">
            
            <label for="model-filter-input">ç¯©é¸æ¨¡å‹ (å³æ™‚æœå°‹):</label>
            <input type="text" id="model-filter-input" placeholder="è¼¸å…¥é—œéµå­—ç¯©é¸ (å¦‚: flash, pro)..." oninput="handleModelFilter()">

            <label for="model-select">æ¨¡å‹é¸æ“‡ (2025 Stable):</label>
            <div class="row" style="margin-bottom: 10px;">
                <select id="model-select" style="margin-bottom:0;" onchange="handleModelSelectChange()"></select>
                <button type="button" id="refresh-btn" class="secondary" style="width: auto; margin-top:0;" onclick="fetchOnlineModels()" title="å¾ç¶²è·¯æ›´æ–°æ¨¡å‹æ¸…å–®">æ›´æ–°</button>
            </div>
            
            <div id="custom-model-wrapper" class="hidden">
                <input type="text" id="custom-model-input" placeholder="æ‰‹å‹•è¼¸å…¥æ¨¡å‹ ID" onchange="handleCustomInputChange()">
            </div>

            <!-- ä»»å‹™æŒ‡æ´¾ -->
            <div class="settings-subsection">
                <h3>åˆ†å·¥è¨­å®š (Task Assignment)</h3>
                <div class="assign-btn-group">
                    <button type="button" onclick="setSpecificConfig('ocr')">è¨­ç‚º OCR PDF å°ˆç”¨</button>
                    <button type="button" onclick="setSpecificConfig('translate')">è¨­ç‚º ç¿»è­¯ PDF å°ˆç”¨</button>
                    <button type="button" class="reset" onclick="clearSpecificConfigs()">é‡ç½®ç‚ºè·Ÿéš¨ä¸»è¦è¨­å®š</button>
                </div>
                <div id="config-status-display" aria-live="polite">ç›®å‰è¨­å®šè¼‰å…¥ä¸­...</div>
            </div>

            <div id="openrouter-settings" class="hidden settings-subsection">
                <h3>OpenRouter æœå°‹è¨­å®š</h3>
                <label class="check-btn">
                    <input type="checkbox" id="openrouter-web-search">
                    <span>å•Ÿç”¨è¯ç¶²æœå°‹ (Web Search)</span>
                </label>
            </div>
            
            <label class="check-btn" style="flex:none; width:auto; margin-bottom: 10px;">
                <input type="checkbox" id="enter-to-send" checked>
                <span>æŒ‰ Enter éµå‚³é€ (å–æ¶ˆå‹¾é¸å‰‡ Enter ç‚ºæ›è¡Œ)</span>
            </label>

            <div class="settings-subsection">
                <h3>èªéŸ³è¼¸å…¥è¨­å®š</h3>
                <label for="voice-engine">èªéŸ³è¾¨è­˜å¼•æ“:</label>
                <select id="voice-engine" onchange="saveVoiceSettings()">
                    <option value="browser">ç€è¦½å™¨åŸç”Ÿ (å…è²»ï¼Œå°è¬›æ©Ÿæ¨¡å¼)</option>
                    <option value="openai">OpenAI Whisper (é«˜æº–ç¢ºï¼Œéœ€ä»˜è²»)</option>
                    <option value="groq">Groq Whisper (æ¥µé€Ÿï¼Œéœ€ Key)</option>
                </select>
                <label for="voice-api-key">èªéŸ³è¾¨è­˜å°ˆç”¨ API Key (é¸å¡«):</label>
                <input type="password" id="voice-api-key" placeholder="è‹¥ç•™ç©ºï¼Œå°‡å˜—è©¦ä½¿ç”¨ä¸»è¦ API Key" autocomplete="off" onchange="saveVoiceSettings()">
            </div>

            <label for="timeout-setting">å›æ‡‰é€¾æ™‚ (ç§’):</label>
            <input type="number" id="timeout-setting" value="120" min="5" step="5">

            <!-- ç³»çµ±æŒ‡ä»¤ç·¨è¼¯å™¨ -->
            <label style="margin-top: 15px; display:block; font-weight:bold;">ç³»çµ±æŒ‡ä»¤ (System Prompts):</label>
            <div class="prompt-tabs">
                <button type="button" id="tab-chat" class="active" onclick="switchPromptEditor('chat')">ç·¨è¼¯: ä¸€èˆ¬å°è©±</button>
                <button type="button" id="tab-ocr" onclick="switchPromptEditor('ocr')">ç·¨è¼¯: OCR å°ˆç”¨</button>
                <button type="button" id="tab-translate" onclick="switchPromptEditor('translate')">ç·¨è¼¯: ç¿»è­¯å°ˆç”¨</button>
            </div>
            <textarea id="system-prompt" placeholder="åœ¨æ­¤è¼¸å…¥ç³»çµ±æŒ‡ä»¤..."></textarea>
            
            <!-- éŒ¯èª¤å›å ±å€ -->
            <div class="settings-subsection" style="border-color: #550000; background: #220000;">
                <h3>éŒ¯èª¤è¨ºæ–·æ—¥èªŒ (Debug Log)</h3>
                <textarea id="error-log-area" readonly placeholder="ç³»çµ±éŒ¯èª¤å°‡é¡¯ç¤ºæ–¼æ­¤..."></textarea>
                <button type="button" onclick="copyErrorLog()">è¤‡è£½éŒ¯èª¤å…§å®¹ä»¥å›å ±</button>
            </div>

            <div class="row">
                <button type="button" onclick="saveSettings()">å„²å­˜è¨­å®š</button>
                <button type="button" onclick="restoreDefaults()" class="secondary">æ¢å¾©é è¨­å€¼</button>
                <button type="button" onclick="showHelp()" class="secondary" style="background:#004488; color:white;">åŠŸèƒ½èªªæ˜</button>
            </div>
        </div>
    </details>

    <!-- PDF å®Œæ•´é–±è®€å·¥å…·ç®± -->
    <details class="pdf-tool-group" open>
        <summary role="button" aria-expanded="true">
            <h2>PDF æ™ºèƒ½é–±è®€å·¥å…·ç®± (OCR & ç¿»è­¯)</h2>
        </summary>
        <div style="margin-top: 15px;">
            <input type="file" id="pdf-tool-input" class="visually-hidden" accept="application/pdf" onchange="handlePDFToolFileSelect()">

            <button type="button" id="pdf-start-btn" class="tool-btn" onclick="document.getElementById('pdf-tool-input').click()" disabled>
                ğŸ“„ PDF å®Œæ•´é–±è®€ (æœ¬åœ°æ ¸å¿ƒå°±ç·’)
            </button>
            <small style="display:block; margin: 5px 0 15px 0; color:#ccc;">
                * èªªæ˜ï¼šå„ªå…ˆä½¿ç”¨æœ¬æ©Ÿèªç¾©æå–ï¼ˆä¿®å¾©å–®å­—ç ´ç¢èˆ‡äº‚ç¢¼ï¼‰ã€‚è‹¥å¤±æ•—ï¼Œè‡ªå‹•è½‰ç‚ºåœ–ç‰‡ OCRã€‚
            </small>

            <div class="row">
                <label class="check-btn">
                    <input type="checkbox" id="pdf-always-ai">
                    <span>ç¸½æ˜¯å°‡ PDF å‚³çµ¦ AI (è·³éæœ¬æ©Ÿæå–)</span>
                </label>

                <label class="check-btn">
                    <input type="checkbox" id="pdf-translate">
                    <span>ç¿»è­¯æˆç¹é«”ä¸­æ–‡ (OCRå¾Œç¿»è­¯)</span>
                </label>
            </div>
        </div>
    </details>

    <!-- çµæœå€ -->
    <main role="main">
        <div id="chat-output" class="message-area"></div>
        
        <div class="export-actions">
            <button type="button" id="copy-btn" class="secondary hidden" onclick="copyResult()" aria-keyshortcuts="Alt+Shift+C" style="flex:1;">
                è¤‡è£½ (Alt+Shift+C)
            </button>
            <button type="button" id="export-txt-btn" class="secondary hidden" onclick="exportChat('txt')" aria-keyshortcuts="Alt+Shift+T" style="flex:1;">
                åŒ¯å‡º TXT (Alt+Shift+T)
            </button>
            <button type="button" id="export-html-btn" class="secondary hidden" onclick="exportChat('html')" aria-keyshortcuts="Alt+Shift+H" style="flex:1;">
                åŒ¯å‡º HTML (Alt+Shift+H)
            </button>
        </div>
    </main>
</div>

<!-- æ§åˆ¶å€ -->
<footer class="controls-wrapper" role="region" aria-label="æ“ä½œå€">
    <form onsubmit="handleSubmit(event)">
        <div class="row">
            <input type="file" id="file-input" class="visually-hidden" accept="*/*" onchange="handleFileSelect()">
            
            <button type="button" id="upload-btn" class="secondary" onclick="document.getElementById('file-input').click()" aria-keyshortcuts="Alt+Shift+U" style="flex:1;">
                é¸æ“‡æª”æ¡ˆ (Alt+Shift+U)
            </button>
            
            <button type="button" id="new-chat-btn" class="danger" onclick="resetConversation()" aria-keyshortcuts="Alt+Shift+N" style="flex:1;">
                æ¸…é™¤å°è©± (Alt+Shift+N)
            </button>

            <label class="check-btn" style="flex:1;">
                <input type="checkbox" id="pause-send" aria-keyshortcuts="Alt+Shift+P">
                <span>æš«åœå‚³é€ (Alt+Shift+P)</span>
            </label>
        </div>
        
        <div class="row">
            <button type="button" id="voice-btn" class="secondary" aria-keyshortcuts="Alt+Shift+V" style="width: auto; padding: 0 15px; height: 80px; margin:0; font-size: 1.2rem;" title="èªéŸ³è¼¸å…¥ (æŒ‰ä½ä¸æ”¾èªªè©±)" aria-label="èªéŸ³è¼¸å…¥ (æŒ‰ä½ä¸æ”¾èªªè©±)">
                æŒ‰ä½èªªè©±
            </button>
            
            <textarea id="user-input" placeholder="è¼¸å…¥è¨Šæ¯... (å¯æ‹–æ”¾æª”æ¡ˆæˆ– Ctrl+V)" aria-keyshortcuts="Alt+Shift+I" autocomplete="off" rows="3" aria-label="è¼¸å…¥è¨Šæ¯å€"></textarea>
            
            <button type="submit" id="submit-btn" aria-keyshortcuts="Alt+Shift+K" style="width: 80px; height: 80px; margin:0;" title="ç™¼é€ (Alt+Shift+K)">å‚³é€</button>
        </div>
    </form>
</footer>

<script>
    // --- ã€æ ¸å¿ƒå¼•æ“ 1ã€‘å…¨èƒ½æ–‡å­—é‡çµ„å¼•æ“ (Universal Text Normalizer) ---
    // è² è²¬å°æ‰€æœ‰æ–‡å­—ä¾†æºé€²è¡Œã€Œèªç¾©æ„ŸçŸ¥ã€çš„å¾Œè™•ç†ï¼Œæ¸…é™¤å¤šé¤˜ç©ºæ ¼ï¼Œä¿®å¾©æ ¼å¼
    class UniversalTextNormalizer {
        // åˆ¤æ–·æ˜¯å¦ç‚ºç·Šæ¹Šå‹èªè¨€ (CJK + æ³°æ–‡ç­‰)
        static isCompactLang(char) {
            return /[\u2E80-\u2FD5\u3190-\u319f\u3400-\u4DBF\u4E00-\u9FCC\uF900-\uFAAD\u3000-\u303F\u3040-\u309F\u30A0-\u30FF\uAC00-\uD7AF\uFF00-\uFFEF\u0E00-\u0E7F]/.test(char);
        }

        // åˆ¤æ–·æ˜¯å¦ç‚ºå‰ç½®å‹ç¬¦è™Ÿ (å¦‚ $ ( [ )
        static isPrefixSymbol(char) {
            return /[$Â¥â‚¬Â£([{'"]/.test(char);
        }
        
        // åˆ¤æ–·æ˜¯å¦ç‚ºå¾Œç½®å‹ç¬¦è™Ÿ (å¦‚ % ) ] } . ,)
        static isSuffixSymbol(char) {
            return /[%\])}.,:;?!]/.test(char);
        }
        
        // åˆ¤æ–·æ˜¯å¦ç‚ºæ•¸å­—
        static isDigit(char) {
            return /\d/.test(char);
        }

        static normalize(text) {
            if (!text) return "";
            
            // 1. çµ±ä¸€æ›è¡Œç¬¦è™Ÿ
            let res = text.replace(/\r\n/g, "\n").replace(/\r/g, "\n");

            // 2. è™•ç†é€£å­—ç¬¦è™Ÿæ›è¡Œ (Hyphenation)
            res = res.replace(/([a-zA-Z])-\n([a-zA-Z])/g, "$1$2");

            // 3. æ®µè½é‡çµ„ (Paragraph Reconstruction)
            const lines = res.split("\n");
            let processed = "";
            
            for (let i = 0; i < lines.length; i++) {
                // å»é™¤è¡Œé¦–è¡Œå°¾ç©ºç™½ (è§£æ±º "  äºº é€  çº– ç¶­  ")
                let curr = lines[i].trim();
                
                if (curr.length === 0) {
                    processed += "\n\n"; 
                    continue;
                }
                
                if (i < lines.length - 1) {
                    let next = lines[i + 1].trim();
                    if (next.length === 0) {
                        processed += curr + "\n"; 
                        continue;
                    }
                    
                    let lastChar = curr.slice(-1);
                    let nextChar = next.charAt(0);
                    
                    // æ›è¡Œè™•é»åˆé‚è¼¯ï¼š
                    // å¦‚æœå…©é‚Šéƒ½æ˜¯ç·Šæ¹Šèªè¨€ï¼Œç›´æ¥é»åˆ
                    if (this.isCompactLang(lastChar) && this.isCompactLang(nextChar)) {
                        processed += curr;
                    } 
                    // å¦‚æœæ˜¯åˆ—è¡¨ç¬¦è™Ÿï¼Œä¿ç•™æ›è¡Œ
                    else if (/^[-*â€¢]/.test(next) || /^[-*â€¢]/.test(curr)) {
                        processed += curr + "\n";
                    }
                    else {
                        processed += curr + " ";
                    }
                } else {
                    processed += curr;
                }
            }

            // 4. å¼·åŠ›æ­£è¦åŒ–æ¸…ç† (Regex Cleaning)
            // ä¿®å¾© OCR æˆ–æå–éç¨‹ä¸­æ¼ç¶²çš„ "äºº é€ " (CJK + space + CJK)
            processed = processed.replace(/([\u2e80-\u9fff\uac00-\ud7af\u0e00-\u0e7f])\s+([\u2e80-\u9fff\uac00-\ud7af\u0e00-\u0e7f])/g, "$1$2");
            
            // ä¿®å¾©è²¨å¹£èˆ‡æ•¸å­— "$ 1,632" -> "$1,632"
            processed = processed.replace(/([$Â¥â‚¬Â£])\s+(\d)/g, "$1$2");
            
            // ä¿®å¾©æ‹¬è™Ÿ "( 5 æ¬¾" -> "(5æ¬¾"
            processed = processed.replace(/([(])\s+(.)/g, "$1$2");
            processed = processed.replace(/(.)\s+([)])/g, "$1$2");

            // ä¿®å¾©æ¨™é»å‰çš„å¤šé¤˜ç©ºæ ¼ "Word ." -> "Word."
            processed = processed.replace(/\s+([,.:;?!])/g, "$1");

            return processed.replace(/\n{3,}/g, "\n\n").trim();
        }
    }

    // --- å…¨åŸŸéŒ¯èª¤è™•ç†æ©Ÿåˆ¶ ---
    window.reportError = function(msg, errObj) {
        const time = new Date().toLocaleTimeString();
        const errText = errObj ? (errObj.stack || errObj.message || JSON.stringify(errObj)) : "N/A";
        const logEntry = `[${time}] ERROR: ${msg}\nDetails: ${errText}\n----------------\n`;
        
        const logArea = document.getElementById('error-log-area');
        if (logArea) logArea.value += logEntry;
        
        console.error(msg, errObj);
        
        const statusBar = document.getElementById('status-bar');
        if (statusBar) {
            statusBar.innerText = `éŒ¯èª¤: ${msg} (è«‹æŸ¥çœ‹æ—¥èªŒ)`;
            statusBar.className = 'error';
            statusBar.setAttribute('aria-live', 'assertive');
        }
        playAudioCue('error');
    };

    window.onerror = function(message, source, lineno, colno, error) {
        window.reportError(`Global: ${message}`, error);
    };

    window.addEventListener('pdfjs-loaded', () => {
        const btn = document.getElementById('pdf-start-btn');
        btn.innerText = "ğŸ“„ PDF å®Œæ•´é–±è®€ (æœ¬åœ°æ ¸å¿ƒå°±ç·’)";
        btn.disabled = false;
        showReadyStatus();
    });

    // --- é è¨­æŒ‡ä»¤ ---
    const DEFAULT_CHAT_PROMPT = `# è§’è‰²è¨­å®š
ä½ æ˜¯ä¸€ä½å°ˆç‚ºé¦™æ¸¯è¦–éšœäººå£«æœå‹™çš„ AI åŠ©ç†ã€‚

# è¦å‰‡
1. **èªè¨€**ï¼šç¹é«”ä¸­æ–‡ï¼ˆé¦™æ¸¯ï¼‰ã€‚
2. **æ ¼å¼**ï¼šä½¿ç”¨ Markdown æ¨™é¡Œ (#) èˆ‡æ¸…å–® (-)ï¼Œé¿å…è£é£¾æ€§ç¬¦è™Ÿã€‚
3. **ç²¾ç°¡**ï¼šé‡é»ç½®å‰ï¼Œèªæ°£å‹å–„ã€‚`;

    const DEFAULT_OCR_PROMPT = `
# SYSTEM ROLE
OCR Engine for visually impaired users.

# TASK
Transcribe text from the image strictly.

# RULES
1. **Verbatim**: No summaries. Output exact text.
2. **Format**: Markdown headers/lists.
3. **Language**: Keep original (mostly Traditional Chinese/English).`;

    const DEFAULT_TRANSLATE_PROMPT = `
# ROLE
Translator (Traditional Chinese - Hong Kong).

# TASK
Translate the input text fully and fluently. Fix broken lines.`;

    const PROMPT_VERSION_KEY = "prompt_ver_2025_release";
    
    // æ›´æ–°æ¨¡å‹æ¸…å–®
    const PROVIDERS = {
        gemini: { 
            prompt: DEFAULT_CHAT_PROMPT, 
            defaultModel: "gemini-2.5-flash", 
            canFetch: true, 
            listUrl: "https://generativelanguage.googleapis.com/v1beta/models?key={KEY}", 
            models: ["gemini-2.5-flash", "gemini-2.5-pro", "gemini-2.0-flash", "gemini-1.5-pro", "gemini-1.5-flash"] 
        },
        openrouter: { 
            prompt: DEFAULT_CHAT_PROMPT, 
            defaultModel: "openai/gpt-4o", 
            canFetch: true, 
            listUrl: "https://openrouter.ai/api/v1/models", 
            models: ["google/gemini-2.5-flash", "openai/gpt-4o", "anthropic/claude-3.5-sonnet"] 
        },
        mistral: { prompt: DEFAULT_CHAT_PROMPT, defaultModel: "mistral-large-latest", canFetch: true, listUrl: "https://api.mistral.ai/v1/models", models: ["mistral-large-latest"] },
        openai: { prompt: DEFAULT_CHAT_PROMPT, defaultModel: "gpt-4o", canFetch: true, listUrl: "https://api.openai.com/v1/models", models: ["gpt-4o"] },
        groq: { prompt: DEFAULT_CHAT_PROMPT, defaultModel: "llama-3.3-70b-versatile", canFetch: true, listUrl: "https://api.groq.com/openai/v1/models", models: ["llama-3.3-70b-versatile"] },
        perplexity: { prompt: DEFAULT_CHAT_PROMPT, defaultModel: "sonar-pro", canFetch: false, models: ["sonar-pro"] }
    };

    let currentActiveModelId = "";
    let selectedFile = null;
    let recognition = null; 
    let mediaRecorder = null;
    let audioChunks = [];
    let chatHistory = [];
    let audioContext = null;
    let allCurrentModels = [];
    let isVoiceRecording = false;
    let specificConfigs = { ocr: null, translate: null };
    let memoryPrompts = { chat: "", ocr: "", translate: "" };
    let currentEditingMode = 'chat'; 

    const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

    function ensureAudioContext() {
        if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
        if (audioContext.state === 'suspended') {
            audioContext.resume().catch(e => console.error("Audio resume failed", e));
        }
    }
    
    ['click', 'touchstart', 'keydown'].forEach(evt => {
        document.addEventListener(evt, ensureAudioContext, { once: false, passive: true });
    });
    
    document.addEventListener('keydown', handleGlobalShortcuts);

    function initVoiceButtonEvents() {
        const btn = document.getElementById('voice-btn');
        if (!btn) return;
        btn.addEventListener('touchstart', (e) => { e.preventDefault(); ensureAudioContext(); startVoiceRecording(); }, {passive: false});
        btn.addEventListener('touchend', (e) => { e.preventDefault(); stopVoiceRecording(); });
        btn.addEventListener('mousedown', (e) => { ensureAudioContext(); startVoiceRecording(); });
        btn.addEventListener('mouseup', (e) => { stopVoiceRecording(); });
        btn.addEventListener('mouseleave', (e) => { if(isVoiceRecording) stopVoiceRecording(); });
        btn.addEventListener('contextmenu', (e) => e.preventDefault());
    }

    function handleGlobalShortcuts(e) {
        if (!e.altKey || !e.shiftKey) return;
        const key = e.key.toLowerCase();
        
        if (key === 'v') {
            e.preventDefault(); ensureAudioContext();
            if (isVoiceRecording) stopVoiceRecording(); else startVoiceRecording();
            return;
        }

        const actions = {
            's': { id: 'settings-summary', type: 'click' },
            'c': { id: 'copy-btn', type: 'click' },
            't': { id: 'export-txt-btn', type: 'click' },
            'h': { id: 'export-html-btn', type: 'click' },
            'u': { id: 'upload-btn', type: 'click' },
            'n': { id: 'new-chat-btn', type: 'click' },
            'p': { id: 'pause-send', type: 'click' },
            'k': { id: 'submit-btn', type: 'click' },
            'i': { id: 'user-input', type: 'focus' },
            'r': { selector: '.mini-copy-btn', type: 'click' }
        };

        if (actions[key]) {
            e.preventDefault(); ensureAudioContext();
            let target;
            if (actions[key].id) target = document.getElementById(actions[key].id);
            else if (actions[key].selector) target = document.querySelector(actions[key].selector);
            if (target) {
                if (actions[key].type === 'click') target.click();
                else if (actions[key].type === 'focus') target.focus();
            }
        }
    }

    document.addEventListener('DOMContentLoaded', async () => {
        try {
            if (!localStorage.getItem(PROMPT_VERSION_KEY)) {
                ['gemini', 'openrouter', 'openai', 'groq', 'perplexity', 'mistral'].forEach(p => localStorage.removeItem(`${p}_prompt`));
                localStorage.setItem(PROMPT_VERSION_KEY, 'true');
            }

            const savedProvider = localStorage.getItem('provider');
            const settingsDetails = document.getElementById('settings-area');
            const savedTimeout = localStorage.getItem('timeout_setting');
            if (savedTimeout) document.getElementById('timeout-setting').value = savedTimeout;
            
            document.getElementById('openrouter-web-search').checked = (localStorage.getItem('openrouter_web_search') === 'true');
            const savedVoiceEngine = localStorage.getItem('voice_engine');
            if (savedVoiceEngine) document.getElementById('voice-engine').value = savedVoiceEngine;
            const savedVoiceKey = localStorage.getItem('voice_api_key');
            if (savedVoiceKey) document.getElementById('voice-api-key').value = savedVoiceKey;
            
            const savedEnter = localStorage.getItem('enter_to_send');
            document.getElementById('enter-to-send').checked = (savedEnter === null || savedEnter === 'true');

            const savedSpecifics = localStorage.getItem('specific_configs');
            if (savedSpecifics) { specificConfigs = JSON.parse(savedSpecifics); }
            updateConfigStatusDisplay();

            memoryPrompts.ocr = localStorage.getItem('custom_prompt_ocr') || DEFAULT_OCR_PROMPT;
            memoryPrompts.translate = localStorage.getItem('custom_prompt_translate') || DEFAULT_TRANSLATE_PROMPT;

            if (savedProvider && PROVIDERS[savedProvider]) {
                document.getElementById('provider-select').value = savedProvider;
                settingsDetails.open = false; 
            } else {
                document.getElementById('provider-select').value = 'gemini'; 
                settingsDetails.open = true; 
            }
            
            handleProviderChange(false); 
            initVoiceSystem();
            initPasteImage();
            initDragAndDrop();
            initEnterKey();
            initVoiceButtonEvents();

        } catch (e) {
            window.reportError("Init Error", e);
        }
    });

    function switchPromptEditor(mode) {
        const textarea = document.getElementById('system-prompt');
        memoryPrompts[currentEditingMode] = textarea.value;
        currentEditingMode = mode;
        textarea.value = memoryPrompts[mode];
        document.getElementById('tab-chat').classList.toggle('active', mode === 'chat');
        document.getElementById('tab-ocr').classList.toggle('active', mode === 'ocr');
        document.getElementById('tab-translate').classList.toggle('active', mode === 'translate');
    }

    function setSpecificConfig(type) {
        const provider = document.getElementById('provider-select').value;
        const model = currentActiveModelId;
        specificConfigs[type] = { provider, model };
        localStorage.setItem('specific_configs', JSON.stringify(specificConfigs));
        const currentKey = document.getElementById('api-key').value;
        if (currentKey) localStorage.setItem(`${provider}_key`, currentKey.trim());
        updateConfigStatusDisplay();
        showTransientStatus(`å·²è¨­å®š ${type} å°ˆç”¨æ¨¡å‹`);
    }

    function clearSpecificConfigs() {
        specificConfigs = { ocr: null, translate: null };
        localStorage.removeItem('specific_configs');
        updateConfigStatusDisplay();
        showTransientStatus("å·²é‡ç½®åˆ†å·¥è¨­å®š");
    }

    function updateConfigStatusDisplay() {
        const display = document.getElementById('config-status-display');
        let html = "<strong>ç›®å‰é…ç½®ï¼š</strong><br>";
        html += specificConfigs.ocr ? `â€¢ OCR: <span class="highlight">${specificConfigs.ocr.provider} / ${specificConfigs.ocr.model}</span><br>` : `â€¢ OCR: è·Ÿéš¨ä¸»è¦<br>`;
        html += specificConfigs.translate ? `â€¢ ç¿»è­¯: <span class="highlight">${specificConfigs.translate.provider} / ${specificConfigs.translate.model}</span>` : `â€¢ ç¿»è­¯: è·Ÿéš¨ä¸»è¦`;
        display.innerHTML = html;
    }

    function playAudioCue(type) {
        if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        const now = audioContext.currentTime;
        
        if (type === 'start') { 
            oscillator.type = 'sine'; oscillator.frequency.setValueAtTime(880, now); gainNode.gain.setValueAtTime(0.1, now); oscillator.start(now); oscillator.stop(now + 0.1); 
        } else if (type === 'success') { 
            oscillator.type = 'sine'; oscillator.frequency.setValueAtTime(440, now); oscillator.frequency.exponentialRampToValueAtTime(880, now + 0.15); gainNode.gain.setValueAtTime(0.1, now); oscillator.start(now); oscillator.stop(now + 0.2); 
        } else if (type === 'error') { 
            oscillator.type = 'sawtooth'; oscillator.frequency.setValueAtTime(150, now); gainNode.gain.setValueAtTime(0.15, now); oscillator.start(now); oscillator.stop(now + 0.4); 
        } else if (type === 'abort') {
            oscillator.type = 'triangle'; oscillator.frequency.setValueAtTime(400, now); oscillator.frequency.linearRampToValueAtTime(200, now + 0.1); gainNode.gain.setValueAtTime(0.1, now); oscillator.start(now); oscillator.stop(now + 0.1);
        }
    }

    function resetConversation() {
        chatHistory = []; 
        document.getElementById('chat-output').innerHTML = ""; 
        document.getElementById('user-input').value = "";
        selectedFile = null;
        document.getElementById('upload-btn').innerText = "é¸æ“‡æª”æ¡ˆ (Alt+Shift+U)";
        document.getElementById('file-input').value = "";
        toggleExportButtons(false);
        showTransientStatus("å°è©±å·²æ¸…é™¤", "info");
    }

    function handlePDFToolFileSelect() {
        const input = document.getElementById('pdf-tool-input');
        if (input.files.length > 0) {
            processPDFTool(input.files[0]);
            document.getElementById('status-bar').focus(); 
        }
        input.value = ""; 
    }
    
    // PDF ç©ºç™½é æª¢æ¸¬
    function isCanvasBlank(canvas) {
        try {
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            const w = canvas.width;
            const h = canvas.height;
            const cx = Math.floor(w / 2 - 25);
            const cy = Math.floor(h / 2 - 25);
            if (cx < 0 || cy < 0) return false; 
            const imageData = ctx.getImageData(cx, cy, 50, 50);
            const data = imageData.data;
            for(let i = 0; i < data.length; i += 4) {
                if (data[i+3] > 0 && (data[i] < 250 || data[i+1] < 250 || data[i+2] < 250)) return false; 
            }
            return true;
        } catch(e) { console.warn("Blank check skipped:", e); return false; }
    }

    async function processPDFTool(file) {
        if (typeof window.pdfjsLib === 'undefined') {
            alert("PDF æ ¸å¿ƒæ­£åœ¨è¼‰å…¥ä¸­ï¼Œè«‹ç¨å€™å†è©¦ã€‚");
            return;
        }

        if (!file || file.type !== 'application/pdf') { alert("è«‹é¸æ“‡ PDF æª”æ¡ˆ"); return; }
        resetConversation(); playAudioCue('start');
        
        const alwaysAI = document.getElementById('pdf-always-ai').checked;
        const needTranslate = document.getElementById('pdf-translate').checked;

        try {
            updateStatusBar("è«‹ç¨å¾Œï¼Œæ­£åœ¨åˆ†æ PDF...", "busy");
            let extractedText = "";
            let sourceMode = "text";

            if (!alwaysAI) {
                // ä½¿ç”¨æ”¹é€²çš„å¹¾ä½•æå–
                const localText = await extractTextFromPDF_Geometric(file);
                
                const cleanText = localText ? localText.replace(/\s/g, '') : "";
                if (cleanText.length > 50 && !/[\uFFFD]/.test(cleanText.slice(0, 100))) {
                    // **é—œéµæ­¥é©Ÿ**ï¼šæå–å¾Œç«‹åˆ»é€²è¡Œèªç¾©æ­£è¦åŒ–
                    extractedText = UniversalTextNormalizer.normalize(localText);
                    sourceMode = "text";
                    updateStatusBar("æ–‡å­—æå–æˆåŠŸï¼Œæº–å‚™è™•ç†...", "busy");
                } else {
                    sourceMode = "image";
                }
            } else {
                sourceMode = "image";
            }

            await performAIProcessing(file, sourceMode, extractedText, needTranslate);

        } catch (e) {
            window.reportError("PDF Processing Error", e);
        }
    }

    async function performAIProcessing(file, sourceMode, textData, needTranslate) {
        const controller = new AbortController(); 
        let accumulatedText = "";

        if (sourceMode === "image") {
            let ocrProvider = specificConfigs.ocr ? specificConfigs.ocr.provider : document.getElementById('provider-select').value;
            let ocrModel = specificConfigs.ocr ? specificConfigs.ocr.model : currentActiveModelId;
            let ocrApiKey = (ocrProvider === document.getElementById('provider-select').value) 
                            ? document.getElementById('api-key').value 
                            : localStorage.getItem(`${ocrProvider}_key`);
            const ocrSystemPrompt = memoryPrompts.ocr;

            if (!ocrApiKey) throw new Error(`ç¼ºå°‘ ${ocrProvider} (OCR) çš„ API Key`);

            const arrayBuffer = await file.arrayBuffer();
            const pdf = await window.pdfjsLib.getDocument({ 
                data: arrayBuffer, 
                cMapUrl: './pdf-dist/cmaps/', 
                cMapPacked: true,
                standardFontDataUrl: './pdf-dist/standard_fonts/'
            }).promise;
            
            const totalPages = pdf.numPages;
            updateVisualProgress(true, `OCR è™•ç†ä¸­ (å…± ${totalPages} é )`);
            
            for (let i = 1; i <= totalPages; i++) {
                if (i % 5 === 0) document.getElementById('visual-progress').innerText = `OCR é€²åº¦: ${i} / ${totalPages}`;
                
                const page = await pdf.getPage(i);
                const viewportRaw = page.getViewport({ scale: 1.0 });
                const maxDim = 1536; 
                const scale = Math.min(maxDim / Math.max(viewportRaw.width, viewportRaw.height), 2.0);
                const viewport = page.getViewport({ scale });
                const canvas = document.createElement('canvas');
                canvas.width = viewport.width; canvas.height = viewport.height;
                await page.render({ canvasContext: canvas.getContext('2d'), viewport }).promise;
                
                if (isCanvasBlank(canvas)) {
                    accumulatedText += `## [Page ${i}]\n(ç©ºç™½é )\n\n`;
                    canvas.remove(); continue; 
                }

                const imgBase64 = canvas.toDataURL('image/jpeg', 0.6).split(',')[1];
                let retry = 0; let pageText = "";
                while(retry < 3) {
                    try {
                        pageText = await callAI(ocrProvider, "Transcribe EXACTLY.", imgBase64, "image/jpeg", controller.signal, ocrModel, ocrApiKey, ocrSystemPrompt);
                        if (!pageText || pageText.trim().length === 0) pageText = "(ç„¡å…§å®¹)";
                        break;
                    } catch(e) { retry++; await sleep(1500); }
                }
                
                // OCR çµæœä¹Ÿå¿…é ˆç¶“éèªç¾©æ­£è¦åŒ–
                accumulatedText += `## [Page ${i}]\n${UniversalTextNormalizer.normalize(pageText)}\n\n`;
                canvas.remove(); await sleep(200); 
            }
            updateVisualProgress(false);

        } else {
            accumulatedText = textData; 
        }

        if (needTranslate) {
            let transProvider = specificConfigs.translate ? specificConfigs.translate.provider : document.getElementById('provider-select').value;
            let transModel = specificConfigs.translate ? specificConfigs.translate.model : currentActiveModelId;
            let transApiKey = (transProvider === document.getElementById('provider-select').value) 
                              ? document.getElementById('api-key').value 
                              : localStorage.getItem(`${transProvider}_key`);
            
            updateStatusBar("æ­£åœ¨ç¿»è­¯å…¨æ–‡...", "busy");
            const transInput = `[SOURCE TEXT]:\n${accumulatedText}`;
            const finalRes = await callAI(transProvider, transInput, null, null, controller.signal, transModel, transApiKey, memoryPrompts.translate);
            
            addMessage('assistant', UniversalTextNormalizer.normalize(finalRes));
        } else {
            updateStatusBar("è™•ç†å®Œæˆ", "ready");
            addMessage('assistant', accumulatedText);
        }

        playAudioCue('success'); 
        updateStatusBar("ä»»å‹™å®Œæˆ", "ready");
        setTimeout(() => {
            const output = document.getElementById('chat-output');
            if(output.lastChild) output.lastChild.focus();
        }, 500);
    }

    function updateVisualProgress(show, text="") {
        const el = document.getElementById('visual-progress');
        if (show) { el.classList.add('active'); el.innerText = text; } 
        else { el.classList.remove('active'); el.innerText = ""; }
    }

    // --- ã€æ ¸å¿ƒå¼•æ“ 2ã€‘å¹¾ä½•åº§æ¨™æ–‡å­—æå–å™¨ (Geometric Text Extractor) ---
    // æ”¹é€²ç‰ˆï¼šå¼•å…¥èªç¾©é»åˆé‚è¼¯ï¼Œé˜²æ­¢ "äºº é€ " æˆ– "$ 1"
    async function extractTextFromPDF_Geometric(file) {
        try {
            const arrayBuffer = await file.arrayBuffer();
            const loadingTask = window.pdfjsLib.getDocument({
                data: arrayBuffer,
                cMapUrl: './pdf-dist/cmaps/',
                cMapPacked: true,
                standardFontDataUrl: './pdf-dist/standard_fonts/',
                disableCombineTextItems: false 
            });
            const pdf = await loadingTask.promise;
            let fullText = "";

            for (let i = 1; i <= pdf.numPages; i++) {
                const page = await pdf.getPage(i);
                const content = await page.getTextContent();
                const items = content.items;
                
                if (items.length === 0) {
                    fullText += `## [Page ${i}]\n\n`;
                    continue;
                }

                let pageStr = "";
                let lastY = -1;
                let lastX = -1;
                let lastWidth = 0;
                let lastStr = "";

                for (let item of items) {
                    const str = item.str;
                    if (!str) continue;

                    const tx = item.transform;
                    const x = tx[4];
                    const y = tx[5];
                    const h = item.height || 10; 
                    const w = item.width;

                    // 1. æ›è¡Œæª¢æ¸¬
                    if (lastY !== -1 && Math.abs(y - lastY) > h * 0.5) {
                        pageStr += "\n";
                        lastX = -1; 
                    } 
                    // 2. èªç¾©æ„ŸçŸ¥é»åˆ (Semantic Aware Gluing)
                    else if (lastX !== -1) {
                        const expectedStart = lastX + lastWidth;
                        const gap = x - expectedStart;
                        
                        // ç²å–å‰å¾Œå­—å…ƒé€²è¡Œé¡å‹åˆ¤æ–·
                        const prevChar = lastStr.slice(-1);
                        const currChar = str.charAt(0);
                        
                        let shouldAddSpace = false;

                        // **é»åˆè¦å‰‡ A**: å¦‚æœå…©é‚Šéƒ½æ˜¯ç·Šæ¹Šèªè¨€ (CJK)ï¼Œå¼·åˆ¶ä¸åŠ ç©ºæ ¼
                        if (UniversalTextNormalizer.isCompactLang(prevChar) && UniversalTextNormalizer.isCompactLang(currChar)) {
                            shouldAddSpace = false;
                        }
                        // **é»åˆè¦å‰‡ B**: å‰é¢æ˜¯è²¨å¹£/å·¦æ‹¬è™Ÿç­‰å‰ç½®ç¬¦è™Ÿï¼Œå¾Œé¢æ˜¯æ•¸å­—/æ–‡å­— -> ä¸åŠ ç©ºæ ¼
                        else if (UniversalTextNormalizer.isPrefixSymbol(prevChar)) {
                            shouldAddSpace = false;
                        }
                        // **é»åˆè¦å‰‡ C**: å¾Œé¢æ˜¯æ¨™é»/å³æ‹¬è™Ÿ -> ä¸åŠ ç©ºæ ¼
                        else if (UniversalTextNormalizer.isSuffixSymbol(currChar)) {
                            shouldAddSpace = false;
                        }
                        // **è¦å‰‡ D**: å…¶ä»–æƒ…æ³ (å¦‚è‹±æ–‡)ï¼Œä¾è³´å¹¾ä½•è·é›¢
                        else {
                            if (gap > h * 0.15) { // é™ä½é–¾å€¼ä»¥é©æ‡‰ç·Šæ¹Šæ’ç‰ˆ
                                shouldAddSpace = true;
                            }
                        }

                        if (shouldAddSpace && str.trim().length > 0 && lastStr.trim().length > 0) {
                            pageStr += " ";
                        }
                    }

                    pageStr += str;
                    lastX = x;
                    lastY = y;
                    lastWidth = w;
                    lastStr = str;
                }
                fullText += `## [Page ${i}]\n${pageStr}\n\n`;
            }
            return fullText;
        } catch (e) {
            console.error("Geometric extract failed", e);
            return null;
        }
    }

    function initVoiceSystem() {
        const engine = document.getElementById('voice-engine').value;
        if (engine === 'browser') initBrowserSpeech(); 
        else if (recognition) { recognition.stop(); recognition = null; }
    }

    function initBrowserSpeech() {
        if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition(); 
            recognition.lang = 'zh-HK'; 
            recognition.continuous = true; 
            recognition.interimResults = true; 
            
            recognition.onstart = () => { 
                isVoiceRecording = true;
                const btn = document.getElementById('voice-btn');
                btn.classList.add('recording'); 
                btn.innerText = "æ”¾é–‹å‚³é€...";
                updateStatusBar('æ­£åœ¨è†è½...', 'recording'); 
                playAudioCue('start'); 
            };
            
            recognition.onresult = (e) => {
                let t = ''; 
                for (let i = e.resultIndex; i < e.results.length; ++i) {
                    if (e.results[i].isFinal) t += e.results[i][0].transcript;
                }
                if (t) document.getElementById('user-input').value += (document.getElementById('user-input').value ? " " : "") + t;
            };
            
            recognition.onerror = (e) => { 
                if (e.error !== 'aborted' && e.error !== 'no-speech') {
                    showTransientStatus('èªéŸ³éŒ¯èª¤', 'error'); 
                    playAudioCue('error');
                }
                stopVoiceInputUI();
            };
            
            recognition.onend = () => { 
                if (isVoiceRecording) { playAudioCue('abort'); }
                stopVoiceInputUI();
            };
        }
    }

    async function startVoiceRecording() {
        ensureAudioContext(); 
        if (isVoiceRecording) return;
        const engine = document.getElementById('voice-engine').value;
        
        if (engine === 'browser') {
            if (recognition) { try { recognition.start(); } catch(e) {} }
        } else {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream);
                audioChunks = []; 
                mediaRecorder.ondataavailable = e => audioChunks.push(e.data);
                mediaRecorder.onstop = async () => { 
                    await processWhisperAudio(new Blob(audioChunks, {type: mediaRecorder.mimeType}), engine, mediaRecorder.mimeType); 
                    stream.getTracks().forEach(t=>t.stop()); 
                };
                mediaRecorder.start(); 
                isVoiceRecording = true;
                document.getElementById('voice-btn').classList.add('recording');
                document.getElementById('voice-btn').innerText = "æ”¾é–‹å‚³é€...";
                playAudioCue('start');
            } catch (e) { 
                showTransientStatus('éº¥å…‹é¢¨éŒ¯èª¤', 'error'); playAudioCue('error'); 
            }
        }
    }

    function stopVoiceRecording() {
        if (!isVoiceRecording) return;
        ensureAudioContext(); 
        const engine = document.getElementById('voice-engine').value;
        playAudioCue('success');
        isVoiceRecording = false; 

        if (engine === 'browser' && recognition) {
            recognition.stop();
        } else if (mediaRecorder && mediaRecorder.state !== 'inactive') {
            mediaRecorder.stop();
            showTransientStatus('æ­£åœ¨è™•ç†éŒ„éŸ³...', 'busy');
        }
    }

    function stopVoiceInputUI() {
        isVoiceRecording = false;
        const btn = document.getElementById('voice-btn');
        btn.classList.remove('recording');
        btn.innerText = "æŒ‰ä½èªªè©±";
        if (!document.getElementById('status-bar').classList.contains('busy')) {
             showReadyStatus();
        }
    }

    async function processWhisperAudio(blob, engine, mime) {
        let apiKey = document.getElementById('voice-api-key').value || document.getElementById('api-key').value;
        if (!apiKey) return alert("éœ€ API Key");
        const fd = new FormData(); fd.append('file', blob, `rec.${mime.includes('mp4')?'mp4':'webm'}`);
        fd.append('model', engine === 'openai' ? 'whisper-1' : 'whisper-large-v3');
        try {
            const res = await fetch(engine==='openai'?"https://api.openai.com/v1/audio/transcriptions":"https://api.groq.com/openai/v1/audio/transcriptions", { method:'POST', headers:{'Authorization':`Bearer ${apiKey}`}, body:fd });
            const data = await res.json();
            if (data.text) { document.getElementById('user-input').value += (document.getElementById('user-input').value ? " " : "") + data.text; showTransientStatus("å®Œæˆ"); }
        } catch(e) { window.reportError("Whisper API Error", e); }
        finally { stopVoiceInputUI(); }
    }

    function saveVoiceSettings() { localStorage.setItem('voice_engine', document.getElementById('voice-engine').value); localStorage.setItem('voice_api_key', document.getElementById('voice-api-key').value); initVoiceSystem(); }
    function initPasteImage() { document.addEventListener('paste', e => { const f = e.clipboardData.files[0]; if(f && f.type.startsWith('image/')) handleFileSelect(f); }); }
    function initDragAndDrop() { const d = document.getElementById('user-input'); d.ondragover = e => {e.preventDefault(); d.classList.add('dragover')}; d.ondragleave = () => d.classList.remove('dragover'); d.ondrop = e => {e.preventDefault(); d.classList.remove('dragover'); handleFileSelect(e.dataTransfer.files[0]);}; }
    function initEnterKey() { document.getElementById('user-input').onkeydown = e => { if(e.key==='Enter' && !e.shiftKey && document.getElementById('enter-to-send').checked) { e.preventDefault(); document.getElementById('submit-btn').click(); } }; }
    
    function updateStatusBar(t, s='ready') { 
        const b = document.getElementById('status-bar'); 
        b.innerText = t; b.className = s; 
        b.setAttribute('aria-live', s === 'error' ? 'assertive' : 'polite');
    }
    
    function showReadyStatus() { updateStatusBar("æº–å‚™å°±ç·’"); }
    function showTransientStatus(m, t='success') { updateStatusBar(m, t==='error'?'error':'ready'); setTimeout(()=>{ if(!document.getElementById('status-bar').classList.contains('busy')) showReadyStatus(); }, 3000); }
    
    function addMessage(role, content) {
        const div = document.createElement('div'); div.className = `message ${role}`; div.tabIndex = -1;
        div.innerHTML = `<h1 class="msg-heading">${role==='user'?'è¼¸å…¥å•é¡Œï¼š':(role==='error'?'ç™¼ç”ŸéŒ¯èª¤ï¼š':'å›æ‡‰çµæœï¼š')}</h1><div class="markdown-body">${role==='user'?content:DOMPurify.sanitize(marked.parse(content))}</div>`;
        if(role==='assistant') {
            const btn = document.createElement('button'); btn.className='mini-copy-btn'; btn.innerText='è¤‡è£½ (Alt+Shift+R)';
            btn.onclick = () => navigator.clipboard.writeText(div.querySelector('.markdown-body').innerText).then(()=>showTransientStatus('å·²è¤‡è£½'));
            div.appendChild(btn);
        }
        document.getElementById('chat-output').appendChild(div); return div;
    }
    function toggleExportButtons(show) { ['copy-btn','export-txt-btn','export-html-btn'].forEach(id=>document.getElementById(id).classList.toggle('hidden', !show)); }
    
    function handleProviderChange(save=true) {
        const p = document.getElementById('provider-select').value; const c = PROVIDERS[p];
        document.getElementById('api-key').value = localStorage.getItem(`${p}_key`) || "";
        memoryPrompts.chat = localStorage.getItem(`${p}_prompt`) || c.prompt;
        
        if (currentEditingMode === 'chat') document.getElementById('system-prompt').value = memoryPrompts.chat;

        document.getElementById('openrouter-settings').classList.toggle('hidden', p!=='openrouter');
        allCurrentModels = JSON.parse(localStorage.getItem(`${p}_model_list`)) || c.models;
        handleModelFilter();
        currentActiveModelId = localStorage.getItem(`${p}_model`) || c.defaultModel;
        document.getElementById('refresh-btn').style.display = c.canFetch ? 'block' : 'none';
        if(save) localStorage.setItem('provider', p);
        resetConversation(); showReadyStatus();
    }
    function handleModelFilter() {
        const f = document.getElementById('model-filter-input').value.toLowerCase();
        updateModelSelect(allCurrentModels.filter(m=>m.toLowerCase().includes(f)), currentActiveModelId);
    }
    function updateModelSelect(list, active) {
        const s = document.getElementById('model-select'); s.innerHTML = "";
        let found = false;
        list.forEach(m => { const o = document.createElement('option'); o.value=m; o.innerText=m; if(m===active) found=true; s.appendChild(o); });
        const cust = document.createElement('option'); cust.value="CUSTOM"; cust.innerText="è‡ªè¡Œè¼¸å…¥..."; s.appendChild(cust);
        const w = document.getElementById('custom-model-wrapper');
        if(found) { s.value=active; w.classList.add('hidden'); } else { s.value="CUSTOM"; w.classList.remove('hidden'); document.getElementById('custom-model-input').value=active; }
    }
    async function fetchOnlineModels() {
        const p = document.getElementById('provider-select').value; const k = document.getElementById('api-key').value;
        if(!k && p!=='openrouter') return alert("éœ€ API Key");
        const btn = document.getElementById('refresh-btn'); btn.innerText="è®€å–ä¸­..."; btn.disabled=true;
        try {
            let list=[];
            if(p==='openrouter') list=(await(await fetch("https://openrouter.ai/api/v1/models")).json()).data.map(m=>m.id);
            else if(p==='gemini') list=(await(await fetch(PROVIDERS[p].listUrl.replace('{KEY}',k))).json()).models.filter(m=>m.supportedGenerationMethods?.includes("generateContent")).map(m=>m.name.replace("models/",""));
            else list=(await(await fetch(PROVIDERS[p].listUrl, {headers:{'Authorization':`Bearer ${k}`}})).json()).data.map(m=>m.id);
            if(list.length) { localStorage.setItem(`${p}_model_list`, JSON.stringify(list)); allCurrentModels=list; handleModelFilter(); showTransientStatus("å·²æ›´æ–°"); }
        } catch(e) { window.reportError("æ›´æ–°æ¨¡å‹åˆ—è¡¨å¤±æ•—", e); } finally { btn.innerText="æ›´æ–°"; btn.disabled=false; }
    }
    function handleModelSelectChange() {
        const s = document.getElementById('model-select');
        if(s.value==="CUSTOM") document.getElementById('custom-model-wrapper').classList.remove('hidden');
        else { document.getElementById('custom-model-wrapper').classList.add('hidden'); currentActiveModelId=s.value; }
        resetConversation();
    }
    function handleCustomInputChange() { currentActiveModelId = document.getElementById('custom-model-input').value.trim(); resetConversation(); }
    
    function saveSettings() {
        const p = document.getElementById('provider-select').value;
        const m = document.getElementById('model-select').value==="CUSTOM" ? document.getElementById('custom-model-input').value : document.getElementById('model-select').value;
        
        memoryPrompts[currentEditingMode] = document.getElementById('system-prompt').value;
        localStorage.setItem(`${p}_prompt`, memoryPrompts.chat);
        localStorage.setItem('custom_prompt_ocr', memoryPrompts.ocr);
        localStorage.setItem('custom_prompt_translate', memoryPrompts.translate);
        localStorage.setItem(`${p}_key`, document.getElementById('api-key').value.trim());
        localStorage.setItem(`${p}_model`, m); currentActiveModelId = m;
        localStorage.setItem('timeout_setting', document.getElementById('timeout-setting').value);
        localStorage.setItem('enter_to_send', document.getElementById('enter-to-send').checked);
        localStorage.setItem('openrouter_web_search', document.getElementById('openrouter-web-search').checked);
        saveVoiceSettings(); showTransientStatus("å·²å„²å­˜"); document.getElementById('settings-area').open = false;
    }

    function restoreDefaults() {
        const p = document.getElementById('provider-select').value; 
        memoryPrompts.chat = PROVIDERS[p].prompt;
        memoryPrompts.ocr = DEFAULT_OCR_PROMPT;
        memoryPrompts.translate = DEFAULT_TRANSLATE_PROMPT;
        localStorage.removeItem(`${p}_prompt`);
        localStorage.removeItem('custom_prompt_ocr');
        localStorage.removeItem('custom_prompt_translate');
        document.getElementById('system-prompt').value = memoryPrompts[currentEditingMode];
        localStorage.removeItem(`${p}_model`); 
        handleProviderChange(true); 
        showTransientStatus("å·²é‚„åŸé è¨­å€¼");
    }

    function copyResult() { navigator.clipboard.writeText(document.getElementById('chat-output').innerText).then(()=>showTransientStatus("å·²è¤‡è£½")); }
    function copyErrorLog() { navigator.clipboard.writeText(document.getElementById('error-log-area').value).then(()=>showTransientStatus("éŒ¯èª¤æ—¥èªŒå·²è¤‡è£½")); }
    
    function exportChat(fmt) {
        const c = document.getElementById('chat-output');
        const b = new Blob([fmt==='html'?`<html><body>${c.innerHTML}</body></html>`:c.innerText], {type:fmt==='html'?'text/html':'text/plain'});
        const a = document.createElement('a'); a.href = URL.createObjectURL(b); a.download = `export.${fmt}`; a.click();
    }
    function handleFileSelect(f) {
        if(f) { selectedFile=f; document.getElementById('upload-btn').innerText=`å·²é¸: ${f.name}`; showTransientStatus("å·²åŠ å…¥"); if(!document.getElementById('pause-send').checked) setTimeout(()=>document.querySelector('form').requestSubmit(), 500); }
    }
    function readFileAsBase64(f) { return new Promise((r,j)=>{const rd=new FileReader(); rd.onload=()=>r(rd.result.split(',')[1]); rd.onerror=j; rd.readAsDataURL(f);}); }

    async function handleSubmit(e) {
        e.preventDefault(); ensureAudioContext();
        const txt = document.getElementById('user-input').value.trim();
        if(!txt && !selectedFile) return showTransientStatus("è«‹è¼¸å…¥", 'error');
        
        playAudioCue('start'); updateStatusBar("è™•ç†ä¸­...", 'busy');
        const btn = document.getElementById('submit-btn'); btn.disabled=true;
        const ctl = new AbortController(); const tm = setTimeout(()=>ctl.abort(), document.getElementById('timeout-setting').value*1000);
        
        try {
            let input = txt; let fileData = null; let mime = null; let skipFile = false;
            if(selectedFile) {
                if(selectedFile.type==='application/pdf') {
                    // é€™è£¡æ”¹ç”¨å¹¾ä½•æå– + å…¨èƒ½é‡çµ„
                    const pdfText = await extractTextFromPDF_Geometric(selectedFile);
                    if(pdfText) { 
                        // **é—œéµæ­¥é©Ÿ**ï¼šé€²å…¥ Prompt å‰ç¢ºä¿å·²ç¶“æ­£è¦åŒ–
                        const cleanPdfText = UniversalTextNormalizer.normalize(pdfText);
                        input=`[PDF CONTENT]:\n${cleanPdfText}\n\n${txt}`; 
                        skipFile=true; 
                    }
                } else { 
                    fileData=await readFileAsBase64(selectedFile); mime=selectedFile.type; 
                }
            }
            
            const res = await callAI(document.getElementById('provider-select').value, input, skipFile?null:fileData, mime, ctl.signal, null, null, memoryPrompts.chat);
            document.getElementById('user-input').value=""; document.getElementById('upload-btn').innerText="é¸æ“‡æª”æ¡ˆ (Alt+Shift+U)"; selectedFile=null;
            addMessage('user', txt||"[æª”æ¡ˆ]"); 
            // AI å›æ‡‰ä¹Ÿé€²è¡Œæ¨™æº–åŒ–
            const ai = addMessage('assistant', UniversalTextNormalizer.normalize(res)); 
            setTimeout(() => { ai.focus(); }, 100);
            chatHistory.push({role:'user',content:input}); chatHistory.push({role:'assistant',content:res});
            playAudioCue('success'); showReadyStatus();
        } catch(e) { window.reportError("Submit Error", e); } finally { clearTimeout(tm); btn.disabled=false; }
    }

    async function callAI(p, txt, file, mime, sig, ovModel, ovKey, ovSystemPrompt) {
        const k = ovKey || document.getElementById('api-key').value; 
        const m = ovModel || currentActiveModelId;
        const sys = ovSystemPrompt || document.getElementById('system-prompt').value; 
        
        if(!k) throw new Error("éœ€ API Key");
        let body={}, url="", headers={'Content-Type':'application/json', 'Authorization':`Bearer ${k}`};
        
        const isMultiImage = Array.isArray(file);
        if (isMultiImage) { mime = "image/jpeg"; }

        if(p==='gemini') {
            url=`https://generativelanguage.googleapis.com/v1beta/models/${m}:generateContent?key=${k}`; delete headers['Authorization'];
            let parts = [];
            if (isMultiImage) {
                file.forEach(b64 => parts.push({inline_data:{mime_type:"image/jpeg", data:b64}}));
                parts.push({text:txt});
            } else {
                parts = file ? [{inline_data:{mime_type:mime, data:file}}, {text:txt}] : [{text:txt}];
            }
            body = { system_instruction:{parts:[{text:sys}]}, contents:[{role:"user", parts:parts}] };
        } else {
            if (p === 'openrouter') {
                url = "https://openrouter.ai/api/v1/chat/completions";
                headers['HTTP-Referer'] = 'https://ai-vision-helper.app'; // CORS requirement
                headers['X-Title'] = 'AI Vision Helper';
                if(document.getElementById('openrouter-web-search').checked) body.plugins = [{id:"web"}];
            } else if (p === 'mistral') {
                url = "https://api.mistral.ai/v1/chat/completions";
            } else if (p === 'perplexity') {
                url = "https://api.perplexity.ai/chat/completions";
            } else if (p === 'openai') {
                url = "https://api.openai.com/v1/chat/completions";
            } else {
                url = "https://api.groq.com/openai/v1/chat/completions";
            }

            let content = [];
            if (file) {
                content.push({type:"text", text:txt});
                content.push({type:"image_url", image_url:{url:`data:${mime};base64,${file}`}});
            } else {
                content = txt;
            }
            body = { ...body, model:m, messages:[{role:"system",content:sys}, {role:"user",content:content}], temperature:0.3 };
        }
        
        const r = await fetch(url, {method:'POST', headers, body:JSON.stringify(body), signal:sig});
        if(!r.ok) {
            const errText = await r.text();
            throw new Error(`API Error (${r.status}): ${errText}`);
        }
        const d = await r.json();
        let resText = p==='gemini' ? (d.candidates?.[0]?.content?.parts?.[0]?.text) : (d.choices?.[0]?.message?.content);
        
        if (!resText || resText.trim().length === 0) {
            throw new Error("AI å›æ‡‰ç‚ºç©ºã€‚å¯èƒ½åŸå› ï¼šæ¨¡å‹ä¸æ”¯æ´è¦–è¦ºè¼¸å…¥æˆ–å…§å®¹è¢«éæ¿¾ã€‚");
        }
        return resText;
    }
</script>
</body>
</html>