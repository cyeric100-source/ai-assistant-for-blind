--- START OF FILE index.html ---

<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI è¦–éšœåŠ©ç† (2025 Hybrid OCR ç‰ˆ)</title>
    
    <!-- å¼•å…¥ Marked.js è§£æ Markdown -->
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/lib/marked.umd.min.js"></script>
    
    <!-- å¼•å…¥ DOMPurify é€²è¡Œ HTML æ¶ˆæ¯’ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.8/purify.min.js"></script>

    <!-- ã€æ ¸å¿ƒè¨­å®šã€‘PDF.js v4.0.379 (ä½¿ç”¨ç©©å®šç‰ˆæœ¬) -->
    <script type="module">
        if (window.location.protocol === 'file:') {
            document.documentElement.innerHTML = `
                <body style="background:#000; color:#fff; display:flex; flex-direction:column; justify-content:center; align-items:center; height:100vh; margin:0; font-family:sans-serif;">
                    <h1 style="color:yellow; font-size:2.5rem; text-align:center;">âš ï¸ ç’°å¢ƒéŒ¯èª¤</h1>
                    <p style="font-size:1.5rem; text-align:center; max-width:800px; line-height:1.6;">
                        è«‹å°‡æ­¤å°ˆæ¡ˆä¸Šå‚³è‡³ <strong>GitHub</strong> ä¸¦é€é GitHub Pages é–‹å•Ÿã€‚
                    </p>
                </body>
            `;
            throw new Error("Local execution blocked.");
        }

        const PDF_BASE = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.0.379/pdf.min.mjs';
        const WORKER_URL = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.0.379/pdf.worker.min.mjs';

        async function initPdfSystem() {
            try {
                const pdfjsLib = await import(PDF_BASE);
                window.pdfjsLib = pdfjsLib;
                pdfjsLib.GlobalWorkerOptions.workerSrc = WORKER_URL;
                console.log("PDF System Initialized");
                window.dispatchEvent(new Event('pdfjs-loaded'));
            } catch (e) {
                console.error("PDF Init Failed:", e);
                window.reportError("PDF æ ¸å¿ƒè¼‰å…¥å¤±æ•— (CDN)", e);
                const btn = document.getElementById('pdf-start-btn');
                if (btn) {
                    btn.innerText = "âš ï¸ éŒ¯èª¤ï¼šPDF æ ¸å¿ƒå¤±æ•—";
                    btn.classList.add('danger');
                    btn.disabled = true;
                }
            }
        }
        initPdfSystem();
    </script>
    
    <style>
        :root {
            --bg-color: #000000;
            --text-color: #FFFFFF;
            --accent-color: #FFFF00;
            --user-header-color: #0088ff;
            --ai-header-color: #FFFF00;
            --border-color: #555;
            --input-bg: #1A1A1A;
            --button-bg: #FFFF00;
            --button-text: #000000;
            --status-bg: #222;
            --tool-bg: #112233;
            --nav-bg: #111;
            --nav-active-bg: #333;
        }

        /* å…¨å±€é‡ç½®èˆ‡ä½ˆå±€ */
        * { box-sizing: border-box; }
        
        body {
            font-family: system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0; padding: 0;
            font-size: 1.1rem; line-height: 1.5;
            height: 100dvh;
            display: grid;
            grid-template-rows: auto 1fr auto;
            overflow: hidden;
        }

        /* 1. é ‚éƒ¨ç‹€æ…‹åˆ— */
        header {
            background: var(--status-bg);
            border-bottom: 1px solid var(--border-color);
            z-index: 100;
            flex-shrink: 0;
        }

        #status-bar {
            padding: 8px; text-align: center; font-weight: bold;
            font-size: 1rem; color: #fff;
            transition: background-color 0.3s;
        }
        #status-bar.ready { background: #004400; }
        #status-bar.busy { background: #664400; }
        #status-bar.error { background: #660000; }
        #status-bar.recording { background: #aa0000; animation: pulse 1s infinite; }
        
        #visual-progress {
            background: #333; color: #88ccff; font-size: 0.85rem; 
            text-align: center; padding: 2px; display: none;
        }
        #visual-progress.active { display: block; }

        /* 2. ä¸»å…§å®¹å€åŸŸ (Tab Views) */
        main {
            position: relative;
            overflow: hidden;
            background: var(--bg-color);
        }

        .view-section {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            overflow-y: auto;
            padding: 15px;
            display: none;
            flex-direction: column;
        }

        .view-section.active {
            display: flex;
        }
        
        /* [Chat View] ç‰¹åˆ¥ä½ˆå±€ */
        #view-chat {
            padding: 0; 
        }
        #chat-container {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            padding-bottom: 20px;
        }
        #input-area-wrapper {
            flex-shrink: 0;
            background: #111;
            border-top: 1px solid var(--border-color);
            padding: 10px;
        }

        /* 3. åº•éƒ¨å°èˆªæ¬„ */
        .bottom-nav {
            background: var(--nav-bg);
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: space-around;
            align-items: center;
            height: 70px;
            flex-shrink: 0;
            z-index: 200;
        }

        .nav-btn {
            background: transparent; border: none;
            color: #888;
            font-size: 0.9rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            flex: 1;
            height: 100%;
            cursor: pointer;
            padding: 5px;
        }
        .nav-btn span.icon { font-size: 1.5rem; margin-bottom: 4px; display: block; }
        .nav-btn.active {
            color: var(--accent-color);
            background: var(--nav-active-bg);
            border-top: 3px solid var(--accent-color);
        }
        .nav-btn:focus-visible { outline: 3px solid var(--accent-color); box-shadow: inset 0 0 10px #fff; }

        /* é€šç”¨å…ƒä»¶æ¨£å¼ */
        h2 { 
            font-size: 1.3rem; color: #88ccff; border-bottom: 2px solid #333; 
            padding-bottom: 5px; margin-top: 0; margin-bottom: 15px;
        }
        h3 { color: #ccc; margin: 15px 0 10px 0; font-size: 1.1rem; }

        input, select, textarea {
            width: 100%; padding: 12px; margin-bottom: 15px;
            background: var(--input-bg); border: 1px solid var(--border-color);
            color: var(--text-color); font-size: 1.1rem; border-radius: 6px;
        }
        
        button.action-btn {
            width: 100%; padding: 14px; font-size: 1.1rem; font-weight: bold;
            border-radius: 8px; margin-bottom: 12px; cursor: pointer;
            background-color: var(--button-bg); color: var(--button-text); border: none;
        }
        button.secondary { background-color: #333; color: #fff; border: 1px solid #777; }
        button.danger { background-color: #550000; color: #ffcccc; border: 1px solid #ff4444; }
        button.high-contrast { background-color: #FFD700; color: #000; border: 2px solid #FFF; font-size: 1.2rem; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }

        /* OCR çµæœå€å°ˆç”¨æ¨£å¼ */
        #quick-ocr-output {
            background: #111; border: 2px solid #444; border-radius: 8px;
            padding: 15px; min-height: 100px; margin-top: 10px;
            white-space: pre-wrap; word-break: break-word;
        }
        #quick-ocr-output:focus { outline: 3px solid var(--accent-color); background: #222; }

        /* å°è©±æ°£æ³¡æ¨£å¼ */
        .message {
            background: #111; padding: 15px; margin-bottom: 20px;
            border-left: 5px solid var(--border-color);
            border-radius: 4px;
        }
        .message.user { border-left-color: var(--user-header-color); background: #0a0a1a; }
        .message.assistant { border-left-color: var(--ai-header-color); background: #1a1a0a; }
        .message h1.msg-heading { font-size: 1rem; color: #888; margin: 0 0 5px 0; border: none; }
        
        /* è¼¸å…¥å€æ¨£å¼ */
        .input-row { display: flex; gap: 8px; align-items: flex-end; }
        #user-input { min-height: 60px; max-height: 150px; margin-bottom: 0; resize: none; }
        #voice-btn { 
            width: 60px; height: 60px; border-radius: 50%; 
            display: flex; align-items: center; justify-content: center;
            font-size: 1.5rem; padding: 0; margin: 0;
            flex-shrink: 0;
        }
        #voice-btn.recording { background-color: #ff3333 !important; animation: pulse 1s infinite; }
        #submit-btn { width: 70px; height: 60px; margin: 0; flex-shrink: 0; padding: 5px; font-size: 1rem; }
        
        /* Utility Row & Checkbox */
        .utility-row { display: flex; gap: 10px; margin-bottom: 10px; overflow-x: auto; padding-bottom: 5px; align-items: center; }
        .utility-row button { white-space: nowrap; font-size: 0.9rem; padding: 8px 12px; margin: 0; width: auto; flex-shrink: 0; }

        /* æ¨™æº– Checkbox æ¨£å¼ (å°è©±é å°ˆç”¨) */
        .chat-check-btn {
            display: inline-flex; align-items: center;
            background: #333; border: 1px solid #777; color: #fff;
            padding: 8px 12px; border-radius: 6px;
            font-size: 0.9rem; cursor: pointer; white-space: nowrap;
            user-select: none;
        }
        .chat-check-btn input {
            width: 18px; height: 18px; margin: 0 8px 0 0;
            accent-color: var(--accent-color); /* å¼·èª¿è‰² */
        }
        /* å‹¾é¸æ™‚é«˜äº® */
        .chat-check-btn:has(input:checked) {
            border-color: var(--accent-color);
            background: #2a2a00;
        }

        /* è¨­å®šé æ¨£å¼ */
        .settings-card {
            background: #1a1a1a; padding: 15px; border-radius: 8px;
            border: 1px solid #333; margin-bottom: 20px;
        }
        
        .check-btn {
            display: flex; align-items: center; background: #222; padding: 10px;
            border-radius: 6px; margin-bottom: 10px; border: 1px solid #444;
        }
        .check-btn input { width: 25px; height: 25px; margin: 0 10px 0 0; }

        .hidden { display: none !important; }
        .visually-hidden { position: absolute; width: 1px; height: 1px; overflow: hidden; clip: rect(0,0,0,0); }
        
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }

        /* é›»è…¦ç‰ˆé©é…ï¼šå´é‚Šæ¬„ */
        @media (min-width: 768px) {
            body {
                grid-template-rows: auto 1fr;
                grid-template-columns: 200px 1fr;
            }
            header { grid-column: 1 / -1; }
            .bottom-nav {
                grid-row: 2; grid-column: 1;
                flex-direction: column; justify-content: flex-start;
                height: 100%; padding-top: 20px;
                border-top: none; border-right: 1px solid var(--border-color);
            }
            .nav-btn { height: auto; padding: 20px; width: 100%; border-top: none; border-left: 4px solid transparent; }
            .nav-btn.active { border-top: none; border-left-color: var(--accent-color); }
            main { grid-row: 2; grid-column: 2; }
        }
    </style>
</head>
<body>

    <!-- 1. é ‚éƒ¨ç‹€æ…‹ -->
    <header role="banner">
        <div id="status-bar" role="status" aria-live="polite">ç³»çµ±åˆå§‹åŒ–ä¸­...</div>
        <div id="visual-progress" aria-hidden="true"></div>
    </header>

    <!-- 2. ä¸»å…§å®¹å€ (åŒ…å«ä¸‰å€‹è¦–åœ–) -->
    <main>
        <!-- A. å°è©±è¦–åœ– (Chat View) -->
        <section id="view-chat" class="view-section active" role="tabpanel" aria-labelledby="tab-chat">
            <div id="chat-container">
                <div class="message assistant">
                    <h1 class="msg-heading">AI åŠ©ç†ï¼š</h1>
                    <div class="markdown-body">ä½ å¥½ï¼æˆ‘æ˜¯ä½ çš„ AI è¦–éšœåŠ©ç†ã€‚å·²å•Ÿç”¨å…¨åŠŸèƒ½å®‰å…¨ä»£ç† (æ”¯æ´å¤§å‹æª”æ¡ˆ)ã€‚è«‹è¼¸å…¥æ–‡å­—ã€ä¸Šå‚³åœ–ç‰‡/PDFï¼Œæˆ–ä½¿ç”¨èªéŸ³é€²è¡Œå°è©±ã€‚</div>
                </div>
                <div id="chat-output"></div>
            </div>

            <!-- è¼¸å…¥æ§åˆ¶å€ (å›ºå®šåœ¨å°è©±é åº•éƒ¨) -->
            <div id="input-area-wrapper">
                <div class="utility-row">
                    <!-- 1. æª”æ¡ˆä¸Šå‚³æŒ‰éˆ• -->
                    <button type="button" id="upload-btn" class="secondary" onclick="document.getElementById('file-input').click()">ğŸ“ æª”æ¡ˆ/æ‹ç…§</button>
                    
                    <!-- 2. æš«åœå‚³é€ Checkbox -->
                    <label class="chat-check-btn">
                        <input type="checkbox" id="pause-send">
                        <span>æš«åœç™¼é€</span>
                    </label>

                    <!-- 3. æ¸…é™¤æŒ‰éˆ• -->
                    <button type="button" id="new-chat-btn" class="danger" onclick="resetConversation()">ğŸ—‘ï¸ æ¸…é™¤</button>
                    
                    <!-- éš±è—çš„ File Input -->
                    <input type="file" id="file-input" class="visually-hidden" accept="*/*" onchange="handleFileSelect()">
                </div>
                
                <form onsubmit="handleSubmit(event)" class="input-row">
                    <button type="button" id="voice-btn" class="secondary" title="èªéŸ³è¼¸å…¥ (æŒ‰ä½ä¸æ”¾)" aria-label="èªéŸ³è¼¸å…¥">ğŸ¤</button>
                    <textarea id="user-input" placeholder="è¼¸å…¥è¨Šæ¯..." rows="1" aria-label="è¼¸å…¥è¨Šæ¯å€"></textarea>
                    <button type="submit" id="submit-btn" title="ç™¼é€">å‚³é€</button>
                </form>
            </div>
        </section>

        <!-- B. å·¥å…·è¦–åœ– (Tools View) -->
        <section id="view-tools" class="view-section" role="tabpanel" aria-labelledby="tab-tools">
            <h2 tabindex="-1" id="tools-title">å·¥å…·ç®± (Tools)</h2>
            
            <!-- æ–°å¢ï¼šå¿«é€Ÿ OCR åŠŸèƒ½å€å¡Š -->
            <div class="settings-card" style="border-color: var(--accent-color);">
                <h3>ğŸ“¸ å¿«é€Ÿæ–‡å­—è­˜åˆ¥ (Quick OCR)</h3>
                <input type="file" id="quick-ocr-input" class="visually-hidden" accept="image/*,application/pdf" onchange="handleQuickOCRFileSelect()">
                
                <button type="button" id="quick-ocr-btn" class="action-btn high-contrast" onclick="triggerQuickOCR()">
                    ğŸ“¸ æ‹æ” / å–å¾—æ–‡å­—
                </button>
                <p style="font-size:0.9rem; color:#aaa;">* æŒ‰ Alt + O å¿«é€Ÿå•Ÿå‹•ã€‚çµæœå°‡ç›´æ¥é¡¯ç¤ºæ–¼ä¸‹æ–¹ã€‚</p>
                
                <!-- çµæœé¡¯ç¤ºå€ï¼Œæ”¯æ´ç„¦é»å°èˆª -->
                <div id="quick-ocr-output" role="region" aria-label="æ–‡å­—è­˜åˆ¥çµæœ" tabindex="-1">
                    (ç­‰å¾…æ‹æ”...)
                </div>
            </div>

            <div class="settings-card">
                <h3>ğŸ“„ PDF æ™ºèƒ½æ··åˆé–±è®€ (Hybrid Reader)</h3>
                <p style="color:#aaa; font-size:0.9rem;">
                    2025 æ–°åŠŸèƒ½ï¼šçµåˆã€Œæ–‡å­—å±¤ã€èˆ‡ã€Œè¦–è¦º AIã€é€²è¡Œé€é æ ¡å°ã€‚
                    å³ä½¿è¶…é 100 é ä¹Ÿèƒ½å®Œæ•´è¼¸å‡ºä¸éºæ¼ã€‚
                </p>
                <input type="file" id="pdf-tool-input" class="visually-hidden" accept="application/pdf" onchange="handlePDFToolFileSelect()">
                
                <button type="button" id="pdf-start-btn" class="action-btn" onclick="document.getElementById('pdf-tool-input').click()" disabled>
                    é¸æ“‡ PDF æª”æ¡ˆä¸¦åˆ†æ
                </button>
                
                <div style="margin-top:10px;">
                    <label class="check-btn">
                        <input type="checkbox" id="pdf-translate"> <span>OCR å¾Œç¿»è­¯æˆç¹é«”ä¸­æ–‡</span>
                    </label>
                </div>
            </div>

            <div class="settings-card">
                <h3>ğŸ’¾ è³‡æ–™åŒ¯å‡º (Export)</h3>
                <button type="button" id="copy-btn" class="action-btn secondary hidden" onclick="copyResult()">è¤‡è£½å…¨éƒ¨å°è©±</button>
                <button type="button" id="export-txt-btn" class="action-btn secondary hidden" onclick="exportChat('txt')">åŒ¯å‡ºç‚º TXT</button>
                <button type="button" id="export-html-btn" class="action-btn secondary hidden" onclick="exportChat('html')">åŒ¯å‡ºç‚º HTML</button>
                <p style="color:#777; font-size:0.9rem;">* åŒ¯å‡ºæŒ‰éˆ•å°‡åœ¨æœ‰å°è©±å…§å®¹å¾Œé¡¯ç¤ºã€‚</p>
            </div>
        </section>

        <!-- C. è¨­å®šè¦–åœ– (Settings View) -->
        <section id="view-settings" class="view-section" role="tabpanel" aria-labelledby="tab-settings">
            <h2 tabindex="-1" id="settings-title">ç³»çµ±è¨­å®š (Settings)</h2>

            <div id="settings-area">
                <div class="settings-card">
                    <h3>ğŸ¤– AI æ¨¡å‹è¨­å®š</h3>
                    <div style="background: #442200; color: #ffcc88; padding: 8px; border-radius: 4px; margin-bottom: 10px; font-size: 0.9rem;">
                        âš ï¸ 2025 æç¤ºï¼šæ¨è–¦ä½¿ç”¨ Google Gemini æˆ– OpenRouterã€‚
                    </div>
                    
                    <label>ä¸»è¦æœå‹™å•†:</label>
                    <select id="provider-select" onchange="handleProviderChange(true)">
                        <option value="gemini">Google Gemini (æ¨è–¦)</option>
                        <option value="openrouter">OpenRouter (æ¨è–¦)</option>
                        <option value="datalab">Datalab (Chandra OCR)</option>
                        <option value="openai">OpenAI</option>
                        <option value="groq">Groq</option>
                        <option value="mistral">Mistral AI</option>
                        <option value="perplexity">Perplexity</option>
                    </select>

                    <label>API Key:</label>
                    <input type="password" id="api-key" placeholder="åœ¨æ­¤è²¼ä¸Šæ‚¨çš„ API Key" autocomplete="off">
                    
                    <label>æ¨¡å‹éæ¿¾:</label>
                    <input type="text" id="model-filter-input" placeholder="è¼¸å…¥é—œéµå­—ç¯©é¸..." oninput="handleModelFilter()">
                    
                    <label>é¸æ“‡æ¨¡å‹:</label>
                    <div style="display:flex; gap:10px;">
                        <select id="model-select" onchange="handleModelSelectChange()" style="margin-bottom:0;"></select>
                        <button type="button" id="refresh-btn" class="secondary" onclick="fetchOnlineModels()" style="width:auto; margin:0;">æ›´æ–°</button>
                    </div>
                    <div id="custom-model-wrapper" class="hidden" style="margin-top:10px;">
                        <input type="text" id="custom-model-input" placeholder="æ‰‹å‹•è¼¸å…¥æ¨¡å‹ ID" onchange="handleCustomInputChange()">
                    </div>
                </div>

                <div class="settings-card">
                    <h3>ğŸ› ï¸ ä»»å‹™åˆ†å·¥ (Task Assignment)</h3>
                    <div style="display:flex; flex-wrap:wrap; gap:10px;">
                        <button type="button" class="secondary" onclick="setSpecificConfig('ocr')" style="flex:1;">è¨­ç‚º OCR å°ˆç”¨</button>
                        <button type="button" class="secondary" onclick="setSpecificConfig('translate')" style="flex:1;">è¨­ç‚º ç¿»è­¯ å°ˆç”¨</button>
                        <button type="button" class="danger" onclick="clearSpecificConfigs()" style="flex:1;">é‡ç½®åˆ†å·¥</button>
                    </div>
                    <div id="config-status-display" aria-live="polite" style="margin-top:10px; color:#aaa; font-size:0.9rem;"></div>
                </div>

                <div class="settings-card">
                    <h3>ğŸ¤ èªéŸ³èˆ‡æ“ä½œ</h3>
                    <select id="voice-engine" onchange="saveVoiceSettings()">
                        <option value="browser">ç€è¦½å™¨åŸç”Ÿ (å…è²»)</option>
                        <option value="openai">OpenAI Whisper (ä»˜è²»)</option>
                        <option value="groq">Groq Whisper (å¿«é€Ÿ)</option>
                    </select>
                    <input type="password" id="voice-api-key" placeholder="èªéŸ³å°ˆç”¨ Key (é¸å¡«)" onchange="saveVoiceSettings()">
                    
                    <label class="check-btn">
                        <input type="checkbox" id="enter-to-send" checked> <span>æŒ‰ Enter éµå‚³é€</span>
                    </label>
                    <label class="check-btn" id="openrouter-settings" class="hidden">
                        <input type="checkbox" id="openrouter-web-search"> <span>å•Ÿç”¨è¯ç¶²æœå°‹ (OpenRouter)</span>
                    </label>
                    
                    <label>å›æ‡‰é€¾æ™‚ (ç§’):</label>
                    <input type="number" id="timeout-setting" value="120">
                </div>

                <div class="settings-card">
                    <h3>ğŸ“ ç³»çµ±æŒ‡ä»¤ (System Prompts)</h3>
                    <div class="utility-row">
                        <button type="button" id="tab-chat" class="secondary" onclick="switchPromptEditor('chat')">ä¸€èˆ¬å°è©±</button>
                        <button type="button" id="tab-ocr" class="secondary" onclick="switchPromptEditor('ocr')">OCR å°ˆç”¨</button>
                        <button type="button" id="tab-translate" class="secondary" onclick="switchPromptEditor('translate')">ç¿»è­¯å°ˆç”¨</button>
                    </div>
                    <textarea id="system-prompt" rows="5" placeholder="åœ¨æ­¤è¼¸å…¥ç³»çµ±æŒ‡ä»¤..."></textarea>
                </div>

                <div class="settings-card" style="border-color: #550000;">
                    <h3>ğŸ› éŒ¯èª¤æ—¥èªŒ (Debug)</h3>
                    <textarea id="error-log-area" readonly rows="5" placeholder="ç„¡éŒ¯èª¤"></textarea>
                    <button type="button" class="secondary" onclick="copyErrorLog()">è¤‡è£½æ—¥èªŒ</button>
                </div>

                <button type="button" class="action-btn" onclick="saveSettings()">å„²å­˜æ‰€æœ‰è¨­å®š</button>
                <button type="button" class="action-btn secondary" onclick="restoreDefaults()">æ¢å¾©é è¨­å€¼</button>
            </div>
        </section>
    </main>

    <!-- 3. åº•éƒ¨å°èˆªæ¬„ -->
    <nav class="bottom-nav" role="tablist">
        <button type="button" class="nav-btn active" id="nav-chat" role="tab" aria-selected="true" aria-controls="view-chat" onclick="switchTab('chat')">
            <span class="icon">ğŸ’¬</span>
            <span>å°è©±</span>
        </button>
        <button type="button" class="nav-btn" id="nav-tools" role="tab" aria-selected="false" aria-controls="view-tools" onclick="switchTab('tools')">
            <span class="icon">ğŸ› ï¸</span>
            <span>å·¥å…·</span>
        </button>
        <button type="button" class="nav-btn" id="nav-settings" role="tab" aria-selected="false" aria-controls="view-settings" onclick="switchTab('settings')">
            <span class="icon">âš™ï¸</span>
            <span>è¨­å®š</span>
        </button>
    </nav>

    <script>
        // --- æ ¸å¿ƒè®Šæ•¸ï¼šCloudflare Worker ä»£ç† ---
        const USER_WORKER_URL = "https://ai-helper-for-blind.cyeric20.workers.dev/";

        // --- å…¨åŸŸè®Šæ•¸ï¼šé»æ€§è¨˜æ†¶ã€æ­·å²ç´€éŒ„ã€ä¸Šä¸€å€‹åˆ†é  ---
        let stickyMemory = { type: null, content: null, mime: null, count: 0 };
        let lastActiveTabId = 'chat'; 
        
        // --- æ ¸å¿ƒ 1: åˆ†é åˆ‡æ›é‚è¼¯ ---
        function switchTab(tabId) {
            document.querySelectorAll('.view-section').forEach(el => el.classList.remove('active'));
            document.querySelectorAll('.nav-btn').forEach(el => {
                el.classList.remove('active');
                el.setAttribute('aria-selected', 'false');
            });

            const targetView = document.getElementById(`view-${tabId}`);
            const targetNav = document.getElementById(`nav-${tabId}`);
            
            if (targetView && targetNav) {
                targetView.classList.add('active');
                targetNav.classList.add('active');
                targetNav.setAttribute('aria-selected', 'true');
                if (tabId === 'chat') document.getElementById('user-input').focus();
                else { const title = document.getElementById(`${tabId}-title`); if (title) title.focus(); }
            }
            
            if (tabId !== 'settings') {
                lastActiveTabId = tabId;
            }
        }

        // --- æ ¸å¿ƒ 2: åŸå§‹èˆ‡æ–°å¢é‚è¼¯ ---
        
        class UniversalTextNormalizer {
            static getScriptType(char) {
                if (!char) return 'other';
                const code = char.charCodeAt(0);
                if ((code >= 0x4E00 && code <= 0x9FFF) || (code >= 0x3040 && code <= 0x30FF) || (code >= 0xAC00 && code <= 0xD7AF)) return 'cjk';
                if ((code >= 0x0E00 && code <= 0x0E7F) || (code >= 0x1780 && code <= 0x17FF)) return 'sea';
                if ((code >= 0x0600 && code <= 0x06FF) || (code >= 0x0590 && code <= 0x05FF)) return 'rtl';
                if ((code >= 0x0041 && code <= 0x005A) || (code >= 0x0061 && code <= 0x007A) || (code >= 0x0030 && code <= 0x0039) || (code >= 0x00C0 && code <= 0x024F)) return 'latin';
                return 'other';
            }
            static normalize(text) {
                if (!text) return "";
                let res = text.replace(/\r\n/g, "\n").replace(/\r/g, "\n").replace(/([a-zA-Z])-\n([a-zA-Z])/g, "$1$2");
                const lines = res.split("\n");
                let processed = "";
                for (let i = 0; i < lines.length; i++) {
                    let curr = lines[i].trim();
                    if (curr.length === 0) { processed += "\n\n"; continue; }
                    if (i < lines.length - 1) {
                        let next = lines[i + 1].trim();
                        if (next.length === 0) { processed += curr + "\n"; continue; }
                        let lastChar = curr.slice(-1);
                        let nextChar = next.charAt(0);
                        const typeA = this.getScriptType(lastChar);
                        const typeB = this.getScriptType(nextChar);
                        if ((typeA === 'cjk' || typeA === 'sea') && (typeB === 'cjk' || typeB === 'sea')) processed += curr; 
                        else if ((typeA === 'cjk' && typeB === 'latin') || (typeA === 'latin' && typeB === 'cjk')) processed += curr;
                        else if (/^[-*â€¢]/.test(next) || /^[-*â€¢]/.test(curr)) processed += curr + "\n";
                        else processed += curr + " ";
                    } else { processed += curr; }
                }
                processed = processed.replace(/([\u2e80-\u9fff])\s+([\u2e80-\u9fff])/g, "$1$2");
                processed = processed.replace(/([\u2e80-\u9fff])\s+([a-zA-Z0-9])/g, "$1$2");
                processed = processed.replace(/([a-zA-Z0-9])\s+([\u2e80-\u9fff])/g, "$1$2");
                return processed.replace(/\n{3,}/g, "\n\n").trim();
            }
        }

        window.reportError = function(msg, errObj) {
            const time = new Date().toLocaleTimeString();
            const errText = errObj ? (errObj.stack || errObj.message || JSON.stringify(errObj)) : "N/A";
            const logArea = document.getElementById('error-log-area');
            if (logArea) logArea.value += `[${time}] ${msg}\n${errText}\n----------------\n`;
            console.error(msg, errObj);
            updateStatusBar(`éŒ¯èª¤: ${msg}`, 'error');
            playAudioCue('error');
        };

        window.addEventListener('pdfjs-loaded', () => {
            const btn = document.getElementById('pdf-start-btn');
            if (btn) {
                btn.innerText = "ğŸ“„ é¸æ“‡ PDF æª”æ¡ˆä¸¦åˆ†æ";
                btn.disabled = false;
            }
            showReadyStatus();
        });

        const DEFAULT_CHAT_PROMPT = `# Persona
You are a top-tier AI visual and information assistant dedicated to serving visually impaired individuals. Your core duty is to act as an extension of the user's eyes and brain, providing information that is safe, precise, and easy to receive via Screen Reader software.

# Global Rules
Regardless of the task, you must strictly adhere to the following three major principles:

1. **Language Standards**:
   - **Sole Output Language**: Traditional Chinese (Hong Kong style vocabulary).
   - **Translation Requirement**: If the source data is in a foreign language, you must digest and translate it into fluent Chinese. It is **strictly prohibited** to display the original text in the output (unless the user specifically requests a comparison).

2. **Accessibility Format**:
   - **Markdown Structure**: You must utilize \`#\` (headings) and \`-\` (lists) to establish a clear hierarchy, facilitating navigation by screen readers.
   - **Symbol Ban**: It is **strictly prohibited** to output \`[ ]\` (square brackets) or \`{ }\` (curly braces) or any decorative symbols that might interfere with the reading rhythm. When citing sources, state them directly in the narrative; do not use notations like \`[1]\`.

3. **Content Style**:
   - Provided the information is rich, the text must be concise and refined, avoiding redundancy. The main points must be placed at the very beginning.`;

        const DEFAULT_OCR_PROMPT = `# SYSTEM ROLE
You are a high-precision Hybrid OCR Engine. You will receive TWO inputs for each page:
1. An **Image** of the PDF page (Visual Layer).
2. The **Raw Text** extracted from the PDF (Text Layer).

# PRIMARY TASK
Combine the visual information and the raw text to produce a **Perfect Markdown** representation of the page.

# EXECUTION RULES
1. **Verbatim Accuracy**:
   - Use the "Raw Text" as the primary source for characters to ensure 100% spelling accuracy.
   - Use the "Image" to correct any encoding errors, garbled text, or layout issues in the Raw Text.
   - **DO NOT** summarize. **DO NOT** omit. Output every single word.

2. **Structure & Formatting**:
   - Use Markdown to replicate the visual structure.
   - **Headings**: Use #, ##, ### based on font size in the Image.
   - **Tables**: Reconstruct tables using Markdown syntax (\`| col | col |\`).
   - **Lists**: Use standard bullets (-) or numbers (1.).

3. **Fallback**:
   - If the Raw Text is empty or garbage, rely 100% on the Image (Visual OCR).

# OUTPUT
Directly output the final Markdown content for this page. No conversational filler.`;
        
        const DEFAULT_TRANSLATE_PROMPT = `# ROLE
You are a world-class Translator and Terminologist fluent in all major languages, specializing in "Traditional Chinese (Hong Kong variant)". Your work is defined by three core principles: Faithfulness (ä¿¡), Expressiveness (é”), and Elegance (é›…).

# TASK
Translate the provided input text into high-quality **Traditional Chinese (Hong Kong)**.

# STRICT GUIDELINES (Must Follow)
1. **NO Summarization**: Translate every single sentence. Do not omit any details, technical terms, or explanations.
2. **Localization (Hong Kong Style)**:
   - Use HK-specific vocabulary (e.g., "Smart phone" -> æ™ºèƒ½é›»è©±, "Project" -> å°ˆæ¡ˆ/é …ç›®, "Quality" -> è³ªç´ , "Software" -> è»Ÿä»¶).
   - Avoid Mainland Chinese or Taiwanese idioms unless they are standard in HK professional contexts.
3. **Formatting**: Preserve the original Markdown structure (headings, bullets, links).
4. **No Filler**: Do not output "Here is the translation" or explanations. Just output the translation.

# OUTPUT
Directly provide the final, polished Traditional Chinese translation.`;
        
        const PROMPT_VERSION_KEY = "prompt_ver_2025_release_v7_hybrid";

        const PROVIDERS = {
            gemini: { prompt: DEFAULT_CHAT_PROMPT, defaultModel: "gemini-flash-latest", canFetch: true, listUrl: "https://generativelanguage.googleapis.com/v1beta/models?key={KEY}", models: ["gemini-flash-latest", "gemini-2.0-flash-exp", "gemini-1.5-pro", "gemini-1.5-flash"] },
            openrouter: { prompt: DEFAULT_CHAT_PROMPT, defaultModel: "google/gemini-2.0-flash-exp:free", canFetch: true, listUrl: "https://openrouter.ai/api/v1/models", models: ["google/gemini-2.0-flash-exp:free", "openai/gpt-4o", "anthropic/claude-3.5-sonnet"] },
            datalab: { prompt: DEFAULT_OCR_PROMPT, defaultModel: "chandra", canFetch: false, listUrl: "", models: ["chandra"] },
            mistral: { prompt: DEFAULT_CHAT_PROMPT, defaultModel: "mistral-large-latest", canFetch: true, listUrl: "https://api.mistral.ai/v1/models", models: ["mistral-large-latest"] },
            openai: { prompt: DEFAULT_CHAT_PROMPT, defaultModel: "gpt-4o", canFetch: true, listUrl: "https://api.openai.com/v1/models", models: ["gpt-4o"] },
            groq: { prompt: DEFAULT_CHAT_PROMPT, defaultModel: "llama-3.3-70b-versatile", canFetch: true, listUrl: "https://api.groq.com/openai/v1/models", models: ["llama-3.3-70b-versatile"] },
            perplexity: { prompt: DEFAULT_CHAT_PROMPT, defaultModel: "sonar-pro", canFetch: false, models: ["sonar-pro"] }
        };

        let currentActiveModelId = "";
        let selectedFile = null;
        let recognition = null; 
        let mediaRecorder = null;
        let audioChunks = [];
        let chatHistory = [];
        let audioContext = null;
        let allCurrentModels = [];
        let isVoiceRecording = false;
        let specificConfigs = { ocr: null, translate: null };
        let memoryPrompts = { chat: "", ocr: "", translate: "" };
        let currentEditingMode = 'chat'; 

        const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        function ensureAudioContext() {
            if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
            if (audioContext.state === 'suspended') audioContext.resume().catch(e => console.error(e));
        }

        ['click', 'touchstart', 'keydown'].forEach(evt => {
            document.addEventListener(evt, ensureAudioContext, { once: false, passive: true });
        });
        
        document.addEventListener('keydown', handleGlobalShortcuts);

        function initVoiceButtonEvents() {
            const btn = document.getElementById('voice-btn');
            if (!btn) return;
            btn.addEventListener('touchstart', (e) => { e.preventDefault(); ensureAudioContext(); startVoiceRecording(); }, {passive: false});
            btn.addEventListener('touchend', (e) => { e.preventDefault(); stopVoiceRecording(); });
            btn.addEventListener('mousedown', (e) => { ensureAudioContext(); startVoiceRecording(); });
            btn.addEventListener('mouseup', (e) => { stopVoiceRecording(); });
            btn.addEventListener('mouseleave', (e) => { if(isVoiceRecording) stopVoiceRecording(); });
            btn.addEventListener('contextmenu', (e) => e.preventDefault());
        }

        function handleGlobalShortcuts(e) {
            if (!e.altKey || !e.shiftKey) return;
            const key = e.key.toLowerCase();
            
            if (key === 'o') { e.preventDefault(); triggerQuickOCR(); return; }

            if (key === 'v') { e.preventDefault(); ensureAudioContext(); isVoiceRecording ? stopVoiceRecording() : startVoiceRecording(); return; }
            const actions = {
                's': () => switchTab('settings'),
                'c': { id: 'copy-btn' },
                't': { id: 'export-txt-btn' },
                'h': { id: 'export-html-btn' },
                'u': { id: 'upload-btn' },
                'n': { id: 'new-chat-btn' },
                'k': { id: 'submit-btn' },
                'i': { id: 'user-input', type: 'focus' },
                '1': () => switchTab('chat'),
                '2': () => switchTab('tools'),
                '3': () => switchTab('settings')
            };
            if (actions[key]) {
                e.preventDefault(); ensureAudioContext();
                if (typeof actions[key] === 'function') actions[key]();
                else {
                    const target = document.getElementById(actions[key].id);
                    if (target) { if (actions[key].type === 'focus') target.focus(); else target.click(); }
                }
            }
        }

        document.addEventListener('DOMContentLoaded', async () => {
            try {
                if (!localStorage.getItem(PROMPT_VERSION_KEY)) {
                    ['gemini', 'openrouter', 'openai', 'groq', 'perplexity', 'mistral'].forEach(p => localStorage.removeItem(`${p}_prompt`));
                    localStorage.setItem(PROMPT_VERSION_KEY, 'true');
                }
                const savedProvider = localStorage.getItem('provider');
                const savedTimeout = localStorage.getItem('timeout_setting');
                if (savedTimeout) document.getElementById('timeout-setting').value = savedTimeout;
                
                const orSearch = document.getElementById('openrouter-web-search');
                if(orSearch) orSearch.checked = (localStorage.getItem('openrouter_web_search') === 'true');
                
                const savedVoiceEngine = localStorage.getItem('voice_engine');
                if (savedVoiceEngine) document.getElementById('voice-engine').value = savedVoiceEngine;
                const savedVoiceKey = localStorage.getItem('voice_api_key');
                if (savedVoiceKey) document.getElementById('voice-api-key').value = savedVoiceKey;
                const savedEnter = localStorage.getItem('enter_to_send');
                document.getElementById('enter-to-send').checked = (savedEnter === null || savedEnter === 'true');

                const savedSpecifics = localStorage.getItem('specific_configs');
                if (savedSpecifics) { specificConfigs = JSON.parse(savedSpecifics); }
                updateConfigStatusDisplay();

                memoryPrompts.ocr = localStorage.getItem('custom_prompt_ocr') || DEFAULT_OCR_PROMPT;
                memoryPrompts.translate = localStorage.getItem('custom_prompt_translate') || DEFAULT_TRANSLATE_PROMPT;

                if (savedProvider && PROVIDERS[savedProvider]) {
                    document.getElementById('provider-select').value = savedProvider;
                } else {
                    document.getElementById('provider-select').value = 'gemini'; 
                }
                
                handleProviderChange(false); 
                initVoiceSystem();
                initPasteImage();
                initDragAndDrop();
                initEnterKey();
                initVoiceButtonEvents();
                
                const pauseToggle = document.getElementById('pause-send');
                if(pauseToggle) pauseToggle.checked = false;

                const hasKey = document.getElementById('api-key').value.trim().length > 0;
                if (!hasKey) {
                    switchTab('settings');
                    showTransientStatus('è«‹å…ˆè¨­å®š API Key', 'error');
                } else {
                    switchTab('chat');
                }

            } catch (e) { window.reportError("Init Error", e); }
        });

        function triggerQuickOCR() {
            switchTab('tools');
            document.getElementById('quick-ocr-input').click();
        }

        async function handleQuickOCRFileSelect() {
            const input = document.getElementById('quick-ocr-input');
            const file = input.files[0];
            if (!file) return;
            
            const outputDiv = document.getElementById('quick-ocr-output');
            outputDiv.innerHTML = '<p>åˆ†æä¸­ï¼Œè«‹ç¨å€™...</p>';
            outputDiv.focus(); 
            
            updateStatusBar("æ­£åœ¨è­˜åˆ¥æ–‡å­— (OCR)...", "busy");
            playAudioCue('start');

            try {
                let fileData = await readFileAsBase64(file);
                
                const res = await callAI(
                    document.getElementById('provider-select').value,
                    DEFAULT_OCR_PROMPT, 
                    [], 
                    "", 
                    fileData,
                    file.type, 
                    null 
                );
                
                const safeHTML = DOMPurify.sanitize(marked.parse(res));
                outputDiv.innerHTML = safeHTML;
                
                playAudioCue('success');
                outputDiv.focus();
                updateStatusBar("è­˜åˆ¥å®Œæˆ");
                
            } catch (e) {
                window.reportError("Quick OCR Failed", e);
                outputDiv.innerHTML = `<p style="color:#ff5555; font-weight:bold;">âš ï¸ è­˜åˆ¥å¤±æ•—ï¼š${e.message}</p>`;
                outputDiv.focus();
            }
            input.value = '';
        }

        function switchPromptEditor(mode) {
            const textarea = document.getElementById('system-prompt');
            memoryPrompts[currentEditingMode] = textarea.value;
            currentEditingMode = mode;
            textarea.value = memoryPrompts[mode];
            document.getElementById('tab-chat').classList.toggle('secondary', mode !== 'chat');
            document.getElementById('tab-ocr').classList.toggle('secondary', mode !== 'ocr');
            document.getElementById('tab-translate').classList.toggle('secondary', mode !== 'translate');
            document.getElementById('tab-chat').classList.toggle('active', mode === 'chat'); 
        }

        function setSpecificConfig(type) {
            const provider = document.getElementById('provider-select').value;
            const model = currentActiveModelId;
            specificConfigs[type] = { provider, model };
            localStorage.setItem('specific_configs', JSON.stringify(specificConfigs));
            const currentKey = document.getElementById('api-key').value;
            if (currentKey) localStorage.setItem(`${provider}_key`, currentKey.trim());
            updateConfigStatusDisplay();
            showTransientStatus(`å·²è¨­å®š ${type} å°ˆç”¨æ¨¡å‹`);
        }

        function clearSpecificConfigs() {
            specificConfigs = { ocr: null, translate: null };
            localStorage.removeItem('specific_configs');
            updateConfigStatusDisplay();
            showTransientStatus("å·²é‡ç½®åˆ†å·¥è¨­å®š");
        }

        function updateConfigStatusDisplay() {
            const display = document.getElementById('config-status-display');
            let html = "";
            html += specificConfigs.ocr ? `â€¢ OCR: ${specificConfigs.ocr.provider} / ${specificConfigs.ocr.model}<br>` : "";
            html += specificConfigs.translate ? `â€¢ ç¿»è­¯: ${specificConfigs.translate.provider} / ${specificConfigs.translate.model}` : "";
            display.innerHTML = html || "ç›®å‰è·Ÿéš¨ä¸»è¦è¨­å®š";
        }

        function playAudioCue(type) {
            if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            const now = audioContext.currentTime;
            
            if (type === 'start') { 
                oscillator.type = 'sine'; oscillator.frequency.setValueAtTime(880, now); gainNode.gain.setValueAtTime(0.1, now); oscillator.start(now); oscillator.stop(now + 0.1); 
            } else if (type === 'success') { 
                oscillator.type = 'sine'; oscillator.frequency.setValueAtTime(440, now); oscillator.frequency.exponentialRampToValueAtTime(880, now + 0.15); gainNode.gain.setValueAtTime(0.1, now); oscillator.start(now); oscillator.stop(now + 0.2); 
            } else if (type === 'error') { 
                oscillator.type = 'sawtooth'; oscillator.frequency.setValueAtTime(150, now); gainNode.gain.setValueAtTime(0.15, now); oscillator.start(now); oscillator.stop(now + 0.4); 
            } else if (type === 'abort') {
                oscillator.type = 'triangle'; oscillator.frequency.setValueAtTime(400, now); oscillator.frequency.linearRampToValueAtTime(200, now + 0.1); gainNode.gain.setValueAtTime(0.1, now); oscillator.start(now); oscillator.stop(now + 0.1);
            }
        }

        function resetConversation() {
            chatHistory = []; 
            stickyMemory = { type: null, content: null, mime: null, count: 0 };
            document.getElementById('chat-output').innerHTML = ""; 
            document.getElementById('user-input').value = "";
            selectedFile = null;
            document.getElementById('upload-btn').innerText = "ğŸ“ æª”æ¡ˆ/æ‹ç…§";
            document.getElementById('upload-btn').classList.remove('active');
            document.getElementById('file-input').value = "";
            toggleExportButtons(false);
            showTransientStatus("å°è©±èˆ‡è¨˜æ†¶å·²æ¸…é™¤");
        }

        function handlePDFToolFileSelect() {
            const input = document.getElementById('pdf-tool-input');
            if (input.files.length > 0) {
                processPDFTool(input.files[0]);
            }
            input.value = ""; 
        }
        
        function isCanvasBlank(canvas) {
            try {
                const ctx = canvas.getContext('2d', { willReadFrequently: true });
                const imageData = ctx.getImageData(canvas.width/2 - 25, canvas.height/2 - 25, 50, 50);
                const data = imageData.data;
                for(let i = 0; i < data.length; i += 4) {
                    if (data[i+3] > 0 && (data[i] < 250 || data[i+1] < 250 || data[i+2] < 250)) return false; 
                }
                return true;
            } catch(e) { return false; }
        }

        async function processPDFTool(file) {
            if (typeof window.pdfjsLib === 'undefined') { alert("PDF æ ¸å¿ƒè¼‰å…¥ä¸­..."); return; }
            if (!file || file.type !== 'application/pdf') { alert("è«‹é¸æ“‡ PDF"); return; }
            
            resetConversation(); playAudioCue('start');
            switchTab('chat');
            
            const needTranslate = document.getElementById('pdf-translate').checked;

            try {
                updateStatusBar("æ­£åœ¨åˆå§‹åŒ–æ··åˆé–±è®€æ¨¡å¼...", "busy");
                // æ”¹ç‚ºå…¨æ–°çš„æ··åˆè™•ç†æ¨¡å¼
                await performHybridAIProcessing(file, needTranslate);

            } catch (e) { window.reportError("PDF Process Failed", e); }
        }

        async function performHybridAIProcessing(file, needTranslate) {
            const controller = new AbortController(); 
            let ocrProvider = specificConfigs.ocr ? specificConfigs.ocr.provider : document.getElementById('provider-select').value;
            let ocrModel = specificConfigs.ocr ? specificConfigs.ocr.model : currentActiveModelId;
            let ocrApiKey = (ocrProvider === document.getElementById('provider-select').value) ? document.getElementById('api-key').value : localStorage.getItem(`${ocrProvider}_key`);
            
            if (!ocrApiKey) throw new Error(`ç¼ºå°‘ ${ocrProvider} Key`);

            // å¦‚æœä½¿ç”¨è€…é¸äº† Datalab (Chandra)ï¼Œä½¿ç”¨å…¶å°ˆå±¬çš„ Whole-File OCR
            if (ocrProvider === 'datalab') {
                 updateStatusBar("ä¸Šå‚³æ•´ä»½æ–‡ä»¶è‡³ Chandra OCR...", "busy");
                 let fileData = await readFileAsBase64(file);
                 let fullText = await callAI('datalab', DEFAULT_OCR_PROMPT, [], "", fileData, "application/pdf", controller.signal, 'chandra', ocrApiKey);
                 const aiMsg = addMessage('assistant', UniversalTextNormalizer.normalize(fullText));
                 setTimeout(() => aiMsg.focus(), 100);
                 updateStatusBar("å®Œæˆ");
                 playAudioCue('success');
                 return;
            }

            // ä¸€èˆ¬ AI (Gemini/OpenAI): æ¡ç”¨é€é æ··åˆæ¨¡å¼
            const arrayBuffer = await file.arrayBuffer();
            const pdf = await window.pdfjsLib.getDocument({ data: arrayBuffer, cMapUrl: 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.0.379/cmaps/', cMapPacked: true }).promise;
            
            updateVisualProgress(true, `æº–å‚™è™•ç† ${pdf.numPages} é ...`);
            
            // å»ºç«‹ä¸€å€‹å³æ™‚é¡¯ç¤ºå®¹å™¨ï¼Œå› ç‚ºæˆ‘å€‘è¦ä¸²æµé¡¯ç¤ºæ¯ä¸€é 
            const containerDiv = document.createElement('div');
            containerDiv.className = `message assistant`;
            containerDiv.innerHTML = `<h1 class="msg-heading">AI åŠ©ç† (å³æ™‚è™•ç†ä¸­)ï¼š</h1><div class="markdown-body" id="streaming-output"></div>`;
            document.getElementById('chat-output').appendChild(containerDiv);
            const outputArea = containerDiv.querySelector('#streaming-output');
            toggleExportButtons(true);

            let fullAccumulatedText = "";

            for (let i = 1; i <= pdf.numPages; i++) {
                updateStatusBar(`æ­£åœ¨è™•ç†ç¬¬ ${i} / ${pdf.numPages} é ...`, "busy");
                document.getElementById('visual-progress').innerText = `Page ${i} / ${pdf.numPages}`;

                // 1. å–å¾— Text Layer (æ–‡å­—æç¤º)
                const page = await pdf.getPage(i);
                let textLayerContent = "";
                try {
                    const textContent = await page.getTextContent();
                    textLayerContent = textContent.items.map(item => item.str).join(" ");
                } catch (e) { console.warn(`Page ${i} text extraction failed`, e); }

                // 2. å–å¾— Visual Layer (åœ–ç‰‡)
                const viewportRaw = page.getViewport({ scale: 1.0 });
                const scale = Math.min(1536 / Math.max(viewportRaw.width, viewportRaw.height), 2.0);
                const canvas = document.createElement('canvas');
                canvas.width = page.getViewport({ scale }).width; 
                canvas.height = page.getViewport({ scale }).height;
                await page.render({ canvasContext: canvas.getContext('2d'), viewport: page.getViewport({ scale }) }).promise;
                
                if (isCanvasBlank(canvas)) {
                    // ç©ºç™½é è·³é
                    canvas.remove();
                    continue;
                }
                const imgBase64 = canvas.toDataURL('image/jpeg', 0.6).split(',')[1];
                canvas.remove();

                // 3. æ§‹å»ºæ··åˆ Prompt
                let pagePrompt = `[Page ${i}]\n`;
                if (textLayerContent && textLayerContent.length > 10) {
                    pagePrompt += `Here is the raw text extracted from this page via software. It may have layout errors but the spelling is mostly correct. Use it as a ground truth reference:\n"""\n${textLayerContent.substring(0, 8000)}\n"""\n\n`;
                } else {
                    pagePrompt += `No raw text available for this page. Rely solely on visual OCR.\n`;
                }

                // 4. å‘¼å« AI (å–®é è™•ç†)
                // æ³¨æ„ï¼šå¦‚æœéœ€è¦ç¿»è­¯ï¼Œç›´æ¥åœ¨ Prompt è£¡è¦æ±‚ç¿»è­¯ï¼Œæˆ–è€…å…ˆ OCR å†ç¿»è­¯ã€‚
                // ç‚ºäº†æ•ˆç‡ï¼Œè‹¥å‹¾é¸ç¿»è­¯ï¼Œæˆ‘å€‘ä¿®æ”¹ System Prompt è®“å®ƒç›´æ¥è¼¸å‡ºä¸­æ–‡ã€‚
                let currentSystemPrompt = memoryPrompts.ocr;
                if (needTranslate) {
                    currentSystemPrompt += "\n\nIMPORTANT: After extraction, TRANSLATE the content into Traditional Chinese (Hong Kong) immediately.";
                }

                try {
                    let pageResult = await callAI(ocrProvider, currentSystemPrompt, [], pagePrompt, imgBase64, "image/jpeg", controller.signal, ocrModel, ocrApiKey);
                    
                    // æ ¼å¼åŒ–è¼¸å‡º
                    let cleanResult = UniversalTextNormalizer.normalize(pageResult);
                    fullAccumulatedText += `## [ç¬¬ ${i} é ]\n\n${cleanResult}\n\n---\n\n`;
                    
                    // å³æ™‚æ¸²æŸ“ Markdown åˆ°ç•«é¢ä¸Š
                    outputArea.innerHTML = DOMPurify.sanitize(marked.parse(fullAccumulatedText));
                    
                    // æ»¾å‹•åˆ°åº•éƒ¨
                    // containerDiv.scrollIntoView({ behavior: "smooth", block: "end" });

                } catch (e) {
                    console.error(`Page ${i} AI Error:`, e);
                    fullAccumulatedText += `## [ç¬¬ ${i} é ]\n\n(æ­¤é è™•ç†å¤±æ•—: ${e.message})\n\n---\n\n`;
                    outputArea.innerHTML = DOMPurify.sanitize(marked.parse(fullAccumulatedText));
                }

                // é¿å… Rate Limitï¼Œç¨å¾®æš«åœ
                await sleep(500);
            }

            updateVisualProgress(false);
            updateStatusBar("æ–‡ä»¶è™•ç†å®Œæˆ");
            playAudioCue('success');
            containerDiv.focus();
        }

        function updateVisualProgress(show, text="") {
            const el = document.getElementById('visual-progress');
            if (show) { el.classList.add('active'); el.innerText = text; } 
            else { el.classList.remove('active'); el.innerText = ""; }
        }

        // ä¿ç•™èˆŠçš„æå–å‡½å¼ä½œç‚ºå‚™ç”¨æˆ–æ¯”å°
        async function extractTextFromPDF_Accurate(file) {
            try {
                const arrayBuffer = await file.arrayBuffer();
                const pdf = await window.pdfjsLib.getDocument({ data: arrayBuffer, cMapUrl: 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.0.379/cmaps/', cMapPacked: true }).promise;
                let fullText = "";
                for (let i = 1; i <= pdf.numPages; i++) {
                    const content = await pdf.getPage(i).then(p => p.getTextContent());
                    const strings = content.items.map(item => item.str);
                    fullText += `[Page ${i}]\n${strings.join(" ")}\n\n`;
                }
                return fullText;
            } catch (e) { return null; }
        }

        function initVoiceSystem() {
            const engine = document.getElementById('voice-engine').value;
            if (engine === 'browser') initBrowserSpeech(); 
            else if (recognition) { recognition.stop(); recognition = null; }
        }

        function initBrowserSpeech() {
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                recognition = new SpeechRecognition(); 
                recognition.lang = 'zh-HK'; recognition.continuous = true; recognition.interimResults = true; 
                recognition.onstart = () => { isVoiceRecording=true; document.getElementById('voice-btn').classList.add('recording'); updateStatusBar('è†è½ä¸­...', 'recording'); playAudioCue('start'); };
                recognition.onresult = (e) => {
                    let t = ''; for (let i = e.resultIndex; i < e.results.length; ++i) if (e.results[i].isFinal) t += e.results[i][0].transcript;
                    if (t) document.getElementById('user-input').value += (document.getElementById('user-input').value ? " " : "") + t;
                };
                recognition.onerror = () => { stopVoiceInputUI(); playAudioCue('error'); };
                recognition.onend = () => { if(isVoiceRecording) playAudioCue('abort'); stopVoiceInputUI(); };
            }
        }

        function getSupportedMimeType() {
            if (MediaRecorder.isTypeSupported('audio/mp4')) return 'audio/mp4';
            if (MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) return 'audio/webm;codecs=opus';
            if (MediaRecorder.isTypeSupported('audio/webm')) return 'audio/webm';
            return ''; 
        }

        async function startVoiceRecording() {
            ensureAudioContext(); if (isVoiceRecording) return;
            const engine = document.getElementById('voice-engine').value;
            if (engine === 'browser') { if (recognition) try { recognition.start(); } catch(e){} }
            else {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    const mimeType = getSupportedMimeType();
                    const options = mimeType ? { mimeType } : undefined;
                    
                    mediaRecorder = new MediaRecorder(stream, options); 
                    audioChunks = []; 
                    mediaRecorder.ondataavailable = e => audioChunks.push(e.data);
                    mediaRecorder.onstop = async () => { 
                        await processWhisperAudio(new Blob(audioChunks, {type: mediaRecorder.mimeType}), engine, mediaRecorder.mimeType); 
                        stream.getTracks().forEach(t=>t.stop()); 
                    };
                    mediaRecorder.start(); isVoiceRecording = true; document.getElementById('voice-btn').classList.add('recording'); playAudioCue('start');
                } catch (e) { showTransientStatus('éº¥å…‹é¢¨éŒ¯èª¤', 'error'); }
            }
        }

        function stopVoiceRecording() {
            if (!isVoiceRecording) return;
            ensureAudioContext(); isVoiceRecording = false; playAudioCue('success');
            if (document.getElementById('voice-engine').value === 'browser' && recognition) recognition.stop();
            else if (mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop();
        }

        function stopVoiceInputUI() {
            isVoiceRecording = false; document.getElementById('voice-btn').classList.remove('recording');
            if (!document.getElementById('status-bar').classList.contains('busy')) showReadyStatus();
        }

        async function processWhisperAudio(blob, engine, mime) {
            let apiKey = document.getElementById('voice-api-key').value || document.getElementById('api-key').value;
            if (!apiKey) return alert("éœ€ API Key");
            const fd = new FormData(); fd.append('file', blob, `rec.${mime.includes('mp4')?'mp4':'webm'}`);
            fd.append('model', engine === 'openai' ? 'whisper-1' : 'whisper-large-v3');
            updateStatusBar("èªéŸ³è½‰è­¯ä¸­...", "busy");
            try {
                const res = await fetch(engine==='openai'?"https://api.openai.com/v1/audio/transcriptions":"https://api.groq.com/openai/v1/audio/transcriptions", { method:'POST', headers:{'Authorization':`Bearer ${apiKey}`}, body:fd });
                const data = await res.json();
                if (data.text) { document.getElementById('user-input').value += (document.getElementById('user-input').value ? " " : "") + data.text; showReadyStatus(); }
            } catch(e) { window.reportError("Whisper Error", e); }
            finally { stopVoiceInputUI(); }
        }

        function saveVoiceSettings() { localStorage.setItem('voice_engine', document.getElementById('voice-engine').value); localStorage.setItem('voice_api_key', document.getElementById('voice-api-key').value); initVoiceSystem(); }
        function initPasteImage() { document.addEventListener('paste', e => { const f = e.clipboardData.files[0]; if(f && f.type.startsWith('image/')) handleFileSelect(f); }); }
        function initDragAndDrop() { const d = document.getElementById('view-chat'); d.ondragover = e => {e.preventDefault(); d.style.background='#222'}; d.ondragleave = () => d.style.background=''; d.ondrop = e => {e.preventDefault(); d.style.background=''; handleFileSelect(e.dataTransfer.files[0]);}; }
        function initEnterKey() { document.getElementById('user-input').onkeydown = e => { if(e.key==='Enter' && !e.shiftKey && document.getElementById('enter-to-send').checked) { e.preventDefault(); document.getElementById('submit-btn').click(); } }; }
        
        function updateStatusBar(t, s='ready') { 
            const b = document.getElementById('status-bar'); 
            b.setAttribute('aria-live', s === 'error' ? 'assertive' : 'polite');
            b.className = s; 
            b.innerText = t; 
        }

        function showReadyStatus() { updateStatusBar("æº–å‚™å°±ç·’"); }
        function showTransientStatus(m, t='success') { updateStatusBar(m, t==='error'?'error':'ready'); setTimeout(()=>{ if(!document.getElementById('status-bar').classList.contains('busy')) showReadyStatus(); }, 3000); }
        
        function addMessage(role, content) {
            const div = document.createElement('div'); div.className = `message ${role}`; div.tabIndex = -1;
            div.innerHTML = `<h1 class="msg-heading">${role==='user'?'æ‚¨ï¼š':'AIï¼š'}</h1><div class="markdown-body" dir="auto">${role==='user'?content:DOMPurify.sanitize(marked.parse(content))}</div>`;
            document.getElementById('chat-output').appendChild(div); 
            toggleExportButtons(true);
            return div;
        }
        function toggleExportButtons(show) { ['copy-btn','export-txt-btn','export-html-btn'].forEach(id=>document.getElementById(id).classList.toggle('hidden', !show)); }
        
        function handleProviderChange(save=true) {
            const p = document.getElementById('provider-select').value; const c = PROVIDERS[p];
            document.getElementById('api-key').value = localStorage.getItem(`${p}_key`) || "";
            memoryPrompts.chat = localStorage.getItem(`${p}_prompt`) || c.prompt;
            if (currentEditingMode === 'chat') document.getElementById('system-prompt').value = memoryPrompts.chat;
            
            const orSet = document.getElementById('openrouter-settings');
            if(orSet) orSet.classList.toggle('hidden', p!=='openrouter');
            
            allCurrentModels = JSON.parse(localStorage.getItem(`${p}_model_list`)) || c.models;
            handleModelFilter();
            currentActiveModelId = localStorage.getItem(`${p}_model`) || c.defaultModel;
            document.getElementById('refresh-btn').style.display = c.canFetch ? 'block' : 'none';
            if(save) localStorage.setItem('provider', p);
            showReadyStatus();
        }
        function handleModelFilter() {
            const f = document.getElementById('model-filter-input').value.toLowerCase();
            updateModelSelect(allCurrentModels.filter(m=>m.toLowerCase().includes(f)), currentActiveModelId);
        }
        function updateModelSelect(list, active) {
            const s = document.getElementById('model-select'); s.innerHTML = "";
            let found = false;
            list.forEach(m => { const o = document.createElement('option'); o.value=m; o.innerText=m; if(m===active) found=true; s.appendChild(o); });
            s.appendChild(new Option("è‡ªè¡Œè¼¸å…¥...", "CUSTOM"));
            const w = document.getElementById('custom-model-wrapper');
            if(found) { s.value=active; w.classList.add('hidden'); } else { s.value="CUSTOM"; w.classList.remove('hidden'); document.getElementById('custom-model-input').value=active; }
        }
        
        async function fetchOnlineModels() {
            const p = document.getElementById('provider-select').value; const k = document.getElementById('api-key').value;
            if(!k && p!=='openrouter') return alert("éœ€ API Key");
            const btn = document.getElementById('refresh-btn'); btn.innerText="è®€å–ä¸­..."; btn.disabled=true;
            try {
                let list=[];
                if(p==='openrouter') list=(await(await fetch("https://openrouter.ai/api/v1/models")).json()).data.map(m=>m.id);
                else if(p==='gemini') list=(await(await fetch(PROVIDERS[p].listUrl.replace('{KEY}',k))).json()).models.filter(m=>m.supportedGenerationMethods?.includes("generateContent")).map(m=>m.name.replace("models/",""));
                else if(p==='datalab') return; 
                else list=(await(await fetch(PROVIDERS[p].listUrl, {headers:{'Authorization':`Bearer ${k}`}})).json()).data.map(m=>m.id);
                
                if(list && list.length > 0) { 
                    localStorage.setItem(`${p}_model_list`, JSON.stringify(list)); 
                    allCurrentModels=list; 
                    handleModelFilter(); 
                    showTransientStatus("æ¨¡å‹æ¸…å–®å·²æ›´æ–°ä¸¦å„²å­˜"); 
                } else {
                    throw new Error("æ‰¾ä¸åˆ°å¯ç”¨æ¨¡å‹");
                }
            } catch(e) { window.reportError("æ›´æ–°å¤±æ•—", e); } 
            finally { btn.innerText="æ›´æ–°"; btn.disabled=false; }
        }

        function handleModelSelectChange() {
            const s = document.getElementById('model-select');
            if(s.value==="CUSTOM") document.getElementById('custom-model-wrapper').classList.remove('hidden');
            else { document.getElementById('custom-model-wrapper').classList.add('hidden'); currentActiveModelId=s.value; }
        }
        function handleCustomInputChange() { currentActiveModelId = document.getElementById('custom-model-input').value.trim(); }
        
        function saveSettings() {
            const p = document.getElementById('provider-select').value;
            const m = document.getElementById('model-select').value==="CUSTOM" ? document.getElementById('custom-model-input').value : document.getElementById('model-select').value;
            memoryPrompts[currentEditingMode] = document.getElementById('system-prompt').value;
            localStorage.setItem(`${p}_prompt`, memoryPrompts.chat);
            localStorage.setItem('custom_prompt_ocr', memoryPrompts.ocr);
            localStorage.setItem('custom_prompt_translate', memoryPrompts.translate);
            localStorage.setItem(`${p}_key`, document.getElementById('api-key').value.trim());
            localStorage.setItem(`${p}_model`, m); currentActiveModelId = m;
            localStorage.setItem('timeout_setting', document.getElementById('timeout-setting').value);
            localStorage.setItem('enter_to_send', document.getElementById('enter-to-send').checked);
            localStorage.setItem('openrouter_web_search', document.getElementById('openrouter-web-search').checked);
            saveVoiceSettings(); 
            showTransientStatus("è¨­å®šå·²å„²å­˜");
            switchTab(lastActiveTabId || 'chat');
        }

        function restoreDefaults() {
            const p = document.getElementById('provider-select').value; 
            memoryPrompts.chat = PROVIDERS[p].prompt;
            memoryPrompts.ocr = DEFAULT_OCR_PROMPT;
            memoryPrompts.translate = DEFAULT_TRANSLATE_PROMPT;
            localStorage.removeItem(`${p}_prompt`);
            localStorage.removeItem('custom_prompt_ocr');
            localStorage.removeItem('custom_prompt_translate');
            document.getElementById('system-prompt').value = memoryPrompts[currentEditingMode];
            handleProviderChange(true); 
            showTransientStatus("å·²é‚„åŸé è¨­å€¼");
        }

        function copyResult() { navigator.clipboard.writeText(document.getElementById('chat-output').innerText).then(()=>showTransientStatus("å·²è¤‡è£½")); }
        function copyErrorLog() { navigator.clipboard.writeText(document.getElementById('error-log-area').value).then(()=>showTransientStatus("æ—¥èªŒå·²è¤‡è£½")); }
        function exportChat(fmt) {
            const c = document.getElementById('chat-output');
            const b = new Blob([fmt==='html'?`<html><body>${c.innerHTML}</body></html>`:c.innerText], {type:fmt==='html'?'text/html':'text/plain'});
            const a = document.createElement('a'); a.href = URL.createObjectURL(b); a.download = `export.${fmt}`; a.click();
        }
        
        async function handleFileSelect(f) {
            f = f || document.getElementById('file-input').files[0];
            if(f) { 
                selectedFile = f; 
                document.getElementById('upload-btn').innerText = `å·²é¸: ${f.name.substring(0,8)}...`;
                document.getElementById('upload-btn').classList.add('active'); 
                
                if (f.type === 'application/pdf') {
                }

                const isPaused = document.getElementById('pause-send').checked;
                if (!isPaused) {
                    showTransientStatus("å³å°‡è‡ªå‹•ç™¼é€...");
                    setTimeout(() => {
                        const event = new Event('submit', { cancelable: true });
                        document.querySelector('form').dispatchEvent(event); 
                    }, 700);
                } else {
                    showTransientStatus("æª”æ¡ˆå·²åŠ å…¥ï¼Œè«‹è¼¸å…¥æ–‡å­—å¾Œç™¼é€"); 
                    document.getElementById('user-input').focus();
                }
            }
        }

        function readFileAsBase64(f) { return new Promise((r,j)=>{const rd=new FileReader(); rd.onload=()=>r(rd.result.split(',')[1]); rd.onerror=j; rd.readAsDataURL(f);}); }
        function readFileAsText(f) { return new Promise((r,j)=>{const rd=new FileReader(); rd.onload=()=>r(rd.result); rd.onerror=j; rd.readAsText(f);}); }

        async function handleSubmit(e) {
            e.preventDefault(); ensureAudioContext();
            const txt = document.getElementById('user-input').value.trim();
            if(!txt && !selectedFile) return showTransientStatus("è«‹è¼¸å…¥å…§å®¹", 'error');
            
            playAudioCue('start'); updateStatusBar("è™•ç†ä¸­...", 'busy');
            const btn = document.getElementById('submit-btn'); btn.disabled=true;
            const ctl = new AbortController(); const tm = setTimeout(()=>ctl.abort(), document.getElementById('timeout-setting').value*1000);
            
            try {
                let input = txt; 
                let fileData = null; 
                let mime = null;

                if(selectedFile) {
                    if(selectedFile.type === 'application/pdf') {
                        const pdfText = await extractTextFromPDF_Accurate(selectedFile);
                        if(pdfText) { 
                            const cleanPdfText = UniversalTextNormalizer.normalize(pdfText);
                            input = `[æ–‡ä»¶å…§å®¹]:\n${cleanPdfText}\n\n[ç”¨æˆ¶æå•]:\n${txt}`;
                            stickyMemory = { type: 'text', content: cleanPdfText, count: 3 };
                        }
                    } 
                    else if (selectedFile.type.startsWith('image/')) {
                        fileData = await readFileAsBase64(selectedFile); 
                        mime = selectedFile.type;
                        stickyMemory = { type: 'image', content: fileData, mime: mime, count: 3 };
                    }
                    else if (selectedFile.type.startsWith('text/') || selectedFile.name.endsWith('.txt') || selectedFile.name.endsWith('.md') || selectedFile.name.endsWith('.js') || selectedFile.name.endsWith('.html') || selectedFile.name.endsWith('.css') || selectedFile.name.endsWith('.py')) {
                         const fileText = await readFileAsText(selectedFile);
                         input = `[æ–‡ä»¶å…§å®¹ (${selectedFile.name})]:\n${fileText}\n\n[ç”¨æˆ¶æå•]:\n${txt}`;
                         stickyMemory = { type: 'text', content: fileText, count: 3 };
                    }
                } 
                else if (stickyMemory.count > 0 && stickyMemory.content) {
                    stickyMemory.count--;
                    if (stickyMemory.type === 'image') {
                        fileData = stickyMemory.content;
                        mime = stickyMemory.mime;
                        showTransientStatus(`åœ–ç‰‡è¿½å•æ¨¡å¼ (å‰©é¤˜ ${stickyMemory.count} æ¬¡)`);
                    } else if (stickyMemory.type === 'text') {
                        input = `[æ–‡ä»¶å…§å®¹å›é¡§]:\n${stickyMemory.content}\n\n[ç”¨æˆ¶è¿½å•]:\n${txt}`;
                        showTransientStatus(`æ–‡ä»¶è¿½å•æ¨¡å¼ (å‰©é¤˜ ${stickyMemory.count} æ¬¡)`);
                    }
                }

                addMessage('user', txt || (selectedFile ? `[æª”æ¡ˆ: ${selectedFile.name}]` : "[è¿½å•æ¨¡å¼]"));
                
                document.getElementById('user-input').value = ""; 
                document.getElementById('upload-btn').innerText = "ğŸ“ æª”æ¡ˆ/æ‹ç…§"; 
                document.getElementById('upload-btn').classList.remove('active');
                selectedFile = null;
                
                const res = await callAI(
                    document.getElementById('provider-select').value, 
                    document.getElementById('system-prompt').value,
                    chatHistory, 
                    input, 
                    fileData, 
                    mime, 
                    ctl.signal
                );

                const aiMsg = addMessage('assistant', UniversalTextNormalizer.normalize(res)); 
                setTimeout(() => { aiMsg.focus(); }, 100);

                chatHistory.push({role: 'user', content: input}); 
                chatHistory.push({role: 'assistant', content: res});
                if (chatHistory.length > 20) chatHistory = chatHistory.slice(-20);

                playAudioCue('success'); showReadyStatus();
            } catch(e) { window.reportError("Submit Error", e); } finally { clearTimeout(tm); btn.disabled=false; }
        }

        async function callAI(p, sysPrompt, history, txt, file, mime, sig, ovModel, ovKey) {
            const k = ovKey || document.getElementById('api-key').value; 
            const m = ovModel || currentActiveModelId;
            
            if(!k) throw new Error("éœ€ API Key");

            // --- å€å¡Š 1: Chandra OCR (Datalab) å°ˆç”¨é‚è¼¯ [ä¿®æ­£ç‰ˆ] ---
            // æ”¹ç”¨ Marker æ¥å£ä»¥å–å¾—æ­£ç¢ºçš„ Markdown æ ¼å¼
            if (p === 'datalab') {
                if (!file) throw new Error("Chandra OCR åƒ…æ”¯æ´æª”æ¡ˆ/åœ–ç‰‡è¼¸å…¥");
                
                const byteCharacters = atob(file);
                const byteNumbers = new Array(byteCharacters.length);
                for (let i = 0; i < byteCharacters.length; i++) {
                    byteNumbers[i] = byteCharacters.charCodeAt(i);
                }
                const byteArray = new Uint8Array(byteNumbers);
                const blob = new Blob([byteArray], {type: mime || 'application/pdf'});

                const formData = new FormData();
                formData.append('file', blob);
                formData.append('output_format', 'markdown'); // å¼·åˆ¶è¼¸å‡º Markdown
                
                // æ”¹ç‚ºä½¿ç”¨ Marker æ¥å£ (Marker æ˜¯ Chandra çš„æ–‡ä»¶è™•ç†æ ¸å¿ƒ)
                const postReq = await fetch(USER_WORKER_URL, {
                    method: 'POST',
                    headers: { 
                        'X-Api-Key': k,
                        'X-Target-Url': 'https://www.datalab.to/api/v1/marker' // ä¿®æ­£ç‚º Marker
                    },
                    body: formData,
                    signal: sig
                });
                
                if (!postReq.ok) {
                    const errText = await postReq.text();
                    throw new Error(`Datalab Upload Failed: ${errText}`);
                }
                
                const postData = await postReq.json();
                const requestId = postData.request_id;
                
                while (true) {
                    if (sig && sig.aborted) throw new Error("ä½¿ç”¨è€…å–æ¶ˆæ“ä½œ");
                    
                    await new Promise(r => setTimeout(r, 1000));
                    
                    const checkReq = await fetch(USER_WORKER_URL, {
                        method: 'GET', 
                        headers: { 
                            'X-Api-Key': k,
                            'X-Target-Url': `https://www.datalab.to/api/v1/marker/${requestId}` // ä¿®æ­£ç‚º Marker æŸ¥è©¢
                        },
                        signal: sig
                    });
                    
                    if (!checkReq.ok) throw new Error("Datalab Check Failed");
                    
                    const checkData = await checkReq.json();
                    
                    if (checkData.status === 'complete') {
                        // ä¿®æ­£è®€å–è·¯å¾‘ï¼šMarker æ¥å£å›å‚³çš„ markdown é€šå¸¸åœ¨é ‚å±¤æˆ– result å…§
                        // ç‚ºäº†ä¿éšªï¼Œæˆ‘å€‘æª¢æŸ¥å¤šå€‹å¯èƒ½çš„ä½ç½®
                        const resultMd = checkData.markdown || (checkData.result ? checkData.result.markdown : null) || JSON.stringify(checkData);
                        return resultMd;
                    } else if (checkData.status === 'failed') {
                        throw new Error(`Datalab Processing Failed: ${checkData.error || 'Unknown error'}`);
                    }
                }
            }
            
            // --- å€å¡Š 2: é€šç”¨ Chat AI (Gemini, OpenRouter...) ---
            // æ¨™é ­æ¨¡å¼è½‰ç™¼
            
            let url = "", headers = { "Content-Type": "application/json", "Authorization": `Bearer ${k}` };
            let bodyObj = {};
            
            if(p === 'gemini') {
                url = `https://generativelanguage.googleapis.com/v1beta/models/${m}:generateContent?key=${k}`;
                delete headers['Authorization']; 
                
                let bodyContent = { 
                    system_instruction: { parts: [{ text: sysPrompt }] },
                    contents: [] 
                };
                history.forEach(msg => {
                    bodyContent.contents.push({
                        role: msg.role === 'user' ? 'user' : 'model',
                        parts: [{ text: msg.content }]
                    });
                });
                let currentParts = [];
                if (file) {
                    currentParts.push({ inline_data: { mime_type: mime || "image/jpeg", data: file } });
                }
                currentParts.push({ text: txt });
                bodyContent.contents.push({ role: "user", parts: currentParts });
                
                bodyObj = bodyContent;
            } 
            else {
                if (p === 'openrouter') {
                    url = "https://openrouter.ai/api/v1/chat/completions";
                    headers['HTTP-Referer'] = 'https://ai-vision.app'; 
                    headers['X-Title'] = 'AI Vision';
                    if(document.getElementById('openrouter-web-search').checked) bodyObj.plugins = [{id:"web"}];
                } else if (p === 'mistral') url = "https://api.mistral.ai/v1/chat/completions";
                else if (p === 'perplexity') url = "https://api.perplexity.ai/chat/completions";
                else if (p === 'openai') url = "https://api.openai.com/v1/chat/completions";
                else url = "https://api.groq.com/openai/v1/chat/completions";

                let messages = [];
                messages.push({ role: "system", content: sysPrompt });
                history.forEach(msg => {
                    messages.push({ role: msg.role, content: msg.content });
                });
                let currentContent = [];
                if (file) {
                    currentContent.push({ type: "text", text: txt });
                    currentContent.push({ type: "image_url", image_url: { url: `data:${mime};base64,${file}` } });
                } else {
                    currentContent = txt;
                }
                messages.push({ role: "user", content: currentContent });

                bodyObj = { ...bodyObj, model: m, messages: messages, temperature: 0.3 };
            }

            // --- æ ¸å¿ƒä»£ç†è«‹æ±‚ ---
            headers['X-Target-Url'] = url; 

            const r = await fetch(USER_WORKER_URL, {
                method: 'POST',
                headers: headers, 
                body: JSON.stringify(bodyObj), 
                signal: sig
            });

            if(!r.ok) throw new Error(await r.text());
            const d = await r.json();
            
            return p === 'gemini' ? (d.candidates?.[0]?.content?.parts?.[0]?.text) : (d.choices?.[0]?.message?.content);
        }
    </script>
</body>
</html>